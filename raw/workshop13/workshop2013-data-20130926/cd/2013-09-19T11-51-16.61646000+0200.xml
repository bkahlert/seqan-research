<?xml version="1.0" encoding="UTF-8"?>
<cd>
   <profile>
      <studies>Molecular biology</studies>
      <workStyle>pragmatic</workStyle>
      <usageDurationNumber>2</usageDurationNumber>
      <usageDurationUnit>days</usageDurationUnit>
      <proficiency>Bloody beginner</proficiency>
      <similiarSystems>I have created my own set of sequence analysis tools</similiarSystems>
      <mainPurpose>I don't really use it yet.</mainPurpose>
      <typicalProducts>I did not create a product yet. I have tried to implement two algorithms I have created and implemented before in C, but failed.</typicalProducts>
      <durability>other</durability>
      <durabilityOther>No products yet.</durabilityOther>
      <exploringPercentageTime>1</exploringPercentageTime>
      <implementingPercentageTime>1</implementingPercentageTime>
      <understandingPercentageTime>1</understandingPercentageTime>
      <reorganisingPercentageTime>1</reorganisingPercentageTime>
      <viscosity>Refactoring, because you need to take care of types, type casting, templates etc. 99% of the cases when I refactor something first version will not even compile.</viscosity>
      <workStepUnit>As anyone efficient with shell programming can tell you, a lot.&#xD;
&#xD;
As for SeqAn, some things seem to be extremely efficient (e.g. the implemented alignment and search algorithms), but the typing / templates seem to be extremely messy and require a lot of overhead.</workStepUnit>
      <hardMentalOperations>Yes, remembering all the templates and variants of types and templates and trying to figure out what is the difference between say Dna5 and Dna5String.</hardMentalOperations>
      <errorProneness>Typing. 99% error messages that I have seen until now were due to incorrect types.&#xD;
&#xD;
Ad 2: Yep, SeqAn makes me feel stupid. Example: using incorrect type and calling incorrect variant of a function.</errorProneness>
      <domainCorrespondence>No idea.</domainCorrespondence>
      <roleExpressiveness>No. For me, this is extremely un-intuitive and requires a lot of reading of the documentation and mostly I end up copying code snippets from other apps without understanding why they work and why what I initially wrote doesn't.&#xD;
&#xD;
Second question: yes, most of the time I copy code snippets that seem to do what I need. I have little understanding why in a particular place a particular form or variant or an idiom is used in place of another one.</roleExpressiveness>
      <progressiveEvaluation>What do you mean by "progress"?</progressiveEvaluation>
      <provisionality>No, for that I'd use Perl or Python or even C. Something that is not necessarily fast, but doesn't require me to spend time on getting type casting right.&#xD;
&#xD;
Once I would see that the algorithm works, I'd consider moving to SeqAn for speed.</provisionality>
      <prematureCommitment>Not enough experience to answer this. The two algorithms which I tried to implement (and failed) made me go through tons of documentations before I even finished the basic I/O operations and argument parsing. Problems with types made connecting my old code with SeqAn problematic to say the least.</prematureCommitment>
      <consistency>I'd expect that functions that do unrelated things would have clearly distinguishable names.</consistency>
      <abstractionLevel>Some yes. Sort of. I assume that the fact that I don't like them reflects my lack of experience rather than their faults.</abstractionLevel>
      <learningStyle>ad 1. I'd put it like this: it was easier for me to understand S4 programming framework in R or how BWT works than to figure out what how to cast a variable to its correct type. &#xD;
&#xD;
ad 2. tutorials.&#xD;
&#xD;
ad 3. a less confusing API reference. And a book: a properly written hard-copy book-manual-reference. Like the R book.</learningStyle>
      <personal>It is very hard to really criticize something when (a) you have very little experience and (b) people have invested obviously copious amounts of work in writing documentation and tutorials. However, while I found the tutorials easy to follow and to complete, I found it very hard to start my own work. Likely I'd have to speed a few weeks just memorizing the available idioms such that I'd not have to spend time trying to figure out whether for reading a certain format I need to use C++ or there is a function implemented for this. I generally like SeqAn and at first had a very good time writing simple apps. But when I tried something more complex, I immediately run into a wall.&#xD;
&#xD;
To sum it up: SeqAn requires little thought (this is a complement! that means it is easy to understand), but lots of memorization. I would not say it has a steep learning curve, I'd say the opposite is true: it is easy at the beginning, but is becomes rapidly much harder when the problems complexity arises.</personal>
      <questionnaire>Good. How was it for you to read this questionnaire?</questionnaire>
   </profile>
</cd>
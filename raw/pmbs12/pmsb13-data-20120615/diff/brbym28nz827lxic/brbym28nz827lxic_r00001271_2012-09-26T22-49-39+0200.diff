diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/dreme.h ./sandbox/meyerclp/apps/dreme/dreme.h
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/dreme.h	2012-09-26 22:05:28.945400000 +0200
+++ ./sandbox/meyerclp/apps/dreme/dreme.h	2012-09-26 22:49:32.825000000 +0200
@@ -89,8 +89,8 @@
 };
 
 
-struct Euklidisch_;
-typedef Tag<Euklidisch_> Euklidisch;
+struct Euclid_;
+typedef Tag<Euclid_> Euclid;
 
 struct Pearson_;
 typedef Tag<Pearson_> Pearson;
@@ -151,7 +151,7 @@
 void BuildWeightMatrix(Seq &seq);
 void BuildInformationContentMatrix(Seq &seq);
 double ComparePWM(std::map<Iupac,double>  &freqMatrix1,std::map<Iupac,double>  &freqMatrix2, Entropy const & tag);
-double ComparePWM(std::map<Iupac,double>  &freqMatrix1,std::map<Iupac,double>  &freqMatrix2, Euklidisch const & tag);
+double ComparePWM(std::map<Iupac,double>  &freqMatrix1,std::map<Iupac,double>  &freqMatrix2, Euclid const & tag);
 double ComparePWM(std::map<Iupac,double>  &freqMatrix1,std::map<Iupac,double>  &freqMatrix2, Pearson const & tag);
 void PWMClustering(String< std::map<unsigned int,std::map<Iupac,double> > > &allPWMs, String<Cluster> &cluster,String<int> &traceback);
 void UpdateDistantMatrix(int n, int x, int y, std::vector<std::vector<String<double > > > &compare, CompleteLinkage const & tag);
@@ -359,9 +359,9 @@
 		temp = Kmer;// reset temp
 		resetTemp = IMap.IupacMapInversed[replace];
 		*tempIt = *replaceIt;
-		//if not end call fkt. with temp 
-		// if end call find --> &counter
-		tempIttemp=tempIt;//der rekursive aufruf mit diesem, da die schleife mit tempIt weitergehen soll
+		//if not end, call fkt. with temp 
+		// if end, call find --> &counter
+		tempIttemp=tempIt;//the  rekursive function-call with tempIttemp, because the loop needs tempIt 
 		if(tempIt+1!=end(temp)){
 			loopOverKmer(seq,temp,temp,++tempIttemp,finder,counter,CounterV,IMap);
 
@@ -377,7 +377,7 @@
 					
 	}
 				
-			//}
+			
 
 
 
@@ -393,14 +393,14 @@
 
 					clear(finder);
 					while(find(finder,temp)){//search the current Kmer in all sequences
-						//std::cout<<'[' <<beginPosition(finder)<<','<<endPosition(finder)<<")\t"<<infix(finder)<<std::endl;//Debug
 						
-						if(seq.c>1){//nur im foreground
+						
+						if(seq.c>1){//check only in foreground
 							clear(seq.results);
 							findIntervals(seq.intervalTrees[beginPosition(finder).i1], beginPosition(finder).i2, endPosition(finder).i2, seq.results);
 						}
 						if(CounterV[beginPosition(finder).i1] == 0 && length(seq.results)==0){//count number of sequences containing the motif, not the occurrences to avoid problems with self-overlapping
-							//ansonsten müsste das array noch einmal durch gegangen werden und an jeder stellt !=0 ++
+							
 							++CounterV[beginPosition(finder).i1];
 							++CounterV[seq.SeqsNumber];//last Position in CounterV is cumulated sum
 							++counter;
@@ -429,7 +429,6 @@
 	
 			
 			String<Iupac> temp;	
-			
 			Iterator<String<Iupac> >::Type tempIt;
 			
 			temp=Kmer;
@@ -437,14 +436,12 @@
 			unsigned int counter=0;
 			std::vector<int> CounterV(seq.SeqsNumber+1,0);//counter for storing 1 or 0 for each Seq + the cumulated sum of the counter in the last field
 			
-			//std::cout<<"Kmer "<<Kmer<<std::endl;
+			
 			loopOverKmer(seq,temp,Kmer,tempIt,finder,counter,CounterV,IMap);
 
 			
 			
 			seqCounter[Kmer]=counter;
-			//std::cout<<Kmer<<" "<<seqCounter[Kmer]<<"   ";
-			//std::cout<<temp<<" "<<CounterV[SeqsNumber]<<std::endl;
 			CounterV.clear();
 			
 			/*
@@ -493,11 +490,12 @@
 				Finder<Index<StringSet<String<Dna5> > > > &finder,
 				unsigned int &counter,
 				std::vector<int> &CounterV){
+
 	typedef IntervalAndCargo<unsigned, unsigned> TInterval;				
 	clear(finder);
-	//std::cout<<temp<<" vor-while"<<std::endl;
+	
 	while(find(finder,temp)){//search the current Kmer in all sequences
-		if(seq.c==1){//nur im ersten Schritt in Intervals speichern, danach kann direkt an den Tree angefügt werden
+		if(seq.c==1){//if c==1 save in Intervals, otherwise add direct to Tree 
 			appendValue(seq.intervals[beginPosition(finder).i1], TInterval(beginPosition(finder).i2, endPosition(finder).i2, 0)); 
 		}
 		else if(seq.c>1)
@@ -510,8 +508,8 @@
 		}
 			
 	}
-	for( unsigned int k =0;k< length(temp);++k){//berechnet Frequenz der Nukleotide, wobei jedes Motiv wieder nur einmal pro Sequenz zählt!
-		seq.freqMatrix[k][temp[k]]+=CounterV[seq.SeqsNumber]; //GCAGCA --> counter der einzelnen wird um die gleiche anzahl hochgezählt, GCAGTA --> usw. Nicht-Wildcards haben W'keit 1
+	for( unsigned int k =0;k< length(temp);++k){//computes frequency of the nucleotides, each motif only once per sequence
+		seq.freqMatrix[k][temp[k]]+=CounterV[seq.SeqsNumber]; //GCAGCA -->adds the counter of the motif to each nucleotide-counter,the same for the next motif GCAGTA --> etc. Non-Wildcards probability=1
 	}
 	
 	CounterV.clear();
@@ -522,11 +520,12 @@
 				Finder<Index<StringSet<String<Dna5> > > > &finder,
 				unsigned int &counter,
 				std::vector<int> &CounterV){
+
 	typedef IntervalAndCargo<unsigned, unsigned> TInterval;				
 	clear(finder);
-	//std::cout<<temp<<" vor-while"<<std::endl;
+	
 	while(find(finder,temp)){//search the current Kmer in all sequences
-		if(seq.c==1){//nur im ersten Schritt in Intervals speichern, danach kann direkt an den Tree angefügt werden
+		if(seq.c==1){//if c==1 save in Intervals, otherwise add direct to Tree 
 			appendValue(seq.intervals[beginPosition(finder).i1], TInterval(beginPosition(finder).i2, endPosition(finder).i2, 0)); 
 		}
 		else if(seq.c>1)
@@ -539,8 +538,8 @@
 		}
 			
 	}
-	for( unsigned int k =0;k< length(temp);++k){//berechnet Frequenz der Nukleotide, wobei jedes Motiv wieder nur einmal pro Sequenz zählt!
-		seq.freqMatrix[k][temp[k]]+=CounterV[seq.SeqsNumber]; //GCAGCA --> counter der einzelnen wird um die gleiche anzahl hochgezählt, GCAGTA --> usw. Nicht-Wildcards haben W'keit 1
+	for( unsigned int k =0;k< length(temp);++k){//computes frequency of the nucleotides, each motif only once per sequence
+		seq.freqMatrix[k][temp[k]]+=CounterV[seq.SeqsNumber];//GCAGCA -->adds the counter of the motif to each nucleotide-counter,the same for the next motif GCAGTA --> etc. Non-Wildcards probability=1
 	}
 	
 	CounterV.clear();
@@ -561,45 +560,41 @@
 			Iterator<String<Dna5> >::Type replaceIt;
 			Iterator<String<Iupac> >::Type tempIttemp;
 			
-			char resetTemp;//bei mehr als einer wildcard, müssen die weiter hinten liegenden nach abarbeitung resetet werden, ansonsten werden diese im nächsten schritt übergangen
+			char resetTemp;//bei mehr als einer wildcard, müssen die weiter hinten liegenden nach Abarbeitung resetet werden, ansonsten werden diese im nächsten schritt übergangen
 
-			if(tempIt==end(temp)) return;//&&(tempIt+1!=end(temp))
-			/*freq[*tempIt]=1;
-			freqMatrix[pos]=freq;
-			freqMatrix[pos]['A']=1;
-			freq.clear();*/
-			//std::cout<<" "<<*tempIt<<" ";
+			if(tempIt==end(temp)) return;
+			
 			if((*tempIt == 'A' || *tempIt == 'C' ||*tempIt == 'G' ||*tempIt == 'T')){
 				loopOverTopKmer(seq,temp,temp,++tempIt,finder,counter,CounterV,IMaps);//only replace the position with a wildcard
-				return;//nach diesem schritt immer return, sonst gelangt man in eine loop
+				return;//always return-->loop otherwise
 			}
 				
 			
 				replace=IMaps.IupacMapReplaceReversed[*tempIt];
 				replaceIt = begin(replace);	
 				for(;replaceIt!=end(replace);++replaceIt){
-					//std::cout<<" "<<temp<<" "<<Kmer<<" "<<*replaceIt<<std::endl;
+					
 					temp = Kmer;// reset temp
-					resetTemp = IMaps.IupacMapInversed[replace]; //falls Y ersetzt wird, ist replace CT --> also resetTemp wieder Y
-					//std::cout<<" resetTemp "<<resetTemp<<std::endl;
+					resetTemp = IMaps.IupacMapInversed[replace]; //if Y gets replaced-->  replace = CT -->  resetTemp = Y
+					
 					*tempIt = *replaceIt;
-					//std::cout<<" re "<<temp<<" ";
-					tempIttemp=tempIt;//der rekursive aufruf mit diesem, da die schleife mit tempIt weitergehen soll
-				//	std::cout<<" "<<temp<<" "<<Kmer<<" "<<*replaceIt<<std::endl;
+					
+					tempIttemp=tempIt;//the rekursive function call with tempIttemp--> loop needs tempIt 
+			
 					
 					if(tempIt+1!=end(temp)){
-						//std::cout<<"vor if "<<temp<<std::endl;
+						
 						loopOverTopKmer(seq,temp,temp,++tempIttemp,finder,counter,CounterV,IMaps);
-						//std::cout<<*tempIttemp<<" tempittemp "<<std::endl;
+						
 					}
-					//zu häufig aufgerufen
-					if((*tempIttemp == 'A' || *tempIttemp == 'C' || *tempIttemp == 'G' || *tempIttemp == 'T' || tempIttemp == end(temp))){//falls nicht, dann kann dies übersprungen werden
+					
+					if((*tempIttemp == 'A' || *tempIttemp == 'C' || *tempIttemp == 'G' || *tempIttemp == 'T' || tempIttemp == end(temp))){
 						/**
 						posTemp gibt die Stelle an, an der man sich grad befindet 
-						--> freqMatrix enthält für jede Position die W'keit für ACGT
+						--> freqMatrix enthält für jede Position des Motivs die W'keit für ACGT
 						--> counter ist die Anzahl wie oft das Wildcard Motiv insgesamt gefunden wurde
 						--> CounterV an letzter Stelle die Anzahl für das jeweilige nicht-Wildcard Motiv
-						--> bei GSAKYA z.B. als Motiv wird jedes Motiv bei 'S' vier mal gesucht(durch die anderen 2 Wildcards)
+						--> bei GSAKYA z.B. als Motiv wird jedes Motiv bei 'S' vier mal gesucht(durch die anderen 2 Wildcards K und Y)
 						--> CounterV für 1 bis posTemp aufaddieren --> in freqMatrix und zwar für die jeweiligen *tempIt-chars
 						--> am Ende alle durch counter teilen --> aufpassen, für jeweilige pos gibts verschiedene counter
 						--> FindKmer wird nur mit ganzen aufgerufen, also alle addieren, dann ist der counter auch gleich?
@@ -609,7 +604,7 @@
 						
 					}
 					*tempIt=resetTemp;
-					//if ende von replaceIt, dann begin(replace) in temp speichern und mitübergeben--> referenz?
+					
 				}
 
 
@@ -622,8 +617,8 @@
 							String<Iupac> &Kmer,
 							Seq &seq, 
 							IupacMaps &IMaps){
-			//std::cout<<Kmer<<std::endl;
-			//freqMatrix -->unsigned int = position in Kmer, position 1 in map = prob. for A, pos. 2 = prob. for C...
+			
+			//freqMatrix -->unsigned int = position in Kmer; position 1 in map = prob. for A, pos. 2 = prob. for C...
 			appendValue(seq.allMotifs,Kmer,Exact());
 								
 			String<Iupac> temp;	
@@ -639,17 +634,8 @@
 			
 			loopOverTopKmer(seq,temp,Kmer,tempIt,finder,counter,CounterV,IMaps);
 			CounterV.clear();
-			//loopOver funktionier, aber jetzt wird der counter nicht mehr richtig berechnet --> fixen  + andere loop anpassen
-			//Durch die wildcards mehrere Vorkommen pro Sequence möglich:
-			//seqCounter[temp]=CounterV[seq.SeqsNumber];
-					
-			//std::cout<<temp<<" "<<*replaceIt<<" ";
 			
-					
-					
-			
-				
-			if(counter>0){//normalisieren des Counters
+			if(counter>0){//normalize counter
 				
 				
 				for( unsigned int k =0;k< length(temp);++k){
@@ -671,13 +657,13 @@
 }
 
 /**
-		Version für nicht generalisierte
+		Computes PWM --> not-generalized Kmer-Version
 **/
 void BuildFrequencyMatrix(  Finder<Index<StringSet<String<Dna5> > > > &finder,
 							String<Dna5> &Kmer,
 							Seq &seq, 
 							IupacMaps &IMaps){
-			//std::cout<<Kmer<<std::endl;
+			
 			//freqMatrix -->unsigned int = position in Kmer, position 1 in map = prob. for A, pos. 2 = prob. for C...
 			
 			appendValue(seq.allMotifs,Kmer,Exact());
@@ -697,7 +683,7 @@
 			
 			
 				
-			if(counter>0){//normalisieren des Counters
+			if(counter>0){//normalize counter
 				
 				
 				for( unsigned int k =0;k< length(temp);++k){
@@ -722,6 +708,7 @@
 //FreqMatrix output
 void PrintMap(  Seq &seq,
 				bool foreground){
+
 	std::map<Iupac,double> freq;
 	std::cout<<std::endl;
 	if(foreground)
@@ -740,22 +727,8 @@
 
 }
 
-void BuildWeightMatrix(Seq &seq){
-
-	
-	
-	for(unsigned int j=0;j<length(seq.freqMatrix);++j){
-		seq.weightMatrix[j]['A'] = log(seq.freqMatrix[j]['A']/seq.frequencies[0]);
-		seq.weightMatrix[j]['C'] = log(seq.freqMatrix[j]['C']/seq.frequencies[1]);
-		seq.weightMatrix[j]['G'] = log(seq.freqMatrix[j]['G']/seq.frequencies[2]);
-		seq.weightMatrix[j]['T'] = log(seq.freqMatrix[j]['T']/seq.frequencies[3]);
-	}
-
 
 
-
-}
-
 void saveData(Seq &seq,std::ofstream &PWM,unsigned c){
 
 	std::cout<<"saveData"<<std::endl;
@@ -810,6 +783,28 @@
 
 }
 
+/*****
+		Computes weightMatrix -->needed for InformationContentMatrix
+*****/
+void BuildWeightMatrix(Seq &seq){
+
+	
+	
+	for(unsigned int j=0;j<length(seq.freqMatrix);++j){
+		seq.weightMatrix[j]['A'] = log(seq.freqMatrix[j]['A']/seq.frequencies[0]);
+		seq.weightMatrix[j]['C'] = log(seq.freqMatrix[j]['C']/seq.frequencies[1]);
+		seq.weightMatrix[j]['G'] = log(seq.freqMatrix[j]['G']/seq.frequencies[2]);
+		seq.weightMatrix[j]['T'] = log(seq.freqMatrix[j]['T']/seq.frequencies[3]);
+	}
+
+
+
+
+}
+/*****
+		computes the information content matrix of a motif
+*****/
+
 void BuildInformationContentMatrix(Seq &seq){
 
 	double e = 3/(2*log(2)*seq.SeqsNumber);//4-1 = 3, 4= Anzahl Nukleotide --> small-error correction
@@ -829,7 +824,7 @@
 
 	
 	/****
-			Für die übergebenen Spalten der Matrizen wird die Entropy berechnet
+			Für die übergebenen Spalten der Matrizen wird die Entropy(=Kullback-Leibler-Divergenz) berechnet
 			Eintrag ist = 0, wenn die Werte identisch sind. Je größer die Zahl, desto unterschiedlicher die Werte
 			Was wenn Wert = Hintergrundverteilung? --> Eintrag wäre = 0, obwohl das nichts mit dem Motiv zu tun hat
 
@@ -849,16 +844,13 @@
 	columnEntropy  = columnEntropy/2;
 
 	
-		
-
-	
 	return columnEntropy;
 
 }
 
-double ComparePWM(std::map<Iupac,double>  &freqMatrix1,std::map<Iupac,double>  &freqMatrix2, Euklidisch const & tag){
+double ComparePWM(std::map<Iupac,double>  &freqMatrix1,std::map<Iupac,double>  &freqMatrix2, Euclid const & tag){
 	/***
-			Werte von 0 = identisch bis sqrt(2*sum(column))/4 ?
+			Computes the euclidean distance
 		
 	***/
 

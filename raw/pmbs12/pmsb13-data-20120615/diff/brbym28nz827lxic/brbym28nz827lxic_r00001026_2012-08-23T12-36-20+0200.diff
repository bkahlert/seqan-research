diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/dreme.h ./sandbox/meyerclp/apps/dreme/dreme.h
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/dreme.h	2012-08-21 15:04:13.734707000 +0200
+++ ./sandbox/meyerclp/apps/dreme/dreme.h	2012-08-23 12:35:54.104941000 +0200
@@ -97,9 +97,6 @@
 struct Pearson_;
 typedef Tag<Pearson_> Pearson;
 
-struct Mahalanobis_;
-typedef Tag<Mahalanobis_> Mahalanobis;
-
 struct Entropy_;
 typedef Tag<Entropy_> Entropy;
 
@@ -155,8 +152,9 @@
 void BuildFrequencyMatrix( Finder<Index<StringSet<String<Dna5> > > > &finder,String<Dna5> &Kmer,Seq &seq, IupacMaps &IMaps);
 void BuildWeightMatrix(Seq &seq);
 void BuildInformationContentMatrix(Seq &seq);
-double ComparePWM(Seq &seq,std::map<unsigned int,std::map<Iupac,double> > &freqMatrix1,std::map<unsigned int,std::map<Iupac,double> > &freqMatrix2, Entropy const & tag);
-double ComparePWM(Seq &seq,std::map<unsigned int,std::map<Iupac,double> > &freqMatrix1,std::map<unsigned int,std::map<Iupac,double> > &freqMatrix2, Euklidisch const & tag);
+double ComparePWM(std::map<Iupac,double>  &freqMatrix1,std::map<Iupac,double>  &freqMatrix2, Entropy const & tag);
+double ComparePWM(std::map<Iupac,double>  &freqMatrix1,std::map<Iupac,double>  &freqMatrix2, Euklidisch const & tag);
+double ComparePWM(std::map<Iupac,double>  &freqMatrix1,std::map<Iupac,double>  &freqMatrix2, Pearson const & tag);
 void PWMClustering(String< std::map<unsigned int,std::map<Iupac,double> > > &allPWMs, String<Cluster> &cluster,String<int> &traceback);
 void UpdateDistantMatrix(int n, int x, int y, std::vector<std::vector<String<double > > > &compare, CompleteLinkage const & tag);
 void UpdateDistantMatrix(int n, int x, int y, std::vector<std::vector<String<double > > > &compare,std::vector<unsigned> &weights, AverageLinkage const & tag);
@@ -867,6 +865,10 @@
 }
 
 double ComparePWM(std::map<Iupac,double>  &freqMatrix1,std::map<Iupac,double>  &freqMatrix2, Euklidisch const & tag){
+	/***
+			Werte von 0 = identisch bis sqrt(2*sum(column))/4 ?
+		
+	***/
 
 	double columnEntropy = 0;
 
@@ -875,10 +877,48 @@
 	columnEntropy += (freqMatrix1['G'] - freqMatrix2['G'])*(freqMatrix1['G'] - freqMatrix2['G']);
 	columnEntropy += (freqMatrix1['T'] - freqMatrix2['T'])*(freqMatrix1['T'] - freqMatrix2['T']);
 	columnEntropy  = sqrt(columnEntropy);
+	columnEntropy  = columnEntropy/4;
 	
 	return columnEntropy;
 
 }
+
+double ComparePWM(std::map<Iupac,double>  &freqMatrix1,std::map<Iupac,double>  &freqMatrix2, Pearson const & tag){
+
+	double columnEntropy = 0;
+	double columnEntropyDivisorA = 0;
+	double columnEntropyDivisorB = 0;
+	double Mean1 = 0;
+	double Mean2 = 0;
+
+	Mean1= (freqMatrix1['A'] + freqMatrix1['C'] + freqMatrix1['G'] + freqMatrix1['T'])/4;
+	Mean2= (freqMatrix2['A'] + freqMatrix2['C'] + freqMatrix2['G'] + freqMatrix2['T'])/4;
+
+	columnEntropy += (freqMatrix1['A'] - Mean1)*(freqMatrix2['A'] - Mean2);
+	columnEntropy += (freqMatrix1['C'] - Mean1)*(freqMatrix2['C'] - Mean2);
+	columnEntropy += (freqMatrix1['G'] - Mean1)*(freqMatrix2['G'] - Mean2);
+	columnEntropy += (freqMatrix1['T'] - Mean1)*(freqMatrix2['T'] - Mean2);
+
+	columnEntropyDivisorA += (freqMatrix1['A'] - Mean1)*(freqMatrix1['A'] - Mean1);
+	columnEntropyDivisorA += (freqMatrix1['C'] - Mean1)*(freqMatrix1['C'] - Mean1);
+	columnEntropyDivisorA += (freqMatrix1['G'] - Mean1)*(freqMatrix1['G'] - Mean1);
+	columnEntropyDivisorA += (freqMatrix1['T'] - Mean1)*(freqMatrix1['T'] - Mean1);
+
+	columnEntropyDivisorB += (freqMatrix2['A'] - Mean2)*(freqMatrix2['A'] - Mean2);
+	columnEntropyDivisorB += (freqMatrix2['C'] - Mean2)*(freqMatrix2['C'] - Mean2);
+	columnEntropyDivisorB += (freqMatrix2['G'] - Mean2)*(freqMatrix2['G'] - Mean2);
+	columnEntropyDivisorB += (freqMatrix2['T'] - Mean2)*(freqMatrix2['T'] - Mean2);
+
+	columnEntropyDivisorA = columnEntropyDivisorA * columnEntropyDivisorB;
+	columnEntropyDivisorA = sqrt(columnEntropyDivisorA);
+
+	columnEntropy = columnEntropy/columnEntropyDivisorA;
+
+
+	return columnEntropy;
+
+}
+
 /****
 		Speichert die jeweiligen Mittelwerte der 2 Ã¼bergebenen Matrizen 
 ****/
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/AAinput.dat ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/AAinput.dat
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/AAinput.dat	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/AAinput.dat	2007-02-21 21:13:31.000000000 +0100
@@ -0,0 +1,65 @@
+numSeq=10
+seqLen=500
+OAPctA=7.89
+OAPctR=5.40
+OAPctN=4.13
+OAPctD=5.35
+OAPctC=1.50
+OAPctQ=3.95
+OAPctE=6.67
+OAPctG=6.96
+OAPctH=2.29
+OAPctI=5.90
+OAPctL=9.65
+OAPctK=5.92
+OAPctM=2.38
+OAPctF=3.96
+OAPctP=4.83
+OAPctS=6.82
+OAPctT=5.41
+OAPctW=1.13
+OAPctY=3.03
+OAPctV=6.73
+numMotifs=5
+motif1Type=U
+motif1Seq=PAPERPSV
+motif1PctSeqsContain=90
+motif1PAM=0
+motif2Type=R
+motif2Len=10
+motif2PctA=10.0
+motif2PctR=20.0
+motif2PctN=5.0
+motif2PctD=1.0
+motif2PctC=10.0
+motif2PctQ=5.0
+motif2PctE=20.0
+motif2PctG=6.0
+motif2PctH=10.0
+motif2PctI=0.0
+motif2PctL=1.0
+motif2PctK=2.0
+motif2PctM=0.0
+motif2PctF=0.0
+motif2PctP=0.0
+motif2PctS=0.0
+motif2PctT=0.0
+motif2PctW=0.0
+motif2PctY=0.0
+motif2PctV=0.0
+motif2PctSeqsContain=100
+motif2PAM=70
+motif3Type=U
+motif3Seq=ERICR
+motif3PctSeqsContain=50
+motif3PAM=250
+motif4Type=U
+motif4Seq=MILKMAN
+motif4PctSeqsContain=100
+motif4PAM=0
+motif5Type=U
+motif5Seq=SALTYPILLSMILKMANERICR
+motif5PctSeqsContain=100
+motif5PAM=62
+output=F
+outFile=output.dat
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/ChangeLog ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/ChangeLog
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/ChangeLog	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/ChangeLog	2007-02-16 16:56:08.000000000 +0100
@@ -0,0 +1,12 @@
+1.0.0 (September 20, 2006)
+	
+	* Initial release
+
+1.1.0 (February 1, 2007)
+	* Allows for an option for batch processing from a file
+	* Updated to use drand48() routines for more uniformly
+        * distributed random numbers
+
+2.0.0 (March 1, 2007)
+	* Allows for creating random Amino Acid motifs using
+          PAM scoring matrices
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/CommonRoutines.cpp ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/CommonRoutines.cpp
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/CommonRoutines.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/CommonRoutines.cpp	2007-03-01 17:13:56.000000000 +0100
@@ -0,0 +1,638 @@
+//===========================================================================
+//=====================  BEGIN OF CommonRoutines.cpp ========================
+//===========================================================================
+
+
+//==========================================================================
+// rMotifGen
+// Eric C. Rouchka
+// C. Timothy Hardin
+// (c) 2004-2007, University of Louisville
+//
+// FILE: CommonRoutines.cpp
+// 
+//    This file is part of rMotifGen.
+//
+//    rMotifGen is free software; you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation; either version 2 of the License, or
+//    (at your option) any later version.
+//
+//    rMotifGen is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    You should have received a copy of the GNU General Public License
+//    along with rMotifGen; if not, write to the Free Software
+//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+//
+//==========================================================================
+
+//==========================================================================
+
+#include <string>
+#include <iostream>
+#include <fstream>
+#include <vector>
+#include "SequenceClass.H"
+#include "CommonRoutines.H"
+using namespace std;
+
+
+//---------------------------------------------------------------------------
+bool isNum(char ch) {
+
+   //**********************************************************************
+   // PRE : ch is a character
+   // POST: returns true if ch is a numeral; false otherwise
+   //**********************************************************************
+
+   if((ch == '1') || (ch == '2') || (ch == '3') || (ch == '4') ||
+      (ch == '5') || (ch == '6') || (ch == '7') || (ch == '8') ||
+      (ch == '9') || (ch == '0')) {
+      return(true);
+   }
+   return(false);
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+bool isNumOrSign(char ch) {
+
+   //**********************************************************************
+   // PRE : ch is a character
+   // POST: returns true if ch is a numeral, +, or -; false otherwise
+   //**********************************************************************
+
+   if(isNum(ch) || (ch == '+') || (ch == '-')) {
+      return(true);
+   }
+   return(false);
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+bool getDoubleFromString(double &retVal, string s, 
+                         double lowBounds, double hiBounds) {
+
+   //**********************************************************************
+   // PRE  : defaultValue has been set
+   // POST : returns true if a double has been read in -- the
+   //        resulting value is stored in the parameter retVal
+   //**********************************************************************
+   char *lhTok, *rhTok;
+
+   lhTok = strtok((char *)s.c_str(), ".");
+   rhTok = strtok(NULL, "\n");
+   
+   int lhs, rhs;
+   if(rhTok == NULL) {
+      if(getIntFromString(lhs, lhTok, -1, 101)) {
+         retVal = (double) lhs;
+         return(true);
+      }
+      else {
+         return(false);
+      }
+   }
+
+   if(getIntFromString(lhs, lhTok, -1, 101) && 
+      getIntFromString(rhs, rhTok, -1, 10001)) {
+
+      // rhs should be divided accordingly
+      int divisor = 1;
+      int tmp = rhs;
+      while(tmp > 0) {
+         divisor *= 10;
+         tmp = tmp / 10;
+      }
+      double rhs2 = (double)rhs / divisor;
+
+      retVal = lhs + rhs2;
+      return(true);
+   }
+   else {
+      return(false);
+   }
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+bool getIntFromString(int &retVal, string s, int lowBounds, int hiBounds) {
+
+   //**********************************************************************
+   // PRE  : defaultValue has been set
+   // POST : returns true if an integer has been read in -- the
+   //        resulting value is stored in the parameter retVal
+   //**********************************************************************
+
+   int len;
+   retVal = 0;
+   len = s.length();
+
+   if(s == "") {
+      return(true);
+   }
+
+   for(int i = 0; i < len; i++) {
+      char currCh = s.at(i);
+      if(!isNum(currCh))
+         return(false);
+      else {
+         int currMult = (int)pow(10,len-i-1);
+         retVal += currMult * ((int)currCh - 48);
+      }
+   }
+   if((retVal > lowBounds)  && (retVal < hiBounds)) 
+      return(true);
+   else
+      return(false);
+   // check to make sure it is a valid number
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+bool getDouble(double &retVal, double defaultValue) {
+
+   //**********************************************************************
+   // PRE  : defaultValue has been set
+   // POST : returns true if a double has been read in -- the
+   //        resulting value is stored in the parameter retVal
+   //**********************************************************************
+
+   string s;
+   int len;
+
+   retVal = 0;
+   cin >> s;
+   len = s.length();
+   if(s == "") {
+      retVal = defaultValue;
+      return(true);
+   }
+
+   int numDecimals=0;
+   int numDecimalPlaces = 0;
+
+   for(int i = 0; i < len; i++) {
+      char currCh = s.at(i);
+      if(!isNum(currCh)) {
+         if((currCh == '.') && ((numDecimals == 0) && (i > 0))) {
+            numDecimals++;
+         }
+         else {
+            return(false);
+         }
+      }
+   }  
+
+   if(getDoubleFromString(retVal, s, -1000000.0, 1000000.0)) {
+       return(true);
+    }
+    else {
+       return(false);
+    }
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+bool getInt(int &retVal, int defaultValue) {
+
+   //**********************************************************************
+   // PRE  : defaultValue has been set
+   // POST : returns true if an integer has been read in -- the
+   //        resulting value is stored in the parameter retVal
+   //**********************************************************************
+
+   string s;
+   int len;
+
+   retVal = 0;
+   cin >> s;
+   len = s.length();
+   if(s == "") {
+      retVal = defaultValue;
+      return(true);
+   }
+
+   for(int i = 0; i < len; i++) {
+      char currCh = s.at(i);
+      if(!isNum(currCh))
+         return(false);
+      else {
+         int currMult = (int)pow(10,len-i-1);
+         retVal += currMult * ((int)currCh - 48);
+      }
+   }
+
+   return(true);
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void getValidAASequenceTokens (string &retVal, ifstream &ifs, 
+                             string validLabel, int errorCode) {
+
+   //**********************************************************************
+   // PRE  : validLabel contains a label for the next valid field to be
+   //        read in from the file
+   // POST : Reads in the next line from the file, storing the value in
+   //        the retVal parameter if the label matches the validLabel,
+   //        otherwise exiting with the defined errorCode
+   //**********************************************************************
+
+   string currLine;
+
+   ifs >> currLine;
+   char *lhTok, *rhTok;
+
+   lhTok = strtok((char *)currLine.c_str(), "=");
+   rhTok = strtok(NULL, "\n");
+   string label = string(lhTok);
+   if(label != validLabel)
+      exit(errorCode);
+   retVal = toUpper(string(rhTok));
+   if(!validAASeq(retVal))
+      exit(errorCode);
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void getValidDNASequenceTokens (string &retVal, ifstream &ifs, 
+                             string validLabel, int errorCode) {
+
+   //**********************************************************************
+   // PRE  : validLabel contains a label for the next valid field to be
+   //        read in from the file
+   // POST : Reads in the next line from the file, storing the value in
+   //        the retVal parameter if the label matches the validLabel,
+   //        otherwise exiting with the defined errorCode
+   //**********************************************************************
+
+   string currLine;
+
+   ifs >> currLine;
+   char *lhTok, *rhTok;
+
+   lhTok = strtok((char *)currLine.c_str(), "=");
+   rhTok = strtok(NULL, "\n");
+   string label = string(lhTok);
+   if(label != validLabel)
+      exit(errorCode);
+   retVal = toUpper(string(rhTok));
+   if(!validDNASeq(retVal))
+      exit(errorCode);
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void getStringTokens (string &retVal, ifstream &ifs, string validLabel, 
+                      int errorCode) {
+
+   //**********************************************************************
+   // PRE  : validLabel contains a label for the next valid field to be
+   //        read in from the file
+   // POST : Reads in the next line from the file, storing the value in
+   //        the retVal parameter if the label matches the validLabel,
+   //        otherwise exiting with the defined errorCode
+   //**********************************************************************
+
+   string currLine;
+   ifs >> currLine;
+   char *lhTok, *rhTok;
+
+   lhTok = strtok((char *)currLine.c_str(), "=");
+   rhTok = strtok(NULL, "\n");
+   string label = string(lhTok);
+   string val = toUpper(string(rhTok));
+   if(label != validLabel)
+      exit(errorCode);
+   retVal = val;
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void getValidCharTokens (string &retVal, ifstream &ifs, 
+                         vector<string> validVals, string validLabel, 
+                         int errorCode) {
+
+   //**********************************************************************
+   // PRE  : validLabel contains a label for the next valid field to be
+   //        read in from the file
+   // POST : Reads in the next line from the file, storing the value in
+   //        the retVal parameter if the label matches the validLabel,
+   //        and the input is listed in the validVals vector,
+   //        otherwise exiting with the defined errorCode
+   //**********************************************************************
+
+   string currLine;
+   ifs >> currLine;
+   char *lhTok, *rhTok;
+
+   lhTok = strtok((char *)currLine.c_str(), "=");
+   rhTok = strtok(NULL, "\n");
+   string label = string(lhTok);
+   string val = toUpper(string(rhTok));
+   if(label != validLabel)
+      exit(errorCode);
+   bool isFound = false;
+   for(int i = 0; i < validVals.size(); i++) {
+      if(val == validVals.at(i)) {
+         isFound = true;
+         i = validVals.size();
+      }
+   }  
+   if(!isFound) 
+      exit(errorCode);
+   retVal = val;
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void getValidDoubleTokens (double &retVal, ifstream &ifs, double low,
+                           double hi, string validLabel, int errorCode) {
+
+   //**********************************************************************
+   // PRE  : validLabel contains a label for the next valid field to be
+   //        read in from the file
+   // POST : Reads in the next line from the file, storing the value in
+   //        the retVal parameter if the label matches the validLabel,
+   //        and is a double in the range from low to hi,
+   //        otherwise exiting with the defined errorCode
+   //**********************************************************************
+
+   string currLine;
+
+   ifs >> currLine;
+   char *lhTok, *rhTok;
+
+   lhTok = strtok((char *)currLine.c_str(), "=");
+   rhTok = strtok(NULL, "\n");
+   string label = string(lhTok);
+
+   if((label != validLabel) || !getDoubleFromString(retVal, rhTok, low, hi))
+      exit(errorCode);
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void getValidIntTokens (int &retVal, ifstream &ifs, int low,
+                        int hi, string validLabel, int errorCode) {
+
+   //**********************************************************************
+   // PRE  : validLabel contains a label for the next valid field to be
+   //        read in from the file
+   // POST : Reads in the next line from the file, storing the value in
+   //        the retVal parameter if the label matches the validLabel,
+   //        and is an integer in the range from low to hi,
+   //        otherwise exiting with the defined errorCode
+   //**********************************************************************
+
+   string currLine;
+
+   ifs >> currLine;
+   char *lhTok, *rhTok;
+
+   lhTok = strtok((char *)currLine.c_str(), "=");
+   rhTok = strtok(NULL, "\n");
+   string label = string(lhTok);
+
+   if((label != validLabel) || !getIntFromString(retVal, rhTok, low, hi))
+      exit(errorCode);
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+double getDoubleInput(string prompt, double defaultVal, 
+                      double lowBounds, double hiBounds) {
+
+   //**********************************************************************
+   // PRE  : prompt is a string that is printed out to the user
+   //        defaultVal is the default value if enter by itself is used
+   //        lowBounds is the first illegal value
+   //        highBounds is the last illegal value
+   // POST : returns the integer value entered, once it has been
+   //        validated according to the parameters
+   //**********************************************************************
+
+   bool finished = false;
+   double retVal;
+
+   while(!finished) {
+      cout << prompt;
+      if(getDouble(retVal, defaultVal)) {
+         if((retVal > lowBounds)  && (retVal < hiBounds)) {
+            finished = true;
+         }
+      }
+      if(!finished) {
+         cout << endl << endl;
+         cout << "ERROR: NUMBER BETWEEN " << lowBounds + 1 << " AND " <<
+              hiBounds - 1 << " EXPECTED!!" << endl << endl;
+      }
+   }
+   return(retVal);
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+int getIntInput(string prompt, int defaultVal, int lowBounds, int hiBounds) {
+
+   //**********************************************************************
+   // PRE  : prompt is a string that is printed out to the user
+   //        defaultVal is the default value if enter by itself is used
+   //        lowBounds is the first illegal value
+   //        highBounds is the last illegal value
+   // POST : returns the integer value entered, once it has been
+   //        validated according to the parameters
+   //**********************************************************************
+
+   bool finished = false;
+   int retVal;
+
+   while(!finished) {
+      cout << prompt;
+      if(getInt(retVal, defaultVal)) {
+         if((retVal > lowBounds)  && (retVal < hiBounds)) {
+            finished = true;
+         }
+      }
+      if(!finished) {
+         cout << endl << endl;
+         cout << "ERROR: NUMBER BETWEEN " << lowBounds + 1 << " AND " <<
+              hiBounds - 1 << " EXPECTED!!" << endl << endl;
+      }
+   }
+   return(retVal);
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+char toUpper(char ch) {
+
+   //**********************************************************************
+   // PRE  : ch is the character to change to uppercase
+   // POST : returns the uppercase equivalent of ch by using ASCII values
+   //**********************************************************************
+
+   int val;
+   val = (int) ch;
+   if((val > 96) && (val < 123)) {
+      val -= 32;
+   }
+   ch = (char)val;
+   return(ch);
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+string toUpper(string s) {
+
+   //**********************************************************************
+   // PRE  : s is the string to change to uppercase
+   // POST : returns the uppercase equivalent of s
+   //**********************************************************************
+
+   int len;
+   int val;
+   string retVal = "";
+   len = s.length();
+
+   for(int i = 0; i < len; i++) {
+      char ch = s.at(i);
+      ch = toUpper(ch);
+      retVal.append(1,ch);
+   }
+   return(retVal);
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+bool validAASeq(string s) {
+
+   //**********************************************************************
+   // PRE  : s is a sequence to be tested
+   // POST : returns true if s is a valid Amino Acid sequence; 
+   //        false if it is not
+   //**********************************************************************
+
+   int len = s.length();
+
+   for(int i = 0; i < len; i++) {
+      char ch = s.at(i);
+      if(!((ch == 'A') || (ch == 'R') || (ch == 'N') || (ch == 'D') || 
+           (ch == 'C') || (ch == 'Q') || (ch == 'E') || (ch == 'G') ||
+           (ch == 'H') || (ch == 'I') || (ch == 'L') || (ch == 'K') ||
+           (ch == 'M') || (ch == 'F') || (ch == 'P') || (ch == 'S') ||
+           (ch == 'T') || (ch == 'W') || (ch == 'Y') || (ch == 'V'))) {
+         return(false);
+      }
+   }
+   return(true);
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+bool validDNASeq(string s) {
+
+   //**********************************************************************
+   // PRE  : s is a sequence to be tested
+   // POST : returns true if s is a valid DNA sequence; false if it is not
+   //**********************************************************************
+
+   int len = s.length();
+
+   for(int i = 0; i < len; i++) {
+      char ch = s.at(i);
+      if(!((ch == 'A') || (ch == 'C') || (ch == 'G') || (ch == 'T'))) {
+         return(false);
+      }
+   }
+   return(true);
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+string getSequence(string prompt, char seqType) {
+
+   //**********************************************************************
+   // PRE  : prompt is the message to be printed to the user
+   // POST : reads in a valid DNA sequence and returns that value
+   //**********************************************************************
+
+   string tmp = "1";
+   bool done = false;
+   while(!done) {
+      cout << prompt;
+      cin >> tmp;
+      tmp = toUpper(tmp);
+      if(seqType == 'N') {
+         if(validDNASeq(tmp)) {
+            done = true;
+         }
+         else {
+            cout << endl << endl << "ERROR: ONLY A, C, G, T ARE VALID" << endl
+            << endl;
+         }
+      }
+      else {
+         if(validAASeq(tmp)) {
+            done = true;
+         }
+         else {
+            cout << endl << endl << "ERROR: INVALID AMINO ACID CODE" << endl 
+            << endl;
+         }
+      }
+   }
+   return(tmp);
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+string getCharInput(string prompt, string legalVal1, string legalVal2) {
+
+   //**********************************************************************
+   // PRE  : reads in the prompt and two possible legal values
+   // POST : loops unitl a valid value has been entered -- it is then 
+   //        returned as the function's return value
+   //**********************************************************************
+
+   string tmp = " ";
+   while((tmp != legalVal1) && (tmp != legalVal2)) {
+      cout << prompt;
+      cin >> tmp;
+      tmp = toUpper(tmp);
+      if(!((tmp == legalVal1) || (tmp == legalVal2))) {
+          cout << endl << endl;
+          cout << "*** ERROR: MUST BE " << legalVal1 << " OR ";
+          cout << legalVal2 << " ***" << endl << endl;
+      }
+   }
+   return(tmp);
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+bool fileExists(string fn) {
+
+   //**********************************************************************
+   // PRE  : fn is a filename
+   // POST : returns true if the file fn exists; false if it does not
+   //**********************************************************************
+
+   ifstream fin;
+   fin.open(fn.c_str());
+   if(fin.fail())
+      return(false);
+   fin.close();
+   return(true);
+}
+//---------------------------------------------------------------------------
+
+//===========================================================================
+//=====================  END OF CommonRoutines.cpp ==========================
+//===========================================================================
+
+
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/CommonRoutines.H ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/CommonRoutines.H
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/CommonRoutines.H	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/CommonRoutines.H	2007-03-01 17:14:13.000000000 +0100
@@ -0,0 +1,105 @@
+//===========================================================================
+//=====================  BEGIN OF CommonRoutines.H   ========================
+//===========================================================================
+
+
+//==========================================================================
+// rMotifGen
+// Eric C. Rouchka
+// C. Timothy Hardin
+// (c) 2004-2007, University of Louisville
+//
+// FILE: CommonRoutines.H
+//
+//
+//    This file is part of rMotifGen.
+//
+//    rMotifGen is free software; you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation; either version 2 of the License, or
+//    (at your option) any later version.
+//
+//    rMotifGen is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    You should have received a copy of the GNU General Public License
+//    along with rMotifGen; if not, write to the Free Software
+//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+//
+//==========================================================================
+
+//==========================================================================
+
+#ifndef MY_COMMONROUTINES_H
+#define MY_COMMONROUTINES_H
+
+#include <string>
+#include <iostream>
+#include <fstream>
+#include <vector>
+#include <math.h>
+#include "SequenceClass.H"
+#include "CommonRoutines.H"
+using namespace std;
+
+
+bool isNum(char ch);
+
+bool isNumOrSign(char ch);
+
+bool getDoubleFromString(double &retVal, string s,
+                         double lowBounds, double hiBounds);
+
+bool getDouble(double &retVal, double defaultValue);
+
+bool getInt(int &retVal, int defaultValue);
+
+bool getIntFromString(int &retVal, string s, int lowBounds, int hiBounds);
+
+int getIntInput(string prompt, int defaultVal, int lowBounds, int hiBounds);
+
+double getDoubleInput(string prompt, double defaultVal, 
+                      double lowBounds, double hiBounds);
+
+char toUpper(char ch);
+
+string getCharInput(string prompt, string legalVal1, string legalVal2);
+
+string toUpper(string s);
+
+bool validDNASeq(string s);
+bool validAASeq(string s);
+
+string getSequence(string prompt, char seqType);
+
+string getCharInput(string prompt, string legalVal1, string legalVal2);
+
+bool fileExists(string fn);
+
+void getValidDoubleTokens (double &retVal, ifstream &ifs, double low,
+                           double hi, string validLabel, int errorCode);
+
+void getValidIntTokens (int &retVal, ifstream &ifs, int low,
+                        int hi, string validLabel, int errorCode);
+
+void getValidCharTokens (string &retVal, ifstream &ifs, 
+                         vector<string> validVector, string validLabel, 
+                         int errorCode);
+
+void getStringTokens (string &retVal, ifstream &ifs, string validLabel, 
+                      int errorCode);
+
+void getValidDNASequenceTokens (string &retVal, ifstream &ifs, 
+                             string validLabel, int errorCode);
+
+void getValidAASequenceTokens (string &retVal, ifstream &ifs, 
+                             string validLabel, int errorCode);
+#endif
+
+//===========================================================================
+//=======================  END OF CommonRoutines.H   ========================
+//===========================================================================
+
+
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/COPYING ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/COPYING
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/COPYING	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/COPYING	2007-02-15 00:42:46.000000000 +0100
@@ -0,0 +1,4 @@
+The source files and documents contained within the rMotifGen
+are licensed under the GNU General Public License. A copy is 
+provided in this directory, in the file LICENSE.
+
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/CREDITS ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/CREDITS
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/CREDITS	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/CREDITS	2007-02-15 00:42:46.000000000 +0100
@@ -0,0 +1,15 @@
+rMotifGen was created by Eric Rouchka <eric.rouchka@louisville.edu> beginning
+in 2004.  Tim Hardin <tim.hardin@louisville.edu> has been instrumental in the
+rMotifGen project as well.  Eric Rouchka is the current maintainer of the
+software.
+
+If you find the rMotifGen software useful, please cite:
+
+	Rouchka EC, Hardin CT (2006).  rMotifGen: random motif generator for
+	genomic sequences.  (Under review)
+
+For more information on rMotifGen, please see the website:
+   
+	http://kbrin.a-bldg.louisville.edu/Tools/rMotifGen
+
+
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/DNAinput.dat ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/DNAinput.dat
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/DNAinput.dat	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/DNAinput.dat	2007-02-15 00:42:46.000000000 +0100
@@ -0,0 +1,39 @@
+numSeq=10
+seqLen=500
+OAPctA=25
+OAPctC=25
+OAPctG=25
+OAPctT=25
+numMotifs=5
+motif1Type=U
+motif1Seq=AAAAAAAA
+motif1PctSeqsContain=90
+motif1PctCons=100
+motif2Type=R
+motif2Len=10
+motif2IsPalindrome=Y
+motif2PctA=10
+motif2PctC=10
+motif2PctG=40
+motif2PctT=40
+motif2PctSeqsContain=100
+motif2PctCons=70
+motif3Type=R
+motif3Len=20
+motif3IsPalindrome=N
+motif3PctA=50
+motif3PctC=2
+motif3PctG=2
+motif3PctT=46
+motif3PctSeqsContain=50
+motif3PctCons=100
+motif4Type=U
+motif4Seq=AAATATATTT
+motif4PctSeqsContain=100
+motif4PctCons=100
+motif5Type=U
+motif5Seq=TGATAA
+motif5PctSeqsContain=100
+motif5PctCons=99
+output=F
+outFile=output.dat
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/LICENSE ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/LICENSE
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/LICENSE	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/LICENSE	2007-02-15 00:42:46.000000000 +0100
@@ -0,0 +1,341 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
+
+
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/Makefile ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/Makefile
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/Makefile	2007-02-28 01:27:08.000000000 +0100
@@ -0,0 +1,17 @@
+COMPILER = g++
+CCFLAGS = -g
+
+rMotifGen: RandomMotifs.cpp SequenceClass.o CommonRoutines.o SubstitutionMatrices.o
+	${COMPILER} ${CCFLAGS} -o rMotifGen RandomMotifs.cpp SequenceClass.o CommonRoutines.o SubstitutionMatrices.o
+
+SequenceClass.o: SequenceClass.cpp SequenceClass.H
+	${COMPILER} ${CCFLAGS} -c SequenceClass.cpp
+
+SubstitutionMatrices.o: SubstitutionMatrices.cpp SubstitutionMatrices.H
+	${COMPILER} ${CCFLAGS} -c SubstitutionMatrices.cpp
+
+CommonRoutines.o: CommonRoutines.H CommonRoutines.cpp SequenceClass.o
+	${COMPILER} ${CCFLAGS} -c CommonRoutines.cpp
+
+clean:
+	rm *.o a.out rMotifGen
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/OUTPUT.DAT ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/OUTPUT.DAT
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/OUTPUT.DAT	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/OUTPUT.DAT	2007-03-01 17:24:14.000000000 +0100
@@ -0,0 +1,109 @@
+
+NUMMOTIFS: 5
+Motif 1 consensus: PAPERPSV
+Motif 2 consensus: GEERACCEQE
+Motif 3 consensus: ERICR
+Motif 4 consensus: MILKMAN
+Motif 5 consensus: SALTYPILLSMILKMANERICR
+
+>rMotifGen_RandSeq_1 5 458 86 324 259 276 
+KAVDFGQLKVFGHADACRHVWKGLIKVKAVEPNLLNEKLGQDHRCRQGTLHPVIQCAMYS 
+AKKIEIGVCKRVVVLIMIRAHAAGLFGQERAVRQQDYISPVRSVETYLCEADTFVILVQR 
+LQKGDDLGGQLSKKLINREIGSIQGTAMPLGWLPFAGPCFRQSNDQNGLKSTLTPEAEKS 
+AVIKLKIRNGFPYNINLDLTLGKVLASPQWSSAFKNDKSPTIALYASSLIADRGAELEPV 
+KHPGFDMNVRSPDDMIIWIMILKMANSTVYDLVRLRSALLYPILLYWILNNAGDHICRAK 
+AFVGMYSLKIQSGCEKSAIPMAEFQKLKKIPVKLYRTLEFQYTAWPPPATSDLIMSVLKH 
+FINGAFYSFLLRIKFLTKFRPMGVDFVETDNSLDERRFGRRVPNLVALFSKKGVASERYS 
+QVHEDIMAFDNVLLGRFMYWKVTIDGSAFTDIQIRGEKPAPERPSVKDLLKEPKKPALDI 
+VAQSCRNELTSPVSHALSQR
+>rMotifGen_RandSeq_2 5 352 94 56 331 273 
+YLFLKTDHADAMERAQDYGSNGRWVFVLQHDVQGFYQLDSVSHLHGAQIEPFAITDSQVC 
+RRAKSAIILEQDARRWFFPFVCLPHSLRTHFVKDNDDRTCCQHQWAGLHGVKKKPGIVWK 
+QWEFVAYIQPRNPTSARITTVKESLSKNPTATFDKIVQRVGGVTARNGVVYEGSECICAL 
+AQMLTGSPRLTVFIQHGVVAERDGLKTAFFLTTYAFPQKYESASHANEVHSKKKREARAG 
+PIEVIRSKGTMTRPEFNKFTILEFAEQERFTITSDLSYSILLSMIIKMANQHICRPHYGS 
+DRSPDALPLPLRRMLVEKIENKEKPKLRLTGMILKMANATVLSTLFNIYRFPPAPERPSV 
+ILPKGAAKGSAAAAVGLFERNLEDIHEDKPSFLYEHHLAQFNLIIMRGYVYADDGPYIGP 
+PEYSDQFGNQVSNRYRDHDVGVGARTDVPDMAGAPLKNAVGQILGHSGAEVDERNPSLGP 
+NIRRRKERRDVTVGLDAKLK
+>rMotifGen_RandSeq_3 5 76 340 -1 49 440 
+VNNKRPVFANSPTVLAMAKIPDPIVFDSAKKDNEKEKLDSFVQSCEFDHMILKMANVQYP 
+ALAIIYRQEDCEIGMTPAPERPSVSERILPKHKNPGGTDSNHELAARCKVLQHTRNSYEG 
+KDVPGCHACRQILHRHNQFHNASPPIILYHNYKIKPVGGLGGSAGARSATCLELPRPRDQ 
+QLQFRHVCCWPSSGPGQREERAARVVEKIYFPVTYYVIPVHNFAEWRVSSANRIKKSEPM 
+VPNADIFKDSFSWSTLKKYSRYEDWILACDAFIVSGGLLFTVADQESVSVDGTVNKDGAI 
+YICRDTTPVSRLAAGQGAVPVNADVPIVFNYFWRHPIVPGGEDRTCCEQDKSFVFVVFDL 
+GHSSHRENKVNNLLEHGQLHARSMHNLILGREPARKRSGCLDVLARVIQHMLKDERILDV 
+YITAADGFLVLDGFDYGFLCVAITYPVMFTMILDMAHNRIPRQAGFYTSGNSMFFFNRFW 
+NRGTFHAIRLGVANFHLPEN
+>rMotifGen_RandSeq_4 5 94 106 -1 69 251 
+VVFPYSGEIGQNDDNVTYNKIKAFAPNDFGHFNEFETIGKEVVIISRDGKLYNLAKELNK 
+YKDSYTAINMILKMANMIASKNLSCGYLIPVYTHPAPERPSVCSQSGEQIACCGEEVQRR 
+ISLAAQPGSEGSSVEEGMVAWGSQLKKLKQSKGQLIDSSIFFGDDPVENQPNDLSKYVNF 
+LALSFTVVSESKESLQELNAYTAVGDGYQLDEIVLETDTIILHPDVNSYGMKIVAAQDLL 
+TYLTSANKEHFNALTYPFLLKTILKMSDERLCHAEVMARKVIVRKPDVIDQNQNFDLLAI 
+LAKLGISGCVHAKRATADASRLRKKNGYPQRPHTNQARIKILQLEEDQPVWRMKKFKEHS 
+DPGEEDAVVILKKFTEKAIPGQGPVLKFVLLNYFKPGQTVSDKAWEKNFSDQVEAQERHL 
+ADIVIYHVAEVGGTEKTTILDVLEAISEIPIVYRKDQALLQGAVIWGLRVPEVKYPKENM 
+AIDGRVENAVSKNVECGIHE
+>rMotifGen_RandSeq_5 5 63 251 -1 490 161 
+VELQDIISTDRTIITTINRTIILQCMHEKLGVFSQAIASKAVDKLIRLDNLEANQTIGRG 
+NVMPAPERPSVFGGCVKCKPGGSVARCGAGNSTPLQDRQSPNLVPFYFVIRGKVGHKNVV 
+IDEHFKVNVLHDLALELAHEVLCQTANAVIFCKKQDVMLPMTDLEYPVILSPVLKMANGV 
+FCRPTITDGQYCGHAKGDDHLYLTALSLNNSFRPVSSQSAEVELIADAYAALAAKKPPVT 
+GLETLCSHAVANEERACCQQEPDTAGDPSPAMYFGERALELHSLVIRPTLSRQYSGPGLK 
+ECLLVVLLSATCQVPGIEAICAQRQFYAVKGLGYQSRLLTRYNVELKYAFHGFLEEAVIG 
+FQHEYFKRLILSLAPGGVSLIERQNGLKARVADALAVMYINAEAGDDQSGHQQAARPIAA 
+ADGRHALAKINQGQRVNAALTFPDAQEAHVLNDLLQIAQTAKVFVDVNHVRAEMLAVDIQ 
+SYDGGLLLYRMILKMANCEI
+>rMotifGen_RandSeq_6 5 264 28 -1 141 401 
+GCAWWIPVPQKGKMESLGEYLIRTRFTPADDHDCCEQKPTQWVTKRARFILCANIVYAVL 
+ATVWAIKQLDNQNEFWPPYPTSIETGKTKQAILAPQNEPALDVARPLADLFTDAPVRACS 
+LAFQGHLPVIRFLLKLGSLHYMILKMANLLNVVVSPALKTLLIVLKSVEVFYENQTGNQV 
+YSGSQHKKFSVPKARTFGAVGTRLLIRLDHDQEKLILDQGEELENVYCLSYLLPRKSTGF 
+PTLANVEMPGKASSKTQSNNAPLIPAPERPSVGDALWVIAVAQMTEKEVLIDKQDSPLSL 
+SKLKGADKTLLSGNEIPPWACSDSFDDKTLRDIFAPKEKGELFGWNSNEDKAIIECHGKG 
+AKYSVYILHLCMMFSKLGFYIAFVKQSGPHPKAVARMLIEHGAKTWPFLFSFILKMAAEK 
+LCRLLQTFITVQVTMQPFDELYVYEVYGRVFQEAMAFRYAYHYETEQPKSERMPYVVPYK 
+ALEVVVVACNKPYNFMYNRK
+>rMotifGen_RandSeq_7 5 -1 103 214 469 412 
+QWSKEVIRYYNSALLSGRDMPNLGNTVRILARGAHHPKHSSVLAGLGRGLPYAAEGYHFL 
+GLPRLIYGLGCAHLLHGLLAANPQKLRQVQALEGHRADGELSCLQERAICESEALAYSYL 
+TGKEIKAFHRPICIGKLLQCPAKRVQIRAEDVLALVLPRVVRDKTSLRNPLTATSIYRLL 
+AGISLDLFPPGDAPYLGYDGFDGFTQLAHSGITSKTLCQKLTVHVAKGEKSELFKDNHRA 
+NRLPAKQAAKDDHKVDKLDAFTLAFIQGQEANPLPRIPDQPNYPMALGVGHLKPRPDLLS 
+DIDLNITRSSKKPLPYYKGDERASLTYSNDRKLWVHKHADESLLLVHTNKDDAQHLLSLY 
+RRAEAELILHENRYENTPLTQLLMTLAESMWLTDPKVRRSEVTAFLGRGHQKNAQLYPIV 
+LWMPLKMAQTRICRTYLLRYEVICKNQQNIVIEADPYTIGRLEQLLSFLMILKMANEEIY 
+WPQGNPFKVLEVLPTVYTLY
+>rMotifGen_RandSeq_8 5 -1 301 137 384 437 
+LVWTCALYKIFLVRVENAVERISHRLPDESCGLKKTAERELGEDPRQPAARTEKALLAVR 
+GIRIHHVVILRKVPEDLERPREEPGILWHGWDRHSYLHYVVSEYRSQYGRRDIITGELFI 
+VGEFNVRHDMDAGGGEGTRKCFNIGHQNFTAYKAYLHVVDIEAANNVSHLRKEPYRDNIL 
+ILVSRPPYDNTIKQNDRFPKGFNAETHLSVTEAYIGASEGSERQSKSYKVVKILAGERRH 
+QEVYPNGVARLGPTVQKQPELNMNNKNGNTSTFTLTGAGHSQRRLLWEMHLVTGLTGPAH 
+GGEDRTCCEMNMSGIFLVRVVDTGGDVGKNIQHSSVYHEIALDYLTPGGILSSHERDTQT 
+ADQLSPAACVSGALIVLGLYLDNGMILKMANKTLLCMVYGFPKVIVASLCETKCFFFLLL 
+DEIFYNYITLTPRGMAQRAPTYAILLVMMIKMAKERVCSGLEDDGGNKDANLILYWTGQA 
+GMYDDRNHLPVLVKFRTPRE
+>rMotifGen_RandSeq_9 5 150 15 473 374 444 
+LAREPALGKLSYPVGNEERDFCEEDPTLARFRADVSVEKPTCQVLSQQMQGILELFRFGY 
+GIRLTVVTPFSRSKLNQLLYAKESKPPDDYYCMPTTVGVIAILATRPNLVFMYGTCMNHG 
+GTLRCFYSVDVDEATHRTPVGLSYAYGPHAPAPERPSVVIYLKPVLSDPCINRKVATFDK 
+QRPKGSNVLEVSIVFSLEVRFNNANVGEHLVKDYQEADAGRDTAINGATDMCDCYTEPKY 
+LKTGVHPGHAFETKDFIRKHLHIDGGGIRFPSNQQRMSGICIAILDYAVIHQVSDEFFVP 
+GSDSALSISLFTRDLLELGNMVYPVVRARYKLIGVAVGGQELSTKVIQKTGHHYDSAYDS 
+SCRAFCVYFRNYGLMILKMANYDTFHMATLPSQKYQCSSLKYGAYTSGVKHEGSTSEGKG 
+VARSSVHQGGVAELPDRVVLFNLLSAIFYPIVLSTIKKKDNERIVRNSDALSTQRISCGG 
+VRNSKNLPVFIKELTELDDQ
+>rMotifGen_RandSeq_10 5 51 89 -1 71 107 
+LPSQPKLTETLGFVEISKLAPTKGPLGKIPPFETPVEKRGSLTYKDEFDFIPAPERPSVR 
+QGRILSYTDELMILKMANTKVSTRAFASSGEVRDCCDMDSENMVHDEWELTYPILLEMIG 
+KKHNEIICKLPNHIIHELEYSYTGKHDRLEEAFVRVEGTIPQSLSVKSYLNCCIVVNAKR 
+SGRQKNLNGYAQGILLPGQIDQYALDCGVEQQFGKAYIYGGIEPENGRMVSSLKFQNDRT 
+MVDRSRDMYGALVESEQIAGFRYMVKVYRVPGFFGPRFPIQMEATAKPVQIIKLAKTKSL 
+SNLSMLRSESVLTIDDFVAVRLYGTLLELFLLKTNHRVGLQGHSSNEAGHNSARADRYLA 
+VYTQQGPKLEFSILRSLTNYIKKHRANCIANYDYVESAFIFTAGATIQALKPEMDEQKQC 
+KSARVRRESSEAKAAHKSKHVDVAVKYYPPGGITCDQSSAHQAVESPGDEISDIMFFTRG 
+RSVSSLGLLQATRLLYGSLT
+
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/PAM1.prob ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/PAM1.prob
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/PAM1.prob	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/PAM1.prob	2007-02-15 00:42:46.000000000 +0100
@@ -0,0 +1,21 @@
+      A     R    N    D    C    Q    E    G    H    I    L    K    M    F    P    S    T    W    Y    V
+A  9867     2    9   10    3    8   17   21    2    6    4    2    6    2   22   35   32    0    2   18
+R     1  9913    1    0    1   10    0    0   10    3    1   19    4    1    4    6    1    8    0    1
+N     4     1 9822   36    0    4    6    6   21    3    1   13    0    1    2   20    9    1    4    1
+D     6     0   42 9859    0    6   53    6    4    1    0    3    0    0    1    5    3    0    0    1
+C     1     1    0    0 9973    0    0    0    1    1    0    0    0    0    1    5    1    0    3    2
+Q     3     9    4    5    0 9876   27    1   23    1    3    6    4    0    6    2    2    0    0    1
+E    10     0    7   56    0   35 9865    4    2    3    1    4    1    0    3    4    2    0    1    2
+G    21     1   12   11    1    3    7 9935    1    0    1    2    1    1    3   21    3    0    0    5
+H     1     8   18    3    1   20    1    0 9912    0    1    1    0    2    3    1    1    1    4    1
+I     2     2    3    1    2    1    2    0    0 9872    9    2   12    7    0    1    7    0    1   33
+L     3     1    3    0    0    6    1    1    4   22 9947    2   45   13    3    1    3    4    2   15
+K     2    37   25    6    0   12    7    2    2    4    1 9926   20    0    3    8   11    0    1    1
+M     1     1    0    0    0    2    0    0    0    5    8    4 9874    1    0    1    2    0    0    4
+F     1     1    1    0    0    0    0    1    2    8    6    0    4 9946    0    2    1    3   28    0
+P    13     5    2    1    1    8    3    2    5    1    2    2    1    1 9926   12    4    0    0    2
+S    28    11   34    7   11    4    6   16    2    2    1    7    4    3   17 9840   38    5    2    2
+T    22     2   13    4    1    3    2    2    1   11    2    8    6    1    5   32 9871    0    2    9
+W     0     2    0    0    0    0    0    0    0    0    0    0    0    1    0    1    0 9976    1    0
+Y     1     0    3    0    3    0    1    0    4    1    1    0    0   21    0    1    1    2 9945    1
+V    13     2    1    1    3    2    2    3    3   57   11    1   17    1    3    2   10    0    2 9901
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/RandomMotifs.cpp ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/RandomMotifs.cpp
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/RandomMotifs.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/RandomMotifs.cpp	2007-03-16 13:30:27.000000000 +0100
@@ -0,0 +1,791 @@
+
+//============================================================================
+//------------------------- BEGIN OF RandomMotifs.cpp ------------------------
+//============================================================================
+
+//==========================================================================
+// rMotifGen
+// Eric C. Rouchka
+// C. Timothy Hardin
+// (c) 2004-2007, University of Louisville
+//
+// FILE: RandomMotifs.cpp
+//
+//    This file is part of rMotifGen.
+//
+//    rMotifGen is free software; you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation; either version 2 of the License, or
+//    (at your option) any later version.
+//
+//    rMotifGen is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    You should have received a copy of the GNU General Public License
+//    along with rMotifGen; if not, write to the Free Software
+//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+// 
+//==========================================================================
+
+#include "RandomMotifs.H"
+#include "SequenceClass.H"
+#include "CommonRoutines.H"
+#include <iostream>
+#include <fstream>
+#include <string>
+#include <vector>
+#include <math.h>
+using namespace std;
+
+//---------------------------------------------------------------------------
+void printWelcome() {
+
+   //**********************************************************************
+   // PRE  : NONE
+   // POST : Prints out a welcome screen information about rMotifGen
+   //**********************************************************************
+
+   system("clear");
+   cout << "          ===========================================" << endl;
+   cout << "          | rMotifGen (v2.0)                        |" << endl;
+   cout << "          |                                         |" << endl;
+   cout << "          | Eric C. Rouchka                         |" << endl;
+   cout << "          | C. Timothy Hardin                       |" << endl;
+   cout << "          |                                         |" << endl;
+   cout << "          | (c) 2004-2007, Eric C. Rouchka and      |" << endl;
+   cout << "          |     C. Timothy Hardin                   |" << endl;
+   cout << "          |     University of Louisville            |" << endl;
+   cout << "          |                                         |" << endl;
+   cout << "          | rMotifGen comes with ABSOLUTELY NO      |" << endl;
+   cout << "          | WARRANTY.  It is distruited under the   |" << endl;
+   cout << "          | GNU General Public License.  Please see |" << endl;
+   cout << "          | the LICENSE file for more details.      |" << endl;
+   cout << "          |                                         |" << endl;
+   cout << "          | Please cite:                            |" << endl;
+   cout << "          |   Rouchka EC, Hardin CT.  (2006)        |" << endl;
+   cout << "          |   rMotifGen: random motif generator for |" << endl;
+   cout << "          |   genomic sequences.  (Under review).   |" << endl;
+   cout << "          ===========================================" << endl;
+   cout << endl << endl;
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void printOverallHeader() {
+
+   //**********************************************************************
+   // PRE  :
+   // POST :
+   //**********************************************************************
+
+   for(int j = 0; j < 76; j++) 
+       cout << "-";
+   cout << endl;
+   for(int j = 0; j < 24; j++)
+       cout << "-";
+   cout << " OVERALL SEQUENCE SETTINGS ";
+   for(int j = 0; j < 25; j++)
+       cout << "-";
+   cout << endl;
+   for(int j = 0; j < 76; j++) 
+       cout << "-";
+   cout << endl;
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void printMotifHeader(int currMotif) {
+
+   //**********************************************************************
+   // PRE  :
+   // POST :
+   //**********************************************************************
+
+   cout << endl << endl;
+   for(int j = 0; j < 76; j++) 
+       cout << "=";
+   cout << endl;
+   for(int j = 0; j < 33; j++)
+       cout << "=";
+   cout << " MOTIF " << currMotif << "  ";
+   for(int j = 0; j < 33; j++)
+       cout << "=";
+   cout << endl;
+   for(int j = 0; j < 76; j++) 
+       cout << "=";
+   cout << endl;
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void getOverallData(int &numSeqs, int &seqLen, double *&pctArr, 
+                    char *LabelArr, int numResidues, int &numMotifs) {
+
+   //**********************************************************************
+   // PRE  :
+   // POST :
+   //**********************************************************************
+
+   pctArr = new double[numResidues];
+   numSeqs = getIntInput("Enter in the number of sequences to generate (10): ",
+                         10, 0, 1001);
+   seqLen  = getIntInput("Enter in the sequence length (500) : ", 500, 9, 10001);
+   double CumSum = 0;
+   for(int i = 0; i < numResidues; i++) {
+      char *prompt;
+      prompt = new char[500];
+      sprintf(prompt, "Enter in the overall percent %c : ", LabelArr[i]);
+      pctArr[i] = getDoubleInput(prompt, 25, -1, 101);
+      CumSum += pctArr[i];
+   }
+   CumSum /= 100.0;
+   for(int i = 0; i < numResidues; i++) {
+      pctArr[i] /=  CumSum;
+   }
+   numMotifs = getIntInput("Enter in the number of motifs per sequence (3) : ",
+                           3, -1, 11);
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void allocateMotifArrays(bool *&motif_isRandomArr, int *&motif_lenArr, 
+                         string *&motif_seqArr, double *&motif_pctSeqConsArr, 
+                         PAM **&motif_PAMArr, double **&motifPctArr,
+                         double *&motif_pctConsensusConsArr, int numMotifs,
+                         int numResidues, bool *&motif_isPalindromicArr) {
+
+   //**********************************************************************
+   // PRE  :
+   // POST :
+   //**********************************************************************
+
+   motif_isRandomArr         = new bool[numMotifs];
+   motif_lenArr              = new int[numMotifs];
+   motif_seqArr              = new string[numMotifs];
+   motif_pctSeqConsArr       = new double[numMotifs];
+   motif_PAMArr              = new PAM *[numMotifs];
+   motif_pctConsensusConsArr = new double[numMotifs];
+   motifPctArr               = new double *[numMotifs];
+   motif_isPalindromicArr    = new bool[numMotifs];
+   for(int i = 0; i < numMotifs; i++) {
+      motifPctArr[i] = new double[numResidues];
+   }
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void getMotifData(bool *&motif_isPalindromicArr, 
+                  bool *&motif_isRandomArr, 
+                  int  *&motif_lenArr,
+                  string *&motif_seqArr, 
+                  double *&motif_pctSeqConsArr, 
+                  double *&motif_pctConsensusConsArr, 
+                  double **&motif_pctArr,
+                  PAM **&motif_PAMArr, 
+                  int numMotifs,
+                  char seqType,
+                  int numResidues,
+                  char *LabelArr) {
+
+   //**********************************************************************
+   // PRE  : space has been allocated for the motif information
+   // POST : valid data has been stored for each motif
+   //**********************************************************************
+
+   for(int i = 0; i < numMotifs; i++) {
+      int currMotif = i + 1;
+      printMotifHeader(currMotif);
+      string tmp = " ";
+      tmp = getCharInput("Is this motif (U)ser defined, or (Random)? (Please enter (U) or (R)) : ", "U", "R");
+      
+      if(tmp == "R") {
+         //--------------------------------------------------------------------
+         // RANDOM MOTIF -- must get the motif length and the motif composition
+         //                 as well as if the motif is palindromic
+         //--------------------------------------------------------------------
+
+         motif_isRandomArr[i] = true;
+         motif_lenArr[i] = getIntInput("Enter in the motif length (10) : ",
+                                       10, 0, 101);
+         if(seqType == 'N') {
+            string tmp2 = " ";
+            tmp2 = getCharInput("Is this motif palindromic (Y) or (N)? ", "Y", "N");
+            if(tmp2 == "Y")  {  motif_isPalindromicArr[i] = true; }
+            else             {  motif_isPalindromicArr[i] = false; }
+         }
+         double sum = 0.0;
+         for(int j = 0; j < numResidues; j++) {
+            char *prompt;
+            prompt = new char[500];
+            sprintf(prompt, "Enter in the motif percent %c : ", LabelArr[j]);
+            double tmpdouble = getDoubleInput(string(prompt), 100.0 / numResidues, -1, 101);
+            sum += tmpdouble;
+            motif_pctArr[i][j] = tmpdouble;
+         }
+         for(int j = 0; j < numResidues; j++) {
+            motif_pctArr[i][j] /= sum;
+            motif_pctArr[i][j] *= 100.0;
+         }
+      }
+      else {
+         // USER INPUT MOTIF -- RETRIEVE THE CONSENSUS FROM THE USER
+         motif_isRandomArr[i] = false;
+         motif_seqArr[i] = getSequence("Enter in the motif sequence : ", seqType);
+      }
+      string prompt = "Enter in the percentage of sequences containing the motif : ";
+      motif_pctSeqConsArr[i] = getIntInput(prompt, 100, -1, 101);
+      if(seqType == 'N') {
+         prompt = "Enter in the percent conservation of the motif consensus sequence : ";
+         motif_pctConsensusConsArr[i] = getIntInput(prompt, 100, -1, 101);
+      }
+      else { // MUST BE AMINO ACID SEQUENCE
+         prompt = "Enter in the number for the PAM matrix to be used (eg 250 for PAM250) : ";
+         int PAMnum = getIntInput(prompt, 250, -1, 501);
+         motif_PAMArr[i] = new PAM(PAMnum);
+      }
+   }
+}
+
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void printToFile(SequenceClass *&S) {
+
+   //**********************************************************************
+   // PRE  : S is the sequence class that has been created
+   // POST : retrieves a file name from the user and then 
+   //        prints out the sequence class to that file
+   //**********************************************************************
+
+   ofstream outfile;
+   string outfn;
+
+   bool done = false;
+   while(!done) {
+      cout << "Enter the file name to print to: ";
+      cin >> outfn;
+
+      // CHECK TO SEE IF FILE EXISTS
+      if(fileExists(outfn)) {
+         string tmp = getCharInput("File exists: Overwrite? (Y or N)", "Y", "N");
+         if(tmp == "Y") {
+            outfile.open(outfn.c_str(), ios::trunc);
+            if(outfile) {
+               outfile << (*S) << endl;
+               done = true;
+               outfile.close();
+            }
+            else {
+               cerr << "ERROR ENCOUNTERED: CANNOT WRITE TO " << outfn << endl;
+            } 
+         }
+      }
+      else {     
+         outfile.open(outfn.c_str(), ios::out);
+
+         if(outfile) {
+             outfile << (*S) << endl;
+             done = true;
+             outfile.close();
+         } 
+         else {
+            cerr << "ERROR ENCOUNTERED: CANNOT WRITE TO " << outfn << endl;
+         }
+      }
+   }
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+int setResidues(char *&ResidueLabels, double *&ResiduePcts,
+                char seqType) {
+
+   //**********************************************************************
+   // PRE  : seqType is 'N' for DNA, 'P' for proteins
+   // POST : allocates the residue labels and percentages arrays
+   //**********************************************************************
+
+   if(seqType == 'N') {
+      ResidueLabels = new char[4];
+      ResiduePcts   = new double[4];
+      ResidueLabels[0] = 'A';   // ADENINE
+      ResidueLabels[1] = 'C';   // CYTOSINE
+      ResidueLabels[2] = 'G';   // GUANINE
+      ResidueLabels[3] = 'T';   // THYMINE
+      return(4);
+   }
+   else {
+      ResidueLabels = new char[20];
+      ResiduePcts   = new double[20];
+      ResidueLabels[0] = 'A';  // ALANINE
+      ResidueLabels[1] = 'R';  // ARGININE
+      ResidueLabels[2] = 'N';  // ASN
+      ResidueLabels[3] = 'D';  // ASPARTAMINE
+      ResidueLabels[4] = 'C'; 
+      ResidueLabels[5] = 'Q';
+      ResidueLabels[6] = 'E';
+      ResidueLabels[7] = 'G';
+      ResidueLabels[8] = 'H';
+      ResidueLabels[9] = 'I';
+      ResidueLabels[10] = 'L';
+      ResidueLabels[11] = 'K';
+      ResidueLabels[12] = 'M';
+      ResidueLabels[13] = 'F';
+      ResidueLabels[14] = 'P';
+      ResidueLabels[15] = 'S';
+      ResidueLabels[16] = 'T';
+      ResidueLabels[17] = 'W';
+      ResidueLabels[18] = 'Y';
+      ResidueLabels[19] = 'V';
+      return(20);
+   }
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void getOverallBackgroundResiduePct(ifstream &infile, char *ResidueLabels, 
+                                    double *&ResiduePcts, int numResidues) {
+
+   //**********************************************************************
+   // PRE  : infile is an open input file stream 
+   // POST : reads in the overall background residue frequencies from infile
+   //**********************************************************************
+   if(infile.eof()) { exit(26); }
+   double cumSum = 0.0;
+   for(int i = 0; i < numResidues; i++) {
+      char *tmpch;
+      tmpch = new char[1];
+      sprintf(tmpch, "%c", ResidueLabels[i]);
+      string tmpst(tmpch); 
+      string ResidueLabel = "OAPct" + tmpst;
+      double tmpdouble;
+      if(infile.eof()) { exit(26); }
+      getValidDoubleTokens(tmpdouble, infile, -1.0, 100.0, ResidueLabel, 11);
+      ResiduePcts[i] = tmpdouble;
+      cumSum += ResiduePcts[i];
+      delete [] (tmpch);
+   }
+  
+   // Normalize Residue Percentages to sum to 100
+   cumSum /= 100.0;
+   for(int i = 0; i < numResidues; i++) {
+      ResiduePcts[i] /= cumSum;
+   }
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void getUserDefinedMotifInfo(ifstream &infile, bool *&motif_isRandomArr, 
+                           string *&motif_seqArr, double *&motif_pctSeqConsArr,
+                           double *&motif_pctConsensusConsArr, 
+                           PAM **&motif_PAMArr, char seqType, int i) {
+
+   //**********************************************************************
+   // PRE  : infile is an open input file stream 
+   // POST : reads in the overall background residue frequencies from infile
+   //**********************************************************************
+
+   // Need to update this for differences between protein and dna
+   // sequences
+   
+   motif_isRandomArr[i] = false;
+   string motifLabel = setMotifLabel(i);
+   string currLabel = motifLabel + "Seq";
+   string tmpstr;
+   if(infile.eof()) { exit(26); }
+   if(seqType == 'P') { // PROTEIN SEQUENCE
+      getValidAASequenceTokens(tmpstr, infile, currLabel, 15);
+   }
+   else { // DNA SEQUENCE
+      getValidDNASequenceTokens(tmpstr, infile, currLabel, 15);
+   }
+   motif_seqArr[i] = tmpstr;
+   currLabel = motifLabel + "PctSeqsContain";
+   double tmpdouble;
+   if(infile.eof()) { exit(26); }
+   getValidDoubleTokens(tmpdouble, infile, -1, 101, currLabel, 16);
+   motif_pctSeqConsArr[i] = tmpdouble;
+   if(infile.eof()) { exit(26); }
+   if(seqType == 'P') { // PROTEIN SEQUENCE
+      getPAMValue(motif_PAMArr, infile, i, motifLabel);
+   }
+   else { // DNA SEQUENCE
+      getPctConserved(motif_pctConsensusConsArr, infile, i, motifLabel);
+   }
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void getPctConserved(double *&motif_pctConsensusConsArr, ifstream &infile, 
+                 int i, string motifLabel) {
+
+   //**********************************************************************
+   // PRE  : infile is open and motif_PAMArr has been allocated
+   // POST : reads in the PAM value from infile, allocates the array
+   //      : and sets it accordingly
+   //**********************************************************************
+
+   string currLabel = motifLabel + "PctCons";
+   double tmpdouble;
+   getValidDoubleTokens(tmpdouble, infile, -1, 101, currLabel, 17);
+   motif_pctConsensusConsArr[i] = tmpdouble;
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+string setMotifLabel(int i) {
+
+   //**********************************************************************
+   // PRE  : i is the motif number
+   // POST :  returns a string giving motif followed by i
+   //**********************************************************************
+
+   char *tmpNum;
+   tmpNum = new char[2];
+   sprintf(tmpNum, "%i", i+1);
+   string tmpNum2(tmpNum);
+   delete [] tmpNum;
+   string motifLabel = "motif" + tmpNum2;
+   return(motifLabel);
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void getRandomMotifInfo(ifstream &infile, bool *&motif_isRandomArr, 
+                        string *&motif_seqArr, double *&motif_pctSeqConsArr,
+                        double *&motif_pctConsensusConsArr,
+                        PAM **&motif_PAMArr, bool *&motif_isPalindromicArr,
+                        int *&motif_lenArr, char seqType, int i, int numResidues,
+ char *ResidueLabels, double **&motifPctArr) {
+
+
+    motif_isRandomArr[i] = true;
+    string motifLabel = setMotifLabel(i);
+    string currLabel = motifLabel + "Len";
+
+    int tmpint;
+    if(infile.eof()) { exit(26); }
+    getValidIntTokens(tmpint, infile, 0, 101, currLabel, 18);
+    motif_lenArr[i] = tmpint;
+    
+    if(seqType == 'N') { // DNA SEQUENCE
+       currLabel = motifLabel + "IsPalindrome";
+       vector <string>validChVector;
+       validChVector.clear();
+       validChVector.push_back("Y");
+       validChVector.push_back("N");
+       string isPalindrome;
+       if(infile.eof()) { exit(26); }
+       getValidCharTokens(isPalindrome, infile, validChVector, currLabel, 19);
+       if(isPalindrome == "Y") {
+          motif_isPalindromicArr[i] = true;
+       }
+       else {
+          motif_isPalindromicArr[i] = false;
+       }
+    }
+    getResidueFrequencies(infile, motifPctArr, ResidueLabels, motifLabel, i, numResidues);
+
+    currLabel = motifLabel + "PctSeqsContain";
+    if(infile.eof()) { exit(26); }
+    getValidIntTokens(tmpint, infile, -1, 101, currLabel, 16);
+    motif_pctSeqConsArr[i] = tmpint;
+  
+    if(infile.eof()) { exit(26); }
+    if(seqType == 'P') { // PROTEIN SEQUENCE
+        getPAMValue(motif_PAMArr, infile, i, motifLabel);
+    }
+    else { // NUCLEOTIDE SEQUENCE
+      getPctConserved(motif_pctConsensusConsArr, infile, i, motifLabel);
+    }
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void getResidueFrequencies(ifstream &inFile, double **&motifPctArr, 
+                           char *ResidueLabels, string motifLabel, int i,
+                           int numResidues) {
+
+   //**********************************************************************
+   // PRE  : infile is open and motif_PctArr has been allocated
+   // POST : reads in the residue frequencies from the infile, and sets
+   //      : the values accordingly 
+   //**********************************************************************
+    double cumSum = 0.0;
+    for(int j = 0; j < numResidues; j++) {
+       string Label = motifLabel + "Pct" + ResidueLabels[j];
+       double tmpdouble;
+       if(inFile.eof()) { exit(26); }
+       getValidDoubleTokens(tmpdouble, inFile, -1.0, 100.0, Label, 11);
+       motifPctArr[i][j] = tmpdouble;
+       cumSum += motifPctArr[i][j];
+    }
+    cumSum /= 100.0;
+    for(int j = 0; j < numResidues; j++) {
+       motifPctArr[i][j] /= cumSum;
+    }
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void getPAMValue(PAM **&motif_PAMArr, ifstream &infile, 
+                 int i, string motifLabel) {
+
+   //**********************************************************************
+   // PRE  : infile is open and motif_PAMArr has been allocated
+   // POST : reads in the PAM value from infile, allocates the array
+   //      : and sets it accordingly
+   //**********************************************************************
+
+    string currLabel = motifLabel + "PAM";
+    int pamVal;
+    if(infile.eof()) { exit(26); }
+    getValidIntTokens(pamVal, infile, -1, 501, currLabel, 17);
+    motif_PAMArr[i] = new PAM(pamVal);
+}
+//---------------------------------------------------------------------------
+
+ 
+//---------------------------------------------------------------------------
+void fileMode(string FN, char seqType){
+
+   //**********************************************************************
+   // PRE  : FN is a file name that exists
+   // POST : reads in the motif generation information from a file with
+   //      : a format of label=value
+   //      : checking to make sure each is appropriately listed
+   //**********************************************************************
+
+
+   double *ResiduePcts;
+   char   *ResidueLabels;
+   int seqLen;
+   int numMotifs;
+   int numSeqs;
+   bool finished;
+   bool   *motif_isRandomArr;
+   bool   *motif_isPalindromicArr;
+   int    *motif_lenArr;
+   string *motif_seqArr;
+   double *motif_pctSeqConsArr;
+   double *motif_pctConsensusConsArr;
+   PAM    **motif_PAMArr;
+   double **motifPctArr;
+   vector <string>validChVector;
+   string currLabel;
+   
+   int numResidues = setResidues(ResidueLabels, ResiduePcts, seqType);
+   if(!fileExists(FN)) {
+      exit(7);
+   }
+   ifstream infile;
+   infile.open(FN.c_str(), ios::in);
+   if(!infile) {
+      exit(7);
+   }
+   string currLine;
+   char *lhTok, *rhTok;
+   getValidIntTokens(numSeqs, infile, 0, 1001, "numSeq", 8);
+   getValidIntTokens(seqLen, infile, 9, 10001, "seqLen", 10);
+   getOverallBackgroundResiduePct(infile, ResidueLabels, 
+                                  ResiduePcts, numResidues);
+   getValidIntTokens(numMotifs, infile, -1, 11, "numMotifs", 13);
+   allocateMotifArrays(motif_isRandomArr, motif_lenArr, motif_seqArr,
+                       motif_pctSeqConsArr, motif_PAMArr, motifPctArr,
+                       motif_pctConsensusConsArr, numMotifs, numResidues,
+                       motif_isPalindromicArr);
+
+   for(int i = 0; i < numMotifs; i++) {
+      // RETRIEVE THE MOTIF-SPECIFIC INFORMATION
+      string motifLabel = setMotifLabel(i);
+      currLabel = motifLabel +  "Type";
+      string motiftype;
+      validChVector.clear();
+      validChVector.push_back("U");   
+      validChVector.push_back("R");
+ 
+      getValidCharTokens(motiftype, infile, validChVector, currLabel, 14);
+      if(motiftype == "U") {
+          getUserDefinedMotifInfo(infile, motif_isRandomArr, motif_seqArr, 
+                              motif_pctSeqConsArr, motif_pctConsensusConsArr,
+                              motif_PAMArr, seqType, i);
+      }
+      else {
+          getRandomMotifInfo(infile, motif_isRandomArr, motif_seqArr,
+                             motif_pctSeqConsArr, motif_pctConsensusConsArr,
+                             motif_PAMArr, motif_isPalindromicArr, 
+                             motif_lenArr, seqType, i, numResidues, 
+                             ResidueLabels, motifPctArr);
+      }
+   }
+   validChVector.clear();
+   validChVector.push_back("F");
+   validChVector.push_back("S");
+   string outputType;
+   currLabel="output";
+   if(infile.eof()) { exit(26); }
+   getValidCharTokens(outputType, infile, validChVector, currLabel, 22);
+   ofstream outfile;
+   if(outputType == "F") {
+       string outfn;
+       currLabel = "outFile";
+       if(infile.eof()) { exit(26); }
+       getStringTokens(outfn, infile, currLabel, 23);
+       outfile.open(outfn.c_str(), ios::out);
+       if(!outfile) {
+          exit(24);
+       }
+   }
+   infile.close();
+   SequenceClass *S;
+   S = new SequenceClass(seqLen, numMotifs, numSeqs, ResidueLabels, 
+                           ResiduePcts, seqType, numResidues);
+   S->setValues(motifPctArr, motif_lenArr, motif_PAMArr, motif_isRandomArr,
+                motif_seqArr, motif_pctSeqConsArr, motif_pctConsensusConsArr, seqType, motif_isPalindromicArr);
+
+   if(outputType == "F") {
+      S->printMotifConsensus(outfile);
+      outfile << *S << endl;
+      outfile.close();
+   }
+   else {
+      S->printMotifConsensus(cout);
+      cout << *S << endl;
+   }
+   delete [] ResiduePcts;
+   delete [] ResidueLabels;
+   delete [] motif_isRandomArr; 
+   delete [] motif_lenArr;
+   delete [] motif_seqArr;
+   delete [] motif_pctSeqConsArr;
+   for(int i = 0; i < numMotifs; i++) {
+      if(seqType == 'P') 
+         delete [] motif_PAMArr[i];
+      if(seqType == 'N')
+         delete [] motifPctArr[i];
+   }
+   if(motif_PAMArr) {
+      delete [] motif_PAMArr;
+   }
+   delete [] motifPctArr;
+}
+//---------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------
+void interactiveMode(){
+
+   //**********************************************************************
+   // PRE  : NONE
+   // POST : reads in the motif generation information from the keyboard
+   //**********************************************************************
+
+   int    seqLen;
+   int    numMotifs;
+   int    numSeqs;
+   bool   finished;
+   double *ResiduePcts;
+   char   *ResidueLabels;
+   PAM    **motif_PAMArr;
+   double **motifPctArr;
+   bool   *motif_isPalindromicArr;
+   bool   *motif_isRandomArr;
+   int    *motif_lenArr;
+   string *motif_seqArr;
+   double *motif_pctSeqConsArr;
+   double *motif_pctConsensusConsArr;
+   double *residueBackgroundFrequencies;
+   char seqType;
+
+   printWelcome();
+   printOverallHeader();
+   string tmp = getCharInput("Type of sequence to generate (N)ucleotide or (P)rotein : ", 
+                             "N", "P");
+   if(tmp == "P") { seqType = 'P'; }
+   if(tmp == "N") { seqType = 'N'; }
+
+   int numResidues = setResidues(ResidueLabels, ResiduePcts, seqType);
+
+   getOverallData(numSeqs, seqLen, ResiduePcts, ResidueLabels, numResidues, numMotifs);
+
+   allocateMotifArrays(motif_isRandomArr, motif_lenArr, motif_seqArr,
+                       motif_pctSeqConsArr, motif_PAMArr, motifPctArr,
+                       motif_pctConsensusConsArr, numMotifs, numResidues,
+                       motif_isPalindromicArr);
+
+   getMotifData(motif_isPalindromicArr, motif_isRandomArr, motif_lenArr,
+                motif_seqArr, motif_pctSeqConsArr, 
+                motif_pctConsensusConsArr, 
+                motifPctArr,
+                motif_PAMArr, numMotifs, seqType, numResidues, ResidueLabels);
+
+   SequenceClass *S;
+   S = new SequenceClass(seqLen, numMotifs, numSeqs, ResidueLabels, 
+                           ResiduePcts, seqType, numResidues);
+   S->setValues(motifPctArr, motif_lenArr, motif_PAMArr, motif_isRandomArr,
+                motif_seqArr, motif_pctSeqConsArr, motif_pctConsensusConsArr, 
+                seqType, motif_isPalindromicArr);
+
+   S->printMotifConsensus(cout);
+   tmp = getCharInput("Output to (S)creen or (F)ile : ", "S", "F");
+   if(tmp == "S") 
+      cout << *S << endl;
+   else {
+      printToFile(S);
+   }
+   delete [] ResiduePcts;
+   delete [] ResidueLabels;
+   delete [] motif_isPalindromicArr;
+   delete [] motif_isRandomArr;
+   delete [] motif_lenArr;
+   delete [] motif_seqArr;
+   delete [] motif_pctSeqConsArr;
+   delete [] motif_pctConsensusConsArr;
+   delete [] residueBackgroundFrequencies;
+   delete [] motif_PAMArr;
+   for(int i = 0; i < numMotifs; i++) 
+      delete [] motifPctArr[i];
+   delete [] motifPctArr;
+   delete S;
+}
+//---------------------------------------------------------------------------
+
+
+//---------------------------------------------------------------------------
+int main(int argc, char *argv[]) {
+
+   if(argc == 1) {
+      interactiveMode();
+   }
+   else if(argc != 4) {
+      exit(5);
+   }
+   else {
+      char residueType='N';
+      string arg1(argv[1]);
+      if(!((arg1 == "N") || (arg1 == "P"))) 
+         exit(5);
+      if(arg1 == "P")
+         residueType = 'P';
+
+      if(argc == 4) {
+         string arg2(argv[2]);
+         if(arg2 != "-f") {
+            exit(5);
+         }
+         string inFN(argv[3]);
+         fileMode(inFN, residueType);
+      }
+   }
+   return(EXIT_SUCCESS);
+}
+//---------------------------------------------------------------------------
+
+//============================================================================
+//--------------------------- END OF RandomMotifs.cpp ------------------------
+//============================================================================
+
+
+
+
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/RandomMotifs.H ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/RandomMotifs.H
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/RandomMotifs.H	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/RandomMotifs.H	2007-02-28 22:49:06.000000000 +0100
@@ -0,0 +1,112 @@
+
+//============================================================================
+//--------------------------- BEGIN OF RandomMotifs.H ------------------------
+//============================================================================
+
+//==========================================================================
+// rMotifGen
+// Eric C. Rouchka
+// C. Timothy Hardin
+// (c) 2004-2007, University of Louisville
+//
+// FILE:  RandomMotifs.H
+//
+//
+//    This file is part of rMotifGen.
+//
+//    rMotifGen is free software; you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation; either version 2 of the License, or
+//    (at your option) any later version.
+//
+//    rMotifGen is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    You should have received a copy of the GNU General Public License
+//    along with rMotifGen; if not, write to the Free Software
+//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+//
+//==========================================================================
+
+
+
+#ifndef MY_RANDOMMOTIFS_H
+#define MY_RANDOMMOTIFS_H
+
+#include "SequenceClass.H"
+#include "CommonRoutines.H"
+#include <iostream>
+#include <fstream>
+#include <string>
+#include <vector>
+#include <math.h>
+using namespace std;
+
+//------------------- LOCAL FUNCTION PROTOTYPES --------------------
+void printWelcome();
+void printOverallHeader();
+void printMotifHeader(int currMotif);
+
+void allocateMotifArrays(bool *&motif_isRandomArr,
+                           int *&motif_lenArr,
+                           string *&motif_seqArr,
+                           double *&motif_pctSeqConsArr,
+                           PAM **&motif_PAMArr,
+                           double **&motifPctArr,
+                           double *&motif_pctConsensusConsArr,
+                           int numMotifs,
+                           int numResidues,
+                           bool *&motif_isPalindromicArr);
+
+void getMotifData(bool * &motif_isPalindromicArr,
+                  bool * &motif_isRandomArr,
+                  int  * &motif_lenArr,
+                  string * &motif_seqArr,
+                  int    * &motif_pctSeqConsArr,
+                  int    * &motif_pctConsensusConsArr,
+                  int    * &motif_pctAArr,
+                  int    * &motif_pctCArr,
+                  int    * &motif_pctGArr,
+                  int    * &motif_pctTArr,
+                  int    numMotifs);
+
+void getUserDefinedMotifInfo(ifstream &infile, bool *&motif_isRandomArr,
+                           string *&motif_seqArr, double *&motif_pctSeqConsArr,
+                           double *&motif_pctConsensusConsArr,
+                           PAM *&motif_PAMArr, char seqType, int i);
+
+string setMotifLabel(int i);
+
+void getRandomMotifInfo(ifstream &infile, bool *&motif_isRandomArr,
+                        string *&motif_seqArr, double *&motif_pctSeqConsArr,
+                        double *&motif_pctConsensusConsArr,
+                        PAM **&motif_PAMArr, bool *&motif_isPalindromicArr,
+                        int *&motif_lenArr, char seqType, int i,
+                        int numResidues, char *ResidueLabels, double **&motifPctArr);
+
+void checkValidPercentages(int pctA, int pctC, int pctG, int pctT, int errorCode);
+
+void printToFile(SequenceClass *&S);
+
+void fileMode(string FN, char seqType);
+
+void getResidueFrequencies(ifstream &inFile, double **&motifPctArr,
+                           char *ResidueLabels, string motifLabel, 
+                           int i, int numResidues);
+
+void getPAMValue(PAM **&motif_PAMArr, ifstream &infile,
+                 int i, string motifLabel);
+
+void getPctConserved(double *&motif_pctConsensusConsArr, ifstream &infile,
+                 int i, string motifLabel);
+
+#endif
+
+//============================================================================
+//------------------------- END OF RandomMotifs.H  ---------------------------
+//============================================================================
+
+
+
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/README ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/README
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/README	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/README	2007-03-01 17:20:33.000000000 +0100
@@ -0,0 +1,180 @@
+//==========================================================================
+// rMotifGen
+// Eric C. Rouchka
+// C. Timothy Hardin
+// University of Louisville
+// (c) 2004-2007, Eric C. Rouchka and C. Timothy Hardin,
+//                University of Louisville
+//
+//    rMotifGen is free software; you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation; either version 2 of the License, or
+//    (at your option) any later version.
+//
+//    rMotifGen is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    You should have received a copy of the GNU General Public License
+//    along with rMotifGen; if not, write to the Free Software
+//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+//
+//==========================================================================
+
+____________________________________________________________________________
+DESCRIPTION 
+-----------
+
+	rMotifGen is a C++ program that allows users to construct DNA 
+	sequences containing either randomly generated or user-defined
+	motif sequences.  These sequences can be useful for simulation
+	purposes, or for testing of DNA motif dectection software.
+
+____________________________________________________________________________
+
+BUILDING rMotifGen
+------------------ 
+
+	rMotifGen was developed using ANSI C++.  rMotifGen uses the Makefile
+	build system.  In order to create the executable, 
+	type:
+
+		make
+
+	This will create the executable rMotifGen
+____________________________________________________________________________
+
+RUNNING rMotifGen
+-----------------
+
+        INTERACTIVE MODE
+
+	In order to run rMotifGen in interactive mode, type:
+
+		rMotifGen
+	
+	You will be prompted to enter in the number of random sequences
+	to generate, which must be greater than 0 and less than 1001.
+	For these sequences, you will be prompted for the length of each 
+	sequence, which must be greater than 9 and less than 10001.
+	For the overall sequence compostion, you will be prompted for the 
+	overall percent A, C, G, and T.  Each of these must be between 0
+	and 100, and the sum of all four must be equal to 100. 
+
+	You will be prompted to enter in the number of motifs per sequence,
+	which must be at least 0, and less than 11.  For each individual
+	motif, the user should enter in whether the motif is (U)ser defined
+	or (R)andom.  For those motifs that are user defined, you will be
+	prompted for the motif consensus sequence.  If the motif is random,
+	you will be prompted to determine the length of the motif, whether
+	or not the motif is palindromic, and the compostion of the motif.
+	For each motif, you will then be prompted for the percent conservatiton
+	of the motif within each of the sequences, and then the percent
+	conservation of the motif consensus in each sequence.  The
+	conservation must be at least 0, and at most 100.
+
+	The consensus for each motif will then be displayed, and the user
+	will be prompted to display the sequences to the screen or to a file.
+	The resulting sequences will be in FASTA format, with the first line
+	containing a description of the sequence, followed by a space, followed
+        by the location of each of the motifs, respectively.  If a motif was 
+	not included in the sequence, it will have a position of -1.
+
+
+        FILE MODE
+
+        In order to run rMotifGen in file mode, type:
+
+              rMotifGen <residueType> -f <infile>
+  
+        Where residueType is either 'N' for nucleic acids, or 'P' for
+        proteins.
+
+        The input file format will be similar for both nucleic acids and 
+        proteins.  The included file AAinput.dat is an example input file for
+        amino acids, and the file input.dat is an example file for nucleic
+        acids.  The format for these files is LABEL=VALUE where the labels are
+        found in the following order:
+        numSeq=            // Number of random sequences to generate
+        seqLen=            // Length of each of the random sequences
+        OAPct<Residue_x>=  // Background count of residue y where
+                           // y = A, C, G, T for DNA, or 
+                           // y = A,R,N,D,C,Q,E,G,H,I,L,K,M,F,P,S,T,W,Y,V 
+                           // for amino acids (note they must appear in this
+                           // order)
+        numMotifs=         // number of motifs to generate
+        motif<X>Type=      // Where X=1..numMotifs --  the value can
+                           // be 'U' for user defined or 'R' for random
+        motif<X>Seq=       // Only Valid if Type = 'U' -- consensus motif
+        motif<X>PctSeqsContain= // Percentage of sequences that contain this 
+                                // motif 
+        motif<X>PAM=            // PAM matrix to use (only for Amino acids)
+        motif<X>PctCons=        // Percent conservation of motif consensus
+                                // (only for DNA sequences)
+        motif<X>Pct<Residue_y>= // Motif frequency for residue y where 
+                                // y is the same as described above
+        output=                 // 'F' for file, 'S' for screen
+        outFile=                // only if output='F'
+ 
+
+____________________________________________________________________________
+
+ERROR CODES
+-----------
+5 -- Invalid Usage
+7 -- Input file does not exist
+8 -- Invalid number of sequences n ( 0 < n < 1001)
+9 -- Invalid sequence length l (9 < l < 10001)
+11 -- Invalid OAPct p (-1 < p < 100)
+12 -- Invalid total overall percentage (must equal 100)
+13 -- Invalid number of motifs m (-1 < m < 11)
+14 -- Invalid character
+15 -- Invalid DNA or PROTEIN sequence
+16 -- Invalid percentage conserved p (-1 < p < 101)
+17 -- Invalid percentage motif conserved p (-1 < p < 101)
+18 -- Invalid motif length m (-1 < m < 101)
+19 -- Invalid isPalindrome token (Y or N)
+20 -- Invalid motif residue percentage p (0 < p < 100)
+21 -- Invalid total reside percentage (must sume to 100)
+22 -- Invalid output type (F for File, S for Screen)
+23 -- Invalid output file name
+24 -- Output file does not exist
+25 -- Invalid PAM (must be between 0 and 500)
+26 -- Invalid EOF
+
+ADDITIONAL FILES 
+----------------
+	
+	For authorship information, see the CREDITS file.
+	For license information, see the LICENSE file.
+	For further information, see:
+		http://kbrin.a-bldg.louisville.edu/Tools/rMotifGen/
+
+____________________________________________________________________________
+
+REFERENCES 
+----------
+	If you use rMotifGen, please cite:
+
+	Rouchka EC, Hardin CT (2007) rMotifGen: random motif generator
+	for genomic sequences.  (under review)
+
+
+____________________________________________________________________________
+
+CONTACT
+-------
+	For more information, see the website:
+		http://kbrin.a-bldg.louisville.edu/Tools/rMotifGen/
+
+        Or contact:
+		Eric C. Rouchka
+		University of Louisville
+		Speed School of Engineering
+		Department of Computer Engineering and Computer Science
+		123 JB Speed Building
+		Louisville, KY 40292
+
+		eric.rouchka@louisville.edu
+____________________________________________________________________________
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/SequenceClass.cpp ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/SequenceClass.cpp
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/SequenceClass.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/SequenceClass.cpp	2007-03-01 17:22:38.000000000 +0100
@@ -0,0 +1,604 @@
+
+
+//============================================================================
+//------------------------ BEGIN OF SequenceClass.cpp ------------------------
+//============================================================================
+
+//==========================================================================
+// rMotifGen
+// Eric C. Rouchka
+// C. Timothy Hardin
+// (c) 2004-2007, University of Louisville
+//
+// FILE:  SequenceClass.cpp
+//
+//
+//    This file is part of rMotifGen.
+//
+//    rMotifGen is free software; you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation; either version 2 of the License, or
+//    (at your option) any later version.
+//
+//    rMotifGen is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    You should have received a copy of the GNU General Public License
+//    along with rMotifGen; if not, write to the Free Software
+//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+//
+//==========================================================================
+
+//==========================================================================
+
+#include "SubstitutionMatrices.H"
+#include "SequenceClass.H"
+#include <iostream>
+#include <sstream>
+#include <string>
+#include <cstdlib>
+#include <time.h>
+using namespace std;
+
+//-----------------------------------------------------------------------------
+ostream &operator << (ostream &os, SequenceClass s) {
+
+   //**************************************************************************
+   // PRE:  os is a defined output stream (console, error, or file)
+   //       s  is a valid instance of the sequence class
+   // POST: the returned value will print out the header and sequence
+   // DESCRIPTION: This is the overloaded output operator for the 
+   //              SequenceClass
+   //**************************************************************************
+
+   for(int i = 0; i < s.numSeqs; i++) {
+      os << s.seqHdrs[i] << endl;
+      string currSeq = s.formatSeq(s.seqs[i], 60, 60, false);
+      os << currSeq;
+   }
+   return(os);
+}
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+void SequenceClass::setValues(double **&mFreqArr, int *&mLenArr,
+                                PAM **&mPAMArr, bool *&useRandomConsArr,
+                                string *&userConsensusArr, double *&nMotifsConsArr, double *&pctConsConsArr, char seqType, bool *&isPalindromicArr) {
+
+   //**************************************************************************
+   // PRE:  NONE
+   // POST: NONE
+   // DESCRIPTION: Sets the values for the data members of the SequenceClass
+   //**************************************************************************
+   for(int i = 0; i < numMotifs; i++) 
+   {
+      for(int j = 0; j < numResidues; j++) {
+         FreqArr[i][j] = (long double)mFreqArr[i][j];
+      }
+      motifLenArr[i] = mLenArr[i];
+      if(seqType == 'P') {
+      PAMArr[i]      = *(mPAMArr[i]);
+      }
+      palindromeArr[i] = isPalindromicArr[i]; 
+
+      randomConsArr[i] = useRandomConsArr[i];
+      userConsArr[i] = !(useRandomConsArr[i]);
+      userConsSeqArr[i] = userConsensusArr[i];
+      pctMotifsConsArr[i] = nMotifsConsArr[i];
+      pctConservedArr[i] = pctConsConsArr[i];
+   }
+   generateSequences();
+}
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+void SequenceClass::printMotifConsensus(ostream &os) {
+
+   //**************************************************************************
+   // PRE:  NONE
+   // POST: NONE
+   // DESCRIPTION: Prints the current motif sequence for each motif
+   //              To the specified output stream
+   //**************************************************************************
+
+   os << endl;
+   os << "NUMMOTIFS: " << numMotifs << endl;
+   for(int i = 0; i < numMotifs; i++) {
+      int currMotif = i + 1;
+      os << "Motif " << currMotif << " consensus: " << consMotifArr[i] << endl;
+   }
+   os << endl;
+}
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+string SequenceClass::randomSeq(int len, char *labelArr, long double *FreqArr, bool isPalindrome)
+{
+   //**************************************************************************
+   // PRE:  NONE
+   // POST: NONE
+   // DESCRIPTION:
+   //**************************************************************************
+   string s = "";
+   int i = 0;
+
+   if(isPalindrome) {
+      int halflen = len / 2;
+      string post = "";
+      while(i < halflen) {
+         int val = lrand48() % 101;
+         long double cumSum = 0;
+         for(int j = 0; j < numResidues; j++) {
+            cumSum += FreqArr[j];
+            if(val < cumSum) {
+               s += labelArr[j];
+               if(labelArr[j] == 'A') { post = "T" + post; }
+               if(labelArr[j] == 'C') { post = "G" + post; }
+               if(labelArr[j] == 'G') { post = "C" + post; }
+               if(labelArr[j] == 'T') { post = "A" + post; }
+               j = numResidues;
+            }
+         }
+         i++;
+      }
+      if((len % 2) != 0) {
+         int val = lrand48() % 101;
+         long double cumSum = 0;
+         for(int j = 0; j < numResidues; j++) {
+            cumSum += FreqArr[j];
+            if(val < cumSum) {
+               s += labelArr[j];
+               j = numResidues;
+            }
+         }
+      }
+      s += post;
+   }
+   else {
+      while (i < len)
+      {
+         int val = lrand48() % 101;
+         long double cumSum = 0;
+         for(int j = 0; j < numResidues; j++) {
+            cumSum += FreqArr[j];
+            if(val < cumSum) {
+               s += labelArr[j];
+               j = numResidues;
+            }
+         }
+         i++;
+      }
+   }
+   return(s);
+}
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+void SequenceClass::createRandomSequences() 
+{
+   //**************************************************************************
+   // PRE:  NONE
+   // POST: NONE
+   // DESCRIPTION: creates random sequences
+   //**************************************************************************
+   string currSeq;
+   for(int i = 0; i < numSeqs; i++) 
+   {
+      currSeq = "";
+      currSeq = randomSeq(seqLens, LabelArr, overallFreqArr, false);
+      seqs[i] = currSeq;
+   }
+}
+//-----------------------------------------------------------------------------
+
+
+//-----------------------------------------------------------------------------
+void SequenceClass::createConsensusMotifs() 
+{
+   //**************************************************************************
+   // PRE:  NONE
+   // POST: NONE
+   // DESCRIPTION: Creates consensus motif patterns
+   //**************************************************************************
+
+   // NOW CREATE RANDOM MOTIFS
+   string currSeq;
+	
+   for(int i = 0; i < numMotifs; i++) 
+   {
+      if(randomConsArr[i]) {
+         currSeq = "";
+         currSeq = randomSeq(motifLenArr[i], LabelArr, FreqArr[i], palindromeArr[i]);
+         consMotifArr[i] = currSeq;
+      }
+      else {
+         consMotifArr[i] = userConsSeqArr[i];
+         motifLenArr[i] = consMotifArr[i].length();
+      }
+   }
+}
+
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+bool SequenceClass::isValid(int pos, bool *used, int len)
+{
+   //**************************************************************************
+   // PRE:  NONE
+   // POST: NONE
+   // DESCRIPTION: This is the default constructor for the sequence class
+   //**************************************************************************
+   for (int i = pos; i < (pos + len); i++)
+   {
+       if (used[i])
+          return (false);   // Position is occupied
+   }
+       return (true);            // Position is unoccupied
+}
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+void SequenceClass::generateSequences() 
+{
+   //**************************************************************************
+   // PRE:  NONE
+   // POST: NONE
+   // DESCRIPTION: 
+   //**************************************************************************
+
+// FIRST, CREATE RANDOM SEQUENCES
+   MotifsToInclude();        // Set which motifs are included 
+   createRandomSequences();  
+   createConsensusMotifs();
+   bool *usedArr;
+
+   for(int i = 0; i < numSeqs; i++) 
+   {
+      // Initialize all positions to be valid motif start positions
+      usedArr = new bool[seqLens];
+      for (int j = 0; j < seqLens; j++)
+      {
+         usedArr[j] = false;
+      }
+
+      for(int j = 0; j < numMotifs; j++) 
+      {
+         if (includeMotifArr[i][j])
+         {
+            int newLen = seqLens - motifLenArr[j];
+            int currLoc = (int)lrand48() % newLen;
+            while (!isValid(currLoc, usedArr, motifLenArr[j]))
+            {
+               currLoc = (int)lrand48() % newLen;
+            }
+            motifPosArr[i][j] = currLoc;
+            for (int k = currLoc; k < (currLoc + motifLenArr[j]); k++)
+            {
+               usedArr[k] = true;
+            }
+         }
+         else
+         {
+            motifPosArr[i][j] = -1;
+         }
+      }
+
+      for(int j = 0; j < numMotifs; j++) 
+      {
+         if (motifPosArr[i][j] != -1)
+         {
+            string currMotif;
+            if(seqType == 'P') {
+               currMotif = mutate(consMotifArr[j], PAMArr[j]);
+            }
+            else {
+               currMotif = mutate(consMotifArr[j], pctConservedArr[j]);
+            }
+            seqs[i] = seqs[i].replace(motifPosArr[i][j], motifLenArr[j], currMotif);
+         }
+      }
+   }
+
+   // ---------------------------------
+   // Create the random sequence header
+   // ---------------------------------
+
+   for(int i = 0; i < numSeqs; i++) 
+   {
+      string currhdr = "";
+      int currSeq = i + 1;
+      string mName = "rMotifGen_RandSeq_" + itos(currSeq);
+      currhdr = ">" + mName + " " + itos(numMotifs) + " ";
+      for(int j = 0; j < numMotifs; j++)
+         currhdr += itos(motifPosArr[i][j]) + " ";
+      seqHdrs[i] = currhdr;
+   }
+
+   delete [] usedArr;
+}
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+string itos(int i) {
+   stringstream s;
+   s << i;
+   return(s.str());
+}
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+string SequenceClass::formatSeq(string s, int width, int blockWidth, 
+                        bool numbersOn) 
+{
+   //**************************************************************************
+   // PRE:  NONE
+   // POST: NONE
+   // DESCRIPTION: 
+   //**************************************************************************
+   if(width % blockWidth != 0) 
+      return(s);
+
+   string formatSeq = "";
+   int len = (int)s.length();
+   int numLines = (int)(len/width);
+   int remainder = len % width;
+   string currSegment = "";
+   int begNum = 0;
+   int endNum = 0;
+
+   int numDigits = calculateDigits(len);
+
+   for(int currLine = 0; currLine < numLines; currLine++) 
+   {
+      currSegment = "";
+      if(numbersOn) 
+      {
+         begNum = 1 + width * currLine;
+         endNum = begNum + width - 1;
+         int currDigits = calculateDigits(begNum);
+         for(int i = 0; i < (numDigits - currDigits); i++) 
+         {
+            currSegment += " ";
+         }
+         currSegment += begNum + " ";
+      }
+      int numBlocks = (width / blockWidth);
+      for(int currBlock = 0; currBlock < numBlocks; currBlock++) 
+      {
+         currSegment += s.substr(currLine * width + currBlock * blockWidth, blockWidth);
+         currSegment += " ";
+      }
+      if(numbersOn) 
+      {
+         currSegment += " ";
+         currSegment += endNum;
+      }
+      formatSeq += currSegment + "\n";
+
+   }
+   if(remainder > 0) 
+   {
+      int rem = remainder;
+      string remainingSeq = s.substr(numLines * width, remainder);
+      len = remainingSeq.length();
+      int numBlocks = (int)(len / blockWidth);
+      remainder = len % blockWidth;
+   
+      if(numbersOn) 
+      {
+         begNum = 1 + width * numLines;
+         endNum = (int)s.length();
+         int currDigits = calculateDigits(begNum);
+         for(int i = 0; i < numDigits - currDigits; i++) 
+         {
+            formatSeq += " ";
+         }
+         formatSeq += begNum + " ";
+      }
+      for(int currBlock = 0; currBlock < numBlocks; currBlock++) 
+      {
+         formatSeq += remainingSeq.substr(currBlock * blockWidth, blockWidth);
+         formatSeq += " ";
+      }
+      if(remainder != 0) 
+      {
+         formatSeq += remainingSeq.substr(numBlocks * blockWidth, remainder);
+      }
+      if(numbersOn) 
+      {
+         int blocks = (int)(width / blockWidth) - numBlocks;
+         int numSpaces = width - rem + blocks + 1;
+         for(int i = 0; i < numSpaces; i++) 
+         {
+            formatSeq += " ";
+         }
+         formatSeq += endNum;
+      }
+      formatSeq += "\n";
+   }
+   return(formatSeq);
+}
+
+//-----------------------------------------------------------------------------
+		
+//-----------------------------------------------------------------------------
+int SequenceClass::calculateDigits(int len) 
+{
+   //**************************************************************************
+   // PRE:  NONE
+   // POST: NONE
+   // DESCRIPTION: returns the number of digits in the number len
+   //**************************************************************************
+   int num = len;
+   int n = 0;
+   while((int)(num/10) != 0) 
+   {
+      n++;
+      num /= 10;
+   }
+   return(n);
+}
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+void SequenceClass::MotifsToInclude() {
+
+   //**************************************************************************
+   // PRE: numSeqs has been set (>0) as has numMotifs
+   // POST: includeMotifArr set appropriately
+   // DESCRIPTION: This function is used to determine which motifs will be
+   //              included in the sequences based upon the percentage of
+   //              motifs that are conserved
+   //**************************************************************************
+
+   for(int i = 0; i < numSeqs; i++) {
+       for(int j = 0; j < numMotifs; j++) {
+           int randVal = lrand48() % 101;
+           if(randVal > pctMotifsConsArr[j]) {
+               includeMotifArr[i][j] = false;
+           }
+           else {
+               includeMotifArr[i][j] = true;
+           }
+       }
+   }
+   return;
+}
+//-----------------------------------------------------------------------------
+        
+//-----------------------------------------------------------------------------
+int SequenceClass::getSeqLens()     { return(seqLens); }
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+double SequenceClass::getOverallPct(char residueToFind) {
+   int index = getIndex(residueToFind);
+   if(index == -1) 
+      return(-1);
+   else
+      return(overallFreqArr[index]);
+}
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+int SequenceClass::getIndex(char residueToFind) {
+   for(int i = 0; i < numResidues; i++) {
+      if(LabelArr[i] == residueToFind) {
+         return(i);
+      }
+   }
+   return(-1);
+}
+//-----------------------------------------------------------------------------
+
+int SequenceClass::getNumMotifs()   { return(numMotifs); }
+int SequenceClass::getNumSeqs()     { return(numSeqs); }
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+SequenceClass::~SequenceClass() {
+
+   //**************************************************************************
+   //PRE:         NONE
+   //POST:        Memory dynamically allocated for Sequence class is free
+   //DESCRIPTION: Destructor for SequenceClass
+   //**************************************************************************
+
+   if(!destructorCalled) {
+      delete [] LabelArr;
+      delete [] overallFreqArr;
+      delete [] motifLenArr;
+      if(PAMArr)
+         delete [] PAMArr;
+      delete [] pctMotifsConsArr;
+      delete [] randomConsArr;
+      delete [] userConsArr;
+      delete [] userConsSeqArr;
+      delete [] palindromeArr;
+      for(int i = 0; i < numMotifs; i++) {
+         delete[] FreqArr[i];
+      }
+      delete[] FreqArr;
+      for(int i = 0; i < numSeqs; i++) {
+         delete [] motifPosArr[i];
+         delete [] includeMotifArr[i];
+      } 
+      delete [] motifPosArr;
+      delete [] includeMotifArr;
+      destructorCalled = true;
+   }
+}
+//-----------------------------------------------------------------------------
+
+
+//-----------------------------------------------------------------------------
+SequenceClass::SequenceClass(int s, int nm, int ns, char *labelArr,
+                                 double *tmpFreqArr, char st, int nr)
+{
+   //**************************************************************************
+   //PRE: s is the length of the sequences to produce (>10)
+   //     tmpFreqArr is the amino acid frequency array which must sum to 100
+   //     nm is the number of motifs (>0)
+   //     ns is the number of sequences (>0))
+   //POST:
+   //DESCRIPTION: This is a constructor for the sequence class
+   //**************************************************************************
+
+   seqLens = s;
+   numMotifs = nm;
+   numSeqs = ns;
+   seqType = st;
+   numResidues = nr;
+   destructorCalled = false;
+
+   //------------------------------------------------------------
+   // ALLOCATE SPACE FOR THE PRIVATE DATA MEMBERS FOR THE CLASS
+   // Values should be set in the setValues function
+   //------------------------------------------------------------
+
+   PAMArr           = new PAM[numMotifs];    // Substitution matrix array
+   randomConsArr    = new bool[numMotifs];   // Random consensus motif?
+   userConsArr      = new bool[numMotifs];   // User consensus motif?
+   userConsSeqArr   = new string[numMotifs]; // User consensus motif sequence
+   motifLenArr      = new int[numMotifs];    // length of motifs
+   pctMotifsConsArr = new double[numMotifs];    // Pct motifs conserved/sequence
+   LabelArr       = new char[numResidues]; // Residue labels
+   overallFreqArr = new long double[numResidues];   // Overall residue frequencies
+   pctConservedArr  = new double[numMotifs]; // Pct conservation inside motif
+   palindromeArr    = new bool[numMotifs];  // Palindromic motif?
+
+   for(int i = 0; i < numResidues; i++) {
+      LabelArr[i] = labelArr[i];
+      overallFreqArr[i] = (long double)tmpFreqArr[i];
+   }
+
+   //------------------------------------------------------------
+   // ALLOCATE SPACE FOR THE PUBLIC DATA MEMBERS FOR THE CLASS
+   // Values will be assigned in the generateSequences Function
+   //------------------------------------------------------------
+   seqs             = new string[numSeqs];   // Overall Sequences
+   seqHdrs          = new string[numSeqs];   // Sequence Headers
+   consMotifArr     = new string[numMotifs]; // Consensus Motif
+   motifPosArr      = new int *[numSeqs];    // Motif Positions
+   includeMotifArr  = new bool *[numSeqs];   // Is motif included in sequence
+
+   for (int i = 0; i < numSeqs; i++)
+   {
+      motifPosArr[i] = new int[numMotifs];
+      includeMotifArr[i] = new bool[numMotifs];
+   }
+   FreqArr   = new long double *[numMotifs];  
+   for(int i = 0; i < numMotifs; i++) {
+      FreqArr[i] = new long double[numResidues];
+   }
+   srand48(time(NULL));
+}
+
+//============================================================================
+//------------------------ END OF SequenceClass.cpp ------------------------
+//============================================================================
+
+
+
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/SequenceClass.H ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/SequenceClass.H
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/SequenceClass.H	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/SequenceClass.H	2007-02-28 22:55:14.000000000 +0100
@@ -0,0 +1,105 @@
+
+//============================================================================
+//------------------------ BEGIN OF SequenceClass.H --------------------------
+//============================================================================
+
+//==========================================================================
+// rMotifGen
+// Eric C. Rouchka
+// C. Timothy Hardin
+// (c) 2004-2007, University of Louisville
+//
+// FILE: SequenceClass.H
+//
+//
+//    This file is part of rMotifGen.
+//
+//    rMotifGen is free software; you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation; either version 2 of the License, or
+//    (at your option) any later version.
+//
+//    rMotifGen is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    You should have received a copy of the GNU General Public License
+//    along with rMotifGen; if not, write to the Free Software
+//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+//
+//==========================================================================
+
+//==========================================================================
+
+#ifndef MY__SEQCLASS_H
+#define MY__SEQCLASS_H
+
+#include "SubstitutionMatrices.H"
+#include <string>
+#include <cstdlib>
+#include <iostream>
+using namespace std;
+
+string itos(int i);
+
+class SequenceClass
+{
+   public:
+      SequenceClass(int s, int nm, int ns, char 
+                      *labelArr, double *tmpFreqArr, char st, int nr);
+      ~SequenceClass();
+      int getSeqLens();
+      double getOverallPct(char residue);
+      int getNumMotifs();
+      int getNumSeqs();
+      void MotifsToInclude();
+      string randomSeq(int len, char *labelArr, long double *FreqArr, bool isPalindrome);
+      void createRandomSequences();
+      void createConsensusMotifs();
+      bool isValid(int pos, bool *used, int len);
+      void generateSequences();
+      string formatSeq(string s, int width, int blockWidth, bool numbersOn);
+      int calculateDigits(int len);
+      void setValues(double **&FreqArr, int *&mLenArr, 
+                     PAM **&mPAMArr, bool *&useRandomConsArr, 
+                     string *&userConsensusArr, double *&nMotifsConsArr,
+                     double *&PctConsensusConserverdArr, char seqType,
+                     bool *&isPalindromicArr);
+      void printMotifConsensus(ostream &os);
+      int getIndex(char aminoAcid);
+      friend ostream &operator << (ostream &os, SequenceClass s);
+      int seqLens;
+      int numMotifs;
+      int numSeqs;
+      string *seqs;
+      string *seqHdrs;
+      string *consMotifArr;
+      int **motifPosArr;
+      bool **includeMotifArr;
+
+   private:
+      char *LabelArr;
+      long double *overallFreqArr;
+      long double **FreqArr;
+      int *motifLenArr;
+      double *pctConservedArr;   // Percent conservation of nts inside of single motif
+      double *pctMotifsConsArr;  // Percentage of motifs conserved per sequence
+      bool *palindromeArr;
+      bool *randomConsArr;
+      bool *userConsArr;
+      string *userConsSeqArr;
+      PAM *PAMArr;
+      char seqType;
+      int numResidues;
+      bool destructorCalled;
+};
+
+#endif
+
+//============================================================================
+//------------------------ END OF SequenceClass.H --------------------------
+//============================================================================
+
+
+
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/SubstitutionMatrices.cpp ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/SubstitutionMatrices.cpp
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/SubstitutionMatrices.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/SubstitutionMatrices.cpp	2007-02-28 22:58:25.000000000 +0100
@@ -0,0 +1,331 @@
+
+//==========================================================================
+// -----------------   BEGIN OF  SubstitutionMatricies.cpp -----------------
+//==========================================================================
+
+//==========================================================================
+// rMotifGen
+// Eric C. Rouchka
+// C. Timothy Hardin
+// (c) 2004-2007, University of Louisville
+//
+// FILE: SubstitutionMatrices.cpp
+//
+//
+//    This file is part of rMotifGen.
+//
+//    rMotifGen is free software; you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation; either version 2 of the License, or
+//    (at your option) any later version.
+//
+//    rMotifGen is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    You should have received a copy of the GNU General Public License
+//    along with rMotifGen; if not, write to the Free Software
+//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+//
+//==========================================================================
+
+#include "SubstitutionMatrices.H"
+
+//==========================================================================
+long double PAM::rowSum(int r) {
+
+   //***********************************************************************
+   // PRE:  r is the row number (between 0 and 19) to find the sum for
+   // POST: returns the sum of the probabilities for row r
+   // DESCRIPTION: 
+   //***********************************************************************
+
+   if((r < 0) || (r > 19)) {
+      exit(0);
+   }
+
+   long double rS = 0;
+   for(int c = 0; c < 20; c++) {
+      rS += matrix[r][c];
+   }   
+   return(rS);
+}
+//==========================================================================
+
+//==========================================================================
+long double PAM::colSum(int c) {
+
+   //***********************************************************************
+   // PRE:  c is the column number (between 0 and 19) to find the sum for
+   // POST: returns the sum of the probabilities for column c
+   // DESCRIPTION: 
+   //***********************************************************************
+
+   if((c < 0) || (c > 19)) {
+      exit(0);
+   }
+
+   long double cS = 0;
+   for(int r = 0; r < 20; r++) {
+      cS += matrix[r][c];
+   }
+   return(cS);
+}
+//==========================================================================
+
+//==========================================================================
+char PAM::substitute(char c) {
+
+   //***********************************************************************
+   // PRE:  
+   // POST:
+   // DESCRIPTION: 
+   //***********************************************************************
+
+   int index = findAAIndex(c);
+   long double rS = rowSum(index);
+   long double runningSum = 0;
+   double rVal = drand48();
+   for(int col = 0; col < 20; col++) {
+      runningSum += matrix[index][col] / rS;
+      if(rVal < runningSum) {
+         return(labels[col]);
+      }
+   }
+   return(c);
+}
+//==========================================================================
+
+//==========================================================================
+PAM::PAM() {
+   //***********************************************************************
+   // PRE:  
+   // POST:
+   // DESCRIPTION: 
+   //***********************************************************************
+   setInitialMatrix();
+}
+//==========================================================================
+
+//==========================================================================
+PAM::PAM(int val) {
+
+   //***********************************************************************
+   // PRE:   val is the number of the PAM matrix, between 1 and 500
+   // POST:  sets the matrix data member
+   // DESCRIPTION: note that PAM matrices are calculated by multiplying
+   //              the PAM1 n times to get PAMn -- if PAM is < 1 or > 500,
+   //              them PAM1 is used
+   //***********************************************************************
+
+   setInitialMatrix();              // calculates PAM1
+   if((val > 1) && (val < 501)) {
+
+      // FIRST CALCULATE PAM1
+      long double PAM1[20][20];
+      for(int r = 0; r < 20; r++) {
+         for(int c = 0; c < 20; c++) {
+            PAM1[r][c] = matrix[r][c];
+         }
+      }
+ 
+      // THEN FIND PAMn BY MULTIPLYING BY PAM1 n TIMES
+      long double tmpMatrix[20][20];
+      for(int i = 2; i <= val; i++) {
+         for(int r = 0; r < 20; r++) {
+            for(int c = 0; c < 20; c++) {
+               long double cVal = 0;
+               for(int j = 0; j < 20; j++) {
+                  cVal += PAM1[r][j] * matrix[j][c];
+               }
+               tmpMatrix[r][c] = cVal;
+            }
+         }
+         for(int r = 0; r < 20; r++) {
+            for(int c = 0; c < 20; c++) {
+               matrix[r][c] = tmpMatrix[r][c];
+            }
+         }
+      }
+  }
+  else {
+    if(val == 0) {
+      for(int r = 0; r < 20; r++) {
+         for(int c = 0; c < 20; c++) {
+            if(r == c) {
+               matrix[r][c] = 1;
+            }
+            else {
+               matrix[r][c] = 0;
+            }
+         }
+      }
+    }
+     // ELSE DO NOTHING -- PAM1 BY DEFAULT
+  } 
+}
+//==========================================================================
+
+//==========================================================================
+void PAM::normalizeMatrix() {
+
+   //***********************************************************************
+   // PRE:   NONE
+   // POST:  Normalizes a row by dividing by the rowSum
+   // DESCRIPTION:  NOT A GOOD IDEA TO USE, SINCE COLS ARE NO LONGER VALID
+   //***********************************************************************
+
+   for(int r = 0; r < 20; r++) {
+      long double rS = rowSum(r);
+      for(int c = r; c < 20; c++) {
+         matrix[r][c] /= rS;
+         matrix[c][r] /= rS;
+      }
+  }
+}
+//==========================================================================
+
+//==========================================================================
+void PAM::printMatrix() {
+
+   //***********************************************************************
+   // PRE:   the pam matrix has been allocated and set
+   // POST:  prints out row by row the values in the PAM matrix
+   // DESCRIPTION: 
+   //***********************************************************************
+
+   cout << setw(6);
+   for(int r = 0; r < 20; r++) {
+      for(int c = 0; c < 20; c++) {
+         cout << matrix[r][c] << " ";
+      }
+      cout << endl;
+   }
+}
+
+//==========================================================================
+
+//==========================================================================
+int PAM::findAAIndex(char ch) {
+
+   //**************************************************************************
+   // PRE:   ch is a valid (uppercase) amino acid character
+   // POST:  returns the index of the character in the labels array
+   //        or -1 if it is not found
+   // DESCRIPTION: 
+   //**************************************************************************
+
+   for(int i = 0; i < 20; i++) {
+      if(labels[i] == ch) {
+         return(i);
+      }
+   }
+   return(-1);
+}
+
+//==========================================================================
+
+//==========================================================================
+void PAM::setInitialMatrix() {
+
+   //**************************************************************************
+   // PRE:   the file PAM1.prob exists, and contains the PAM1 matrix in 
+   //        terms of probabilities multiplied by 10000
+   // POST:
+   // DESCRIPTION: 
+   //**************************************************************************
+
+   ifstream infile;
+   infile.open("PAM1.prob", ios::in);
+   if(!infile) {
+      exit(7);
+   }
+   for(int c = 0; c < 20; c++) {
+      char ch; 
+      infile >> ch;
+      labels[c] = ch;
+   }
+   for(int r = 0; r < 20; r++) {
+      char ch;
+      infile >> ch;
+      for(int c = 0; c < 20; c++) {
+         int tmpVal;
+         infile >> tmpVal;
+         matrix[r][c] = tmpVal / 10000.0; 
+      }
+   } 
+   for(int r = 0; r < 20; r++) {
+      for(int c = r+1; c < 20; c++) {
+         long double avg = (matrix[r][c] + matrix[c][r]) / 2.0;
+         matrix[r][c] = matrix[c][r] = avg;
+      }
+   }
+   infile.close();
+}
+//==========================================================================
+
+//==========================================================================
+string mutate(string s, PAM p) {
+
+   //**************************************************************************
+   // PRE:  s is a valid amino acid sequence; p is a PAM matrix
+   // POST: returns the string s mutated according to the PAM matrix
+   // DESCRIPTION:  This function takes in a string and a mutation matrix
+   //               and mutates each position in the string independently
+   //               returning the mutated string
+   //**************************************************************************
+
+   int len = s.length();
+   string newStr;
+   for(int i = 0; i < len; i++) {
+      char ch = s.at(i);
+      char newCh = p.substitute(ch);  // substitute according to the PAM
+      newStr += newCh;                // append character onto the end
+   }
+   return(newStr);
+}
+//==========================================================================
+
+//==========================================================================
+string mutate(string s, double pctConserved)
+{
+   //**************************************************************************
+   // PRE:  NONE
+   // POST: NONE
+   // DESCRIPTION: Mutates a DNA string according to the percent conservation
+   //**************************************************************************
+
+   string retVal;
+   retVal = s;
+   int len = (int)s.length();
+
+   for(int i = 0; i < len; i++)
+   {
+      int randVal = lrand48() % 101;
+      if(randVal > pctConserved)
+      {
+         string oldCh = retVal.substr(i, 1);
+         string newCh = oldCh;
+         while(oldCh == newCh)
+         {
+            int randVal2 = lrand48() % 101;
+            if(randVal2 < 25)      newCh = "A";
+            else if(randVal2 < 50) newCh = "C";
+            else if(randVal2 < 75) newCh = "G";
+            else                   newCh = "T";
+         }
+         retVal.replace(i, 1, newCh);
+      }
+   }
+   return(retVal);
+}
+//==========================================================================
+    
+
+//==========================================================================
+// -----------------   END OF  SubstitutionMatricies.cpp -------------------
+//==========================================================================
+
+
+
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/SubstitutionMatrices.H ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/SubstitutionMatrices.H
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/SubstitutionMatrices.H	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/rMotifGen_v2.0/SubstitutionMatrices.H	2007-02-28 22:57:05.000000000 +0100
@@ -0,0 +1,71 @@
+
+//==========================================================================
+// -----------------   BEGIN OF  SubstitutionMatricies.H -------------------
+//==========================================================================
+
+//==========================================================================
+// rMotifGen
+// Eric C. Rouchka
+// C. Timothy Hardin
+// (c) 2004-2007, University of Louisville
+//
+// FILE: SubstitutionMatrices.H
+//
+//
+//    This file is part of rMotifGen.
+//
+//    rMotifGen is free software; you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation; either version 2 of the License, or
+//    (at your option) any later version.
+//
+//    rMotifGen is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    You should have received a copy of the GNU General Public License
+//    along with rMotifGen; if not, write to the Free Software
+//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+//
+//==========================================================================
+
+//==========================================================================
+#ifndef MY_PAM_H
+#define MY_PAM_H
+
+#include <iostream>
+#include <iomanip>
+#include <fstream>
+#include <string>
+#include <time.h>
+using namespace std;
+
+class PAM {
+   public:
+      PAM();
+      PAM(int val);
+      int findAAIndex(char ch); 
+      void setInitialMatrix();     // Initializes the PAM1 matrix
+      void printMatrix();
+      void normalizeMatrix();
+      char substitute(char c);     // subsitutes a single character using PAM probabilities
+      long double rowSum(int r);   // Finds the sum of the row probabilities
+      long double colSum(int c);   // Finds the sum of the column probabilities
+
+   private:
+      long double matrix[20][20];  // PAM Matrix (in terms of probabilities)
+      char labels[20];             // Amino Acid Labels for row/column header
+};
+
+string mutate(string s, PAM p);
+string mutate(string s, double pctConserved);
+
+#endif
+
+//==========================================================================
+// -------------------   END OF  SubstitutionMatricies.H -------------------
+//==========================================================================
+
+
+
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/SeqLogo.r ./sandbox/meyerclp/apps/dreme/SeqLogo.r
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/SeqLogo.r	1970-01-01 01:00:00.000000000 +0100
+++ ./sandbox/meyerclp/apps/dreme/SeqLogo.r	2012-08-21 22:42:36.517507000 +0200
@@ -0,0 +1,19 @@
+library(seqLogo)
+list <- list.files("C:/Users/David/Desktop/")
+counter = 0
+for(i in 1:length(list)){
+	x<-regexpr("PWM..txt",list[i])
+	if(x[1]>=0){
+			counter = counter +1
+			y<-paste("C:/Users/David/Desktop/",list[i], sep = "")
+			m<-read.table(y)
+			pwm <- makePWM(m)
+			seqLogo(pwm, ic.scale=FALSE)
+			
+			out<- paste("C:/Users/David/Desktop/PWM",counter,sep = "")
+			out<- paste(out,".jpg",sep = "")
+			
+			savePlot(filename=out, type="jpeg")
+
+		}
+}

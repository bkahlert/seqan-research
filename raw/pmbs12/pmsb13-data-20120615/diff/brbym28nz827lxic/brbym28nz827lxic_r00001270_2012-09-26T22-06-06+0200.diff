diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/dreme.h ./sandbox/meyerclp/apps/dreme/dreme.h
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/dreme.h	2012-09-22 18:05:15.179215300 +0200
+++ ./sandbox/meyerclp/apps/dreme/dreme.h	2012-09-26 22:05:28.945400000 +0200
@@ -26,51 +26,48 @@
 
 struct Seq
 {
+	
+	unsigned c; 
+	unsigned seed;
+	unsigned SeqsNumber;
+	double pValue;
+
+	StringSet<String<Dna5> > seqs;
 	StringSet<CharString> ids;
-	unsigned c; // Anzahl der Motive, provisorisch
-	StringSet<String<Dna5> > seqs;//
+	String<String<Iupac> > allMotifs;
+	String<unsigned> results;
+	String< std::map<unsigned int,std::map<Iupac,double> > > allPWMs;
+	typedef IntervalAndCargo<unsigned, unsigned> TInterval;
+	String<String<TInterval> > intervals;//String<TInterval> enthält alle Intervalle einer Sequenz. String<String<..>> enthält alle Sequenzen	
+	String<IntervalTree<unsigned> > intervalTrees; // Tree für schnellere Suche erstellen --> String von Trees, da mehrere Sequenzen
+	/**
+		In BuildFrequencyMatrix werden die gefundenen Intervalle des Top-Motivs an Intervalls gehängt
+		Am Ende der while wird dann ein IntervallTree für jede Sequenz erzeugt, sodass im nächsten Schritt direkt geschaut werden kann ob ein Motiv mit einem schon 
+		gefundenen überlappt
+	**/
+	
 	Index< StringSet<String<Dna5> > > SArray;
-	unsigned seed;
-	unsigned int SeqsNumber;
 	
 	std::map<String<Dna5>,unsigned int > seqCounter;//maps the Sequence-Kmere to a Counter for the Sequence
 	std::map<String<Iupac>,unsigned int> generalizedKmer;
-
 	std::map<String<Iupac>,double > SortedPValueReversed;
-	
 	std::multimap<double,String<Dna5> > SortedPValue;
 	std::multimap<double,String<Iupac> > generalizedSortedPValue;
 	std::map<unsigned int,std::map<Iupac,double> > freqMatrix;
-	String< std::map<unsigned int,std::map<Iupac,double> > > allPWMs;
 	std::map<unsigned int,std::map<Iupac,double> > weightMatrix;
 	std::map<unsigned int, double > seqLogoMatrix;
 	std::map<unsigned int, double > columnEntropy;
-	String<String<Iupac> > allMotifs;
-	
 	std::map<unsigned int,std::map<Iupac,double> > InformationContentMatrix;
 	FrequencyDistribution<Dna5> frequencies;
 
-	/**
-		In BuildFrequencyMatrix werden die gefundenen Intervalle des Top-Motivs an Intervalls gehängt
-		Am Ende der while wird dann ein IntervallTree für jede Sequenz erzeugt, sodass im nächsten Schritt direkt geschaut werden kann ob ein Motiv mit einem schon 
-		gefundenen überlappt
-	**/
-	typedef IntervalAndCargo<unsigned, unsigned> TInterval;
-	String<String<TInterval> > intervals;//String<TInterval> enthält alle Intervalle einer Sequenz. String<String<..>> enthält alle Sequenzen
 	
-	String<IntervalTree<unsigned> > intervalTrees; // Tree für schnellere Suche erstellen --> String von Trees, da mehrere Sequenzen
-	String<unsigned> results;
-	double pValue;
+	
+	
 };
 
 struct IupacMaps
 {
-	/*Map<Pair<unsigned int,char> > IupacMap;
-	Map<Pair<char,unsigned int> > IupacMapReversed;
-	Map<Pair<char,String<Iupac> > > IupacMapReplace;
-	Map<Pair<char,String<Dna5> > > IupacMapReplaceReversed;
-	Map<Pair<String<Dna5>, char > > IupacMapInversed;
-*/
+
 	std::map<unsigned int,char> IupacMap;
 	std::map<char,unsigned int> IupacMapReversed;
 	std::map<char,String<Iupac> > IupacMapReplace; //stores the replacement-chars
@@ -177,8 +174,7 @@
 void readFastA(	struct Seq &seq, 
 				CharString fname){
 
-	//########### einlesen in ids und seqs
-	//Variable um Sequenz und ID zu speichern
+	
 	std::fstream fasta(toCString(fname), std:: ios_base::in | std::ios_base::binary);
 	if(!fasta.good()){
 		std::cerr << "Could not open file: \"" << fname << "\"" << std::endl;
@@ -239,7 +235,7 @@
 
 void PrintST(Seq &seq){
 
-	typedef Index<StringSet<String<Dna5> > > TMyIndex;//Dna5Q
+	typedef Index<StringSet<String<Dna5> > > TMyIndex;
 	Iterator<TMyIndex, BottomUp<> >::Type myIterator(seq.SArray);
 	for(;!atEnd(myIterator);++myIterator){
 		std::cout<<representative(myIterator)<<std::endl;
@@ -262,48 +258,38 @@
 }
 
 
-//iniate Search in Fore- and Background
+//Initiiert Suche im Vorder- und Hintergrund
 void initExactKmer( Seq &seq,
 					Seq &back,
 					unsigned int kmer_len,
 					unsigned int kmer_len_end){
 
 	Finder<Index<StringSet<String<Dna5> > > > finder(seq.SArray);
-	Finder<Index<StringSet<String<Dna5> > > > finderB(back.SArray);//finder background
+	Finder<Index<StringSet<String<Dna5> > > > finderB(back.SArray);
 	typedef Index< StringSet<String<Dna5> > > TMyIndex;
-	//kmer_len= 3;//minimal kmer-length
-	//kmer_len_end=8;//maximal length
+	
 	if(kmer_len<1) kmer_len=3;
 	if(kmer_len_end<kmer_len) kmer_len_end=kmer_len+1;
-	//std::cout<<"kmer: "<<kmer_len<<std::endl;
-	//std::cout<<"end: "<<kmer_len_end<<std::endl;
-
+	
 	typedef Iterator<StringSet<String<Dna5> > >::Type TStringSetIterator;
 	unsigned int slen=0;
-	String<Dna5> Kmer;//current Kmer
+	String<Dna5> Kmer;
 	
 
-	std::cout<<std::endl<<std::endl;
-	for(;kmer_len<=kmer_len_end;++kmer_len){//loop over all possible Kmer-length -->3-8
+	
+	for(;kmer_len<=kmer_len_end;++kmer_len){//loop over all possible Kmer-length 
 		for(TStringSetIterator it=begin(seq.seqs);it!=end(seq.seqs);++it){//loop over all sequences
 			slen=length(value(it));//length of the current seq
 			if(slen==0) continue;
 			else if(slen<kmer_len) continue;
-			//std::cout<<"Sequence: "<<value(it)<<std::endl;
+		
 		
 		
 			for(unsigned int i=0;i<slen-kmer_len+1;++i){//loop over all Kmere in the current sequence
 			
-				Kmer=infix(value(it),i,i+kmer_len);//optimieren
-				//std::cout<<Kmer<<" ";
-				//if(Kmer[kmer_len-1]=='N'){//'AAAN'AAAA ---> AAA'NAAA'A --> after continue AAAN'AAAA'
-				//	i+=kmer_len;
-				//	continue;
-				//}
-				
+				Kmer=infix(value(it),i,i+kmer_len);
+			
 				if(seq.seqCounter.find(Kmer)!=seq.seqCounter.end()) continue;// if Kmer is in the Map -->nothing to do
-	//			//Pattern<String<Dna5> > pattern(Kmer);
-			//	std::cout<<"count";
 				CountKmer(back,finderB,Kmer);
 				CountKmer(seq,finder,Kmer);
 				
@@ -313,7 +299,7 @@
 	}
 
 		
-	//}
+	
 }
 
 //gets the current Kmer and searches it in the index
@@ -323,15 +309,15 @@
 				String<Dna5> &Kmer){
 	
 			std::vector<int> CounterV(seq.SeqsNumber+1,0);//counter for storing 1 or 0 for each Seq + the cumulated sum of the counter in the last field
-			//std::cout<<"vor while  ";
+			
 			clear(finder);
 			while(find(finder,Kmer)){//search the current Kmer in all sequences
-				//std::cout<<'[' <<beginPosition(finder)<<','<<endPosition(finder)<<")\t"<<infix(finder)<<std::endl;//Debug
+				
 			
-				if(seq.c>1){//nur im foreground
+				if(seq.c>1){//check only in foreground
 					clear(seq.results);
 					findIntervals(seq.intervalTrees[beginPosition(finder).i1], beginPosition(finder).i2, endPosition(finder).i2, seq.results);
-				}// wenn results>0, dann überlappt das Kmer --> nicht aufzählen
+				}// if results>0 --> do not count:Kmer is overlapping
 				if(CounterV[beginPosition(finder).i1] == 0 && length(seq.results)==0){//count number of sequences containing the motif, not the occurrences to avoid problems with self-overlapping
 					++CounterV[beginPosition(finder).i1];
 					++CounterV[seq.SeqsNumber];//last Position in CounterV is cumulated sum

diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/dreme.h ./sandbox/meyerclp/apps/dreme/dreme.h
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/dreme.h	2012-07-25 12:23:06.581807300 +0200
+++ ./sandbox/meyerclp/apps/dreme/dreme.h	2012-07-25 12:24:57.848807300 +0200
@@ -735,66 +735,66 @@
 
 }
 
-//void ComparePWM(Seq &seq,std::map<unsigned int,std::map<Iupac,double> > &freqMatrix1,std::map<unsigned int,std::map<Iupac,double> > &freqMatrix2, Entropy const & tag){
-//
-//	/***
-//	Matrizen müssen nicht gleich lang sein --> vorher mit fester Größe noch einmal die kMere scannen?
-//											   Matrizen alignen?
-//											   Im Fall der Ungleichheit --> Alle möglichen Alignments(treshold) beachten, Minimum nehmen
-//	***/
-//	
-//	/****
-//			Für jede Spalte=Position einen Eintrag für je zwei zu vergleichende PWMs
-//			Eintrag ist = 0, wenn die Werte identisch sind. Je größer die Zahl, desto unterschiedlicher die Werte
-//			Was wenn Wert = Hintergrundverteilung? --> Eintrag wäre = 0, obwohl das nichts mit dem Motiv zu tun hat
-//
-//			Für jede Spalte berechnen und durch Spaltenanzahl teilen
-//	****/
-//	seq.columnEntropy[0]=0;
-//	
-//	for(unsigned int j=1;j<length(freqMatrix1)+1;++j){
-//		seq.columnEntropy[j]  = freqMatrix1[j-1]['A']*log(freqMatrix1[j-1]['A']/freqMatrix2[j-1]['A']);
-//		seq.columnEntropy[j] += freqMatrix1[j-1]['C']*log(freqMatrix1[j-1]['C']/freqMatrix2[j-1]['C']);
-//		seq.columnEntropy[j] += freqMatrix1[j-1]['G']*log(freqMatrix1[j-1]['G']/freqMatrix2[j-1]['G']);
-//		seq.columnEntropy[j] += freqMatrix1[j-1]['T']*log(freqMatrix1[j-1]['T']/freqMatrix2[j-1]['T']);
-//		seq.columnEntropy[j] += freqMatrix2[j-1]['A']*log(freqMatrix2[j-1]['A']/freqMatrix1[j-1]['A']);
-//		seq.columnEntropy[j] += freqMatrix2[j-1]['C']*log(freqMatrix2[j-1]['C']/freqMatrix1[j-1]['C']);
-//		seq.columnEntropy[j] += freqMatrix2[j-1]['G']*log(freqMatrix2[j-1]['G']/freqMatrix1[j-1]['G']);
-//		seq.columnEntropy[j] += freqMatrix2[j-1]['T']*log(freqMatrix2[j-1]['T']/freqMatrix1[j-1]['T']);
-//		seq.columnEntropy[j]  = seq.columnEntropy[j]/2;
-//		seq.columnEntropy[0] += seq.columnEntropy[j]; 
-//
-//	}
-//	seq.columnEntropy[0]=seq.columnEntropy[0]/length(freqMatrix1);
-//
-//}
-//
-//void ComparePWM(Seq &seq,std::map<unsigned int,std::map<Iupac,double> > &freqMatrix1,std::map<unsigned int,std::map<Iupac,double> > &freqMatrix2, Euklidisch const & tag){
-//
-//	seq.columnEntropy[0]=0;
-//	for(unsigned int j=1;j<length(freqMatrix1)+1;++j){
-//
-//		seq.columnEntropy[j]  = (freqMatrix1[j-1]['A'] - freqMatrix2[j-1]['A'])*(freqMatrix1[j-1]['A'] - freqMatrix2[j-1]['A']);
-//		seq.columnEntropy[j] += (freqMatrix1[j-1]['C'] - freqMatrix2[j-1]['C'])*(freqMatrix1[j-1]['C'] - freqMatrix2[j-1]['C']);
-//		seq.columnEntropy[j] += (freqMatrix1[j-1]['G'] - freqMatrix2[j-1]['G'])*(freqMatrix1[j-1]['G'] - freqMatrix2[j-1]['G']);
-//		seq.columnEntropy[j] += (freqMatrix1[j-1]['T'] - freqMatrix2[j-1]['T'])*(freqMatrix1[j-1]['T'] - freqMatrix2[j-1]['T']);
-//		seq.columnEntropy[j]  = sqrt(seq.columnEntropy[j]);
-//		seq.columnEntropy[0] += seq.columnEntropy[j];
-//	}
-//	seq.columnEntropy[0]=seq.columnEntropy[0]/length(freqMatrix1);//enthält durchschnitt der spalten
-//
-//}
+void ComparePWM(Seq &seq,std::map<unsigned int,std::map<Iupac,double> > &freqMatrix1,std::map<unsigned int,std::map<Iupac,double> > &freqMatrix2, Entropy const & tag){
+
+	/***
+	Matrizen müssen nicht gleich lang sein --> vorher mit fester Größe noch einmal die kMere scannen?
+											   Matrizen alignen?
+											   Im Fall der Ungleichheit --> Alle möglichen Alignments(treshold) beachten, Minimum nehmen
+	***/
+	
+	/****
+			Für jede Spalte=Position einen Eintrag für je zwei zu vergleichende PWMs
+			Eintrag ist = 0, wenn die Werte identisch sind. Je größer die Zahl, desto unterschiedlicher die Werte
+			Was wenn Wert = Hintergrundverteilung? --> Eintrag wäre = 0, obwohl das nichts mit dem Motiv zu tun hat
+
+			Für jede Spalte berechnen und durch Spaltenanzahl teilen
+	****/
+	seq.columnEntropy[0]=0;
+	
+	for(unsigned int j=1;j<length(freqMatrix1)+1;++j){
+		seq.columnEntropy[j]  = freqMatrix1[j-1]['A']*log(freqMatrix1[j-1]['A']/freqMatrix2[j-1]['A']);
+		seq.columnEntropy[j] += freqMatrix1[j-1]['C']*log(freqMatrix1[j-1]['C']/freqMatrix2[j-1]['C']);
+		seq.columnEntropy[j] += freqMatrix1[j-1]['G']*log(freqMatrix1[j-1]['G']/freqMatrix2[j-1]['G']);
+		seq.columnEntropy[j] += freqMatrix1[j-1]['T']*log(freqMatrix1[j-1]['T']/freqMatrix2[j-1]['T']);
+		seq.columnEntropy[j] += freqMatrix2[j-1]['A']*log(freqMatrix2[j-1]['A']/freqMatrix1[j-1]['A']);
+		seq.columnEntropy[j] += freqMatrix2[j-1]['C']*log(freqMatrix2[j-1]['C']/freqMatrix1[j-1]['C']);
+		seq.columnEntropy[j] += freqMatrix2[j-1]['G']*log(freqMatrix2[j-1]['G']/freqMatrix1[j-1]['G']);
+		seq.columnEntropy[j] += freqMatrix2[j-1]['T']*log(freqMatrix2[j-1]['T']/freqMatrix1[j-1]['T']);
+		seq.columnEntropy[j]  = seq.columnEntropy[j]/2;
+		seq.columnEntropy[0] += seq.columnEntropy[j]; 
+
+	}
+	seq.columnEntropy[0]=seq.columnEntropy[0]/length(freqMatrix1);
+
+}
+
+void ComparePWM(Seq &seq,std::map<unsigned int,std::map<Iupac,double> > &freqMatrix1,std::map<unsigned int,std::map<Iupac,double> > &freqMatrix2, Euklidisch const & tag){
+
+	seq.columnEntropy[0]=0;
+	for(unsigned int j=1;j<length(freqMatrix1)+1;++j){
+
+		seq.columnEntropy[j]  = (freqMatrix1[j-1]['A'] - freqMatrix2[j-1]['A'])*(freqMatrix1[j-1]['A'] - freqMatrix2[j-1]['A']);
+		seq.columnEntropy[j] += (freqMatrix1[j-1]['C'] - freqMatrix2[j-1]['C'])*(freqMatrix1[j-1]['C'] - freqMatrix2[j-1]['C']);
+		seq.columnEntropy[j] += (freqMatrix1[j-1]['G'] - freqMatrix2[j-1]['G'])*(freqMatrix1[j-1]['G'] - freqMatrix2[j-1]['G']);
+		seq.columnEntropy[j] += (freqMatrix1[j-1]['T'] - freqMatrix2[j-1]['T'])*(freqMatrix1[j-1]['T'] - freqMatrix2[j-1]['T']);
+		seq.columnEntropy[j]  = sqrt(seq.columnEntropy[j]);
+		seq.columnEntropy[0] += seq.columnEntropy[j];
+	}
+	seq.columnEntropy[0]=seq.columnEntropy[0]/length(freqMatrix1);//enthält durchschnitt der spalten
+
+}
 /****
 		Speichert die jeweiligen Mittelwerte der 2 übergebenen Matrizen 
 ****/
 void BuildMeanOf2PWMs(Seq &seq,std::map<unsigned int,std::map<Iupac,double> > &freqMatrix1,std::map<unsigned int,std::map<Iupac,double> > &freqMatrix2){
 
-	/*for(unsigned int j=0;j<length(freqMatrix1);++j){
+	for(unsigned int j=0;j<length(freqMatrix1);++j){
 		freqMatrix1[j]['A'] = (freqMatrix1[j]['A']+freqMatrix2[j]['A']);
 		freqMatrix1[j]['C'] = (freqMatrix1[j]['C']+freqMatrix2[j]['C']);
 		freqMatrix1[j]['G'] = (freqMatrix1[j]['G']+freqMatrix2[j]['G']);
 		freqMatrix1[j]['T'] = (freqMatrix1[j]['T']+freqMatrix2[j]['T']);
-	}*/
+	}
 
 
 }
@@ -808,7 +808,7 @@
 	String<String<double > > compare;
 	String<double> compareTemp;
 
-	/*for(unsigned int i=0;i<allPWMsLength-1;++i){
+	for(unsigned int i=0;i<allPWMsLength-1;++i){
 
 		for(unsigned int j=i+1;j<allPWMsLength;++j){
 
@@ -828,7 +828,7 @@
 	}
 	std::cout<<length(compare)<<" "<<length(compare[0])<<" "<<length(compare[1])<<std::endl;
 	std::cout<<compare[0][0]<<" "<<compare[0][1]<<" "<<compare[1][0];
-*/
+
 	
 
 	while(minDifference[0]<1){

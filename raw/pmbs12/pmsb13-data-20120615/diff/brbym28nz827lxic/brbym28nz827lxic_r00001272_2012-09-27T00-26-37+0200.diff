diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata/brbym28nz827lxic_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x C:/Users/David/Desktop/Seqan/Seqan/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/dreme.h ./sandbox/meyerclp/apps/dreme/dreme.h
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/meyerclp/apps/dreme/dreme.h	2012-09-26 22:49:32.825000000 +0200
+++ ./sandbox/meyerclp/apps/dreme/dreme.h	2012-09-27 00:26:22.352600000 +0200
@@ -729,9 +729,11 @@
 
 
 
-void saveData(Seq &seq,std::ofstream &PWM,unsigned c){
+void saveData(	Seq &seq,
+				std::ofstream &PWM,
+				unsigned c){
 
-	std::cout<<"saveData"<<std::endl;
+	
 
 	String<char> pwm;
 	char *buffer= new char[33];
@@ -819,7 +821,9 @@
 
 }
 
-double ComparePWM(std::map<Iupac,double>  &freqMatrix1,std::map<Iupac,double>  &freqMatrix2, Entropy const & tag){
+double ComparePWM(	std::map<Iupac,double>  &freqMatrix1,
+					std::map<Iupac,double>  &freqMatrix2, 
+					Entropy const & tag){
 
 
 	
@@ -828,7 +832,7 @@
 			Eintrag ist = 0, wenn die Werte identisch sind. Je größer die Zahl, desto unterschiedlicher die Werte
 			Was wenn Wert = Hintergrundverteilung? --> Eintrag wäre = 0, obwohl das nichts mit dem Motiv zu tun hat
 
-			Für jede Spalte berechnen und durch Spaltenanzahl teilen --> im Nachhinein
+			Für jede Spalte berechnen und im Nachhinein durch Spaltenanzahl teilen 
 	****/
 	double columnEntropy=0;
 	
@@ -847,12 +851,14 @@
 	return columnEntropy;
 
 }
-
-double ComparePWM(std::map<Iupac,double>  &freqMatrix1,std::map<Iupac,double>  &freqMatrix2, Euclid const & tag){
-	/***
+/****
 			Computes the euclidean distance
 		
-	***/
+****/
+double ComparePWM(	std::map<Iupac,double>  &freqMatrix1,
+					std::map<Iupac,double>  &freqMatrix2, 
+					Euclid const & tag){
+	
 
 	double columnEntropy = 0;
 
@@ -866,8 +872,12 @@
 	return columnEntropy;
 
 }
-
-double ComparePWM(std::map<Iupac,double>  &freqMatrix1,std::map<Iupac,double>  &freqMatrix2, Pearson const & tag){
+/****
+		computes the Pearson correlation coefficient
+****/
+double ComparePWM(	std::map<Iupac,double>  &freqMatrix1,
+					std::map<Iupac,double>  &freqMatrix2, 
+					Pearson const & tag){
 
 	double columnEntropy = 0;
 	double columnEntropyDivisorA = 0;
@@ -904,9 +914,11 @@
 }
 
 /****
-		Speichert die jeweiligen Mittelwerte der 2 übergebenen Matrizen 
+		Computes the mean of the two matrices 
 ****/
-void BuildMeanOf2PWMs(Seq &seq,std::map<unsigned int,std::map<Iupac,double> > &freqMatrix1,std::map<unsigned int,std::map<Iupac,double> > &freqMatrix2){
+void BuildMeanOf2PWMs(	Seq &seq,
+						std::map<unsigned int,std::map<Iupac,double> > &freqMatrix1,
+						std::map<unsigned int,std::map<Iupac,double> > &freqMatrix2){
 
 	for(unsigned int j=0;j<length(freqMatrix1);++j){
 		freqMatrix1[j]['A'] = (freqMatrix1[j]['A']+freqMatrix2[j]['A'])/2;
@@ -917,14 +929,19 @@
 	
 
 }
-
-void UpdateDistantMatrix(int n, int x, int y, std::vector<std::vector<String<double> > > &compare, CompleteLinkage const & tag ){
-
-	/****
+/****
 			Updates the distance with Complete Linkage
 			Replaces PWM x with the new one
 			
-	****/
+****/
+
+void UpdateDistantMatrix(	int n,
+							int x, 
+							int y, 
+							std::vector<std::vector<String<double> > > &compare, 
+							CompleteLinkage const & tag ){
+
+	
 	unsigned j;
 	for (j = 0; j < x; j++)
 		compare[x][j][0] = std::max(compare[y][j][0],compare[x][j][0]);
@@ -941,9 +958,16 @@
 }
 
 
+/****
+		Updates the distance with Average Linkage
+****/
 
-
-void UpdateDistantMatrix(int n, int x, int y, std::vector<std::vector<String<double> > > &compare,std::vector<unsigned> &weights, AverageLinkage const & tag ){
+void UpdateDistantMatrix(	int n, 
+							int x, 
+							int y,
+							std::vector<std::vector<String<double> > > &compare,
+							std::vector<unsigned> &weights, 
+							AverageLinkage const & tag ){
 
 
 	/***
@@ -967,8 +991,12 @@
 
 }
 
-
-void minDifferenceInMatrix(unsigned n,String<double> &minDifference,std::vector<std::vector<String<double> > > compare){
+/****
+		computes the minimum within the matrix 'compare'
+****/
+void minDifferenceInMatrix(	unsigned n,
+							String<double> &minDifference,
+							std::vector<std::vector<String<double> > > compare){
 
 	minDifference[0]=0;
 	for(unsigned i=0;i<n-1;++i){
@@ -977,20 +1005,23 @@
 			
 			if(minDifference[0]==0 || minDifference[0]>compare[j][i][0]){
 				minDifference[0]=compare[j][i][0];
-				minDifference[1]=i;
-				minDifference[2]=j;
-				//std::cout<<i<<" "<<j<<" "<<compare[j][i][0];
+				minDifference[1]=i;//PWM i
+				minDifference[2]=j;//PWM j --> PWM i and j = PWMs of the smallest value in the matrix
+				
 			}
 
 		}
 
 	}
 
-	//std::cout<<std::endl<<minDifference[0]<<" "<<minDifference[1]<<" "<<minDifference[2]<<std::endl<<std::endl;
 }
 
-
-void computesDistantMatrix(String< std::map<unsigned int,std::map<Iupac,double> > > &allPWMs,std::vector<std::vector<String<double> > > &compare, unsigned allPWMsLength){
+/****
+		computes the distant matrix with the alignment of the PWMs --> for overlapping PWMs
+****/
+void computesDistantMatrix(	String< std::map<unsigned int,std::map<Iupac,double> > > &allPWMs,
+							std::vector<std::vector<String<double> > > &compare, 
+							unsigned allPWMsLength){
 
 	unsigned j;
 	unsigned i;
@@ -1009,62 +1040,56 @@
 	}
 
 }
+/****
+		Dr= the sum of all distances for all points in cluster r
+****/
 
-double computeDr(Cluster &cluster,std::vector<std::vector<String<double> > > copyCompare){
+double computeDr(	Cluster &cluster,
+					std::vector<std::vector<String<double> > > copyCompare){
 
 	double Dr=0;
 	
 	for(unsigned i=0;i<length(cluster.content);++i){
-		
 		for(unsigned j=0;j<length(cluster.content);++j){
-			
-			
 			if(cluster.content[i]<cluster.content[j]){
 				
-
-				Dr+= copyCompare[cluster.content[j]][cluster.content[i]][0];//copyCompare[i][j] --> i>j, daher falls i<j umdrehen
+				Dr+= copyCompare[cluster.content[j]][cluster.content[i]][0];//copyCompare[i][j] --> i>j, therefore reverse if i<j 
 				
 			}
 			else if(cluster.content[j]<cluster.content[i]){
 				
-			
 				Dr+= copyCompare[cluster.content[i]][cluster.content[j]][0];
 				
 			}
 		}
 	}
 	
-
-
 	return Dr/2;
 }
+/****
+		Wk = the pooled within-cluster sum of squares around the cluster means
+****/
 
-double computeWk(int n,String<Cluster> &cluster){// n=allPWMsLength-n
+double computeWk(	int n,
+					String<Cluster> &cluster){// n=allPWMsLength-n
 
 	/***
-
 		Wenn ein neues Cluster hinzukommt einfach addieren/n
-		Wenn ein bestehendes verändert wird, den wert austauschen
-		--> anhand von left/right machbar --> falls dort negative zahlen, dann verändert 
-			falls nicht addieren 
-			falls negativ --> -negativ -1 bestimmt cluster-nummer, dort Dr wert
-
-
+		Wenn ein bestehendes verändert wird, den Wert austauschen
 	***/
 
 
 	if(n>0){
 		cluster[n].Wk=cluster[n-1].Wk;
-		//std::cout<<"Wk "<<cluster[n].Wk<<" "<<n<<" "<<cluster[n].left<<" "<<cluster[n].right<<" "<<cluster[n].Dr<<std::endl;
 	}
 	else
 		cluster[n].Wk=0;
 
-	if(cluster[n].left>=0 && cluster[n].right>=0) //überflüssig wenn mit else anfangen
-		cluster[n].Wk +=cluster[n].Dr/length(cluster[n].content);//braucht nicht durch 2 dividieren, da in content nur die eine hälfte aufaddiert wurde
+	if(cluster[n].left>=0 && cluster[n].right>=0) 
+		cluster[n].Wk +=cluster[n].Dr/length(cluster[n].content);//no need to divide by 2 --> content contains only the half
 	else{
 		if(cluster[n].left<0)
-			cluster[n].Wk=cluster[n].Wk - cluster[-cluster[n].left-1].Dr/length(cluster[-cluster[n].left-1].content);//das Wk des vorherigen clusters abziehen --> 12 wird mit 3 zu 123 geklustert-->wäre 123.Dr/1 --> 12 wird von 12 und 3 abgezogen und 123 am ende der else addiert
+			cluster[n].Wk=cluster[n].Wk - cluster[-cluster[n].left-1].Dr/length(cluster[-cluster[n].left-1].content);
 		if(cluster[n].right<0)
 			cluster[n].Wk=cluster[n].Wk - cluster[-cluster[n].right-1].Dr/length(cluster[-cluster[n].right-1].content);	
 
@@ -1087,8 +1112,8 @@
 						  unsigned PWMLength ){
 
 	/***
-			Für jede Spalte eines PWMs Normalverteilte Zufallszahlen
-			So viele PWMs wie auch gemessen
+			Berechnet für jede Spalte eines PWMs gleichverteilte Zufallszahlen
+			Erzeugt so viele PWMs wie auch gemessen wurden
 
 			Spalten:
 			Zufällig zwischen ACGT auswählen --> x von 0 bis 0.99
@@ -1112,7 +1137,6 @@
 	
 
 	for(unsigned i=0;i<allPWMsLength;++i){//genauso viele Reference-Daten erstellen, wie PWMs vorhanden
-		//std::cout<<"i "<<i<<std::endl;
 		for(unsigned j=0;j<PWMLength;++j){
 			ACGT="ACGT";
 			uniDouble=0;
@@ -1124,17 +1148,10 @@
 				pos=pickRandomNumber(rng, uniformInt);
 				ReferenzFreq[j][ACGT[pos]]=pickRandomNumber(rng, uniformDouble);
 				uniDouble+=ReferenzFreq[j][ACGT[pos]];
-				//std::cout<<"Pos: "<<ACGT[pos]<<" "<<uniDouble<<" "<<ReferenzFreq[j][ACGT[pos]]<<std::endl;
 				erase(ACGT,pos);
 			}
 			ReferenzFreq[j][ACGT[0]]=1-uniDouble;
-			//std::cout<<"Pos: "<<ACGT[0]<<" "<<uniDouble<<" "<<ReferenzFreq[j][ACGT[0]]<<std::endl;
 			clear(ACGT);
-			//std::cout<<std::endl;
-	//		ReferenzFreq[j]["zufallACGT"]="zufallvon 0 bis 0.99";
-	//		ReferenzFreq[j]["zufallACG"]="zufallvon 0 bis 1-[zufallACGT]";
-	//		ReferenzFreq[j]["zufallAC"]="zufallvon 0 bis 1-[zufallACGT]-[zufallACG]";
-	//		ReferenzFreq[j]["A"]="zufallvon 0 bis 1-[zufallACGT]-[zufallACG]-[zufallAC]";
 
 		} 
 		
@@ -1146,7 +1163,9 @@
 
 
 }
-
+/****
+		l_quer= the mean of the sum of all Wks from the random reference data
+****/
 void compute_l_quer(String<Cluster> &cluster, 
 					String<double> &l_quer_for_k,
 					String<String<double> > &allWk,
@@ -1156,24 +1175,21 @@
 
 		unsigned k=0;
 		
-		for(unsigned j=0;j<allPWMsLength-1;++j){//addiert die log(Wk's) aller B-Referenz-Daten auf --> nur die Summe wird benötigt
+		for(unsigned j=0;j<allPWMsLength-1;++j){//adds the log(Wk's) from all B-Reference-Data -->only the sum is required
 			/*****
-					j != anzahl der cluster -->allPWMsLength - (j+1) ist Anzahl der Cluster
-					Bei 4 Objekten entspricht k=0 dem Fall, dass 2 zusammengeclustert wurden und der Rest allein ist
-					k=allPWMsLength-2 entspricht einem großem Cluster
+					j != number of cluster -->allPWMsLength - (j+1) =number of Cluster
+					
 			*****/
 			k=allPWMsLength-(j+1);
 			appendValue(allWk[i],cluster[j].Wk);
 			
 			l_quer_for_k[0]+=log(cluster[j].Wk)/B;
-			//std::cout<<l_quer_for_k[0]<<std::endl;
 
 			if(i==0){
 				l_quer_for_k[k]=log(cluster[j].Wk)/B;
 			}
 			else{
 				l_quer_for_k[k]+=log(cluster[j].Wk)/B;
-				//std::cout<<"else "<<k<<" "<<l_quer_for_k[k]<<" "<<log(cluster[j].Wk)<<std::endl<<std::endl;
 			}
 		}
 
@@ -1190,20 +1206,21 @@
 	unsigned k=0;
 	for(unsigned j=0;j<allPWMsLength-1;++j){
 		k=allPWMsLength-(j+1);
-		//std::cout<<l_quer_for_k[k]<<" "<<log(observedCluster[j].Wk)<<" ";
 		Gap[k]=l_quer_for_k[k]-log(observedCluster[j].Wk);
-		//std::cout<<Gap[k]<<std::endl;
 	}
 
 }
 
+/****
+		computes the standard deviation sdk and sk= sdk*sqrt(1 + 1/B)
+****/
 void compute_sdk_and_sk(String<double> &sk,
 						String<double> &l_quer_for_k,
 						String<String<double> > &allWk,
 						unsigned allPWMsLength,
 						int B){
 
-	String<double> sdk;//Standard-Abweichungen
+	String<double> sdk;//standard deviation
 	resize(sdk,allPWMsLength);
 	unsigned k=0;
 	for(unsigned i=0;i<B;++i){
@@ -1221,7 +1238,7 @@
 	
 
 	/*******************
-		sk berechnen
+		compute sk
 	********************/
 
 	double x=1+1/double(B);
@@ -1236,7 +1253,7 @@
 }
 
 unsigned computeGapStat(String< std::map<unsigned int,std::map<Iupac,double> > > &allPWMs,
-					String<Cluster> &observedCluster){
+						String<Cluster> &observedCluster){
 
 	String<Cluster> cluster;
 	String<String<double> > allWk;
@@ -1244,8 +1261,8 @@
 	String<double> l_quer_for_k;
 	String<int> traceback;
 	String<double> sk;
-	int B=5;//B Referenz-Datensätze werden erstellt
-	
+	int B=5;//B reference-data sets 
+
 
 	String< std::map<unsigned int,std::map<Iupac,double> > > Reference;
 	unsigned allPWMsLength=length(allPWMs);
@@ -1259,7 +1276,7 @@
 	l_quer_for_k[0]=0;
 	
 	/************
-		l_quer berechnen
+		compute l_quer 
 	************/
 	for(unsigned i=0;i<B;++i){
 
@@ -1272,24 +1289,24 @@
 	}
 	
 	/******************
-		Gap berechnen
+		compute Gap 
 	******************/
 	computeGap(l_quer_for_k,observedCluster,Gap,allPWMsLength);
 
 
 	/******************
-		sdk && sk berechnen
+		compute sdk && sk 
 	******************/
 
 	compute_sdk_and_sk(sk,l_quer_for_k,allWk,allPWMsLength,B);
 
 	/*******************
-		kleinstes k für die Gap berechnen
+		compute smallest k 
+		--> returns optimal cluster-size
 	********************/
 	unsigned j=0;
 	for(unsigned k=1;k<allPWMsLength-1;++k){
 		j=allPWMsLength-(k+1);
-		//std::cout<<"gap "<<Gap[j]<<" "<<Gap[j+1]<<" "<<sk[j+1]<<std::endl;
 		if(Gap[j]<=Gap[j+1]-sk[j+1]){
 			std::cout<<"j "<<j<<std::endl;
 			std::cout<<j+1<<" Cluster sind das Optimum, also nach dem "<<allPWMsLength - (j + 1)<<" Cluster-Schritt"<<std::endl;
@@ -1312,7 +1329,13 @@
 
 }
 
-void clusterTraceback(String<String<Iupac> > &allMotifs,String<int> &traceback, unsigned j){
+/****
+		The traceback of the clustering
+		--> prints the clustered motifs in the right order
+****/
+void clusterTraceback(	String<String<Iupac> > &allMotifs,
+						String<int> &traceback, 
+						unsigned j){
 
 	Iterator<String<int> >::Type tracebackIt;
 	if(j==0){	
@@ -1330,7 +1353,9 @@
 	}
 	
 }
-
+/****
+		performes the actual clustering with average linkage (currently)
+****/
 void PWMClustering(String< std::map<unsigned int,std::map<Iupac,double> > > &allPWMs,
 				   String<Cluster> &cluster,
 				   String<int> &traceback){
@@ -1349,30 +1374,35 @@
 	unsigned j;
 	for (j = 0; j < allPWMsLength; j++) clusterId[j] = j;//to assign which PWM is in which cluster
 	/***
-			Average Linkage:
+			 required by average linkage:
 	***/
 	std::vector<unsigned> weights(allPWMsLength,1);
 	
 	
 
 
-	//vorher per local alignment feststellen wo die beste Überlappung ist!
+	/****
+			generates the distant matrix 'compare'
+	****/
 	computesDistantMatrix(allPWMs,compare,allPWMsLength);
 
 	std::vector<std::vector<String<double> > > copyCompare(compare);
 	String<int> temp;
 	minDifferenceInMatrix(allPWMsLength,minDifference,compare);
-	for(unsigned n=allPWMsLength;n>1;--n){//treshold noch bestimmen --> && minDifference[0]<2
+	/****
+			computes all possible cluster-sizes
+	****/
+	for(unsigned n=allPWMsLength;n>1;--n){
 		
 		
-		//BuildMeanOf2PWMs(seq,seq.allPWMs[int(minDifference[1])],seq.allPWMs[int(minDifference[2])]);//bildet aus 2PWMs die Mittelwerte und speichert sie in
+		//BuildMeanOf2PWMs(seq,seq.allPWMs[int(minDifference[1])],seq.allPWMs[int(minDifference[2])]);//Computes the mean of the two matrices
 		
 		UpdateDistantMatrix(n,int(minDifference[1]),int(minDifference[2]),compare,weights,AverageLinkage());
 	
 		
 		/****
-				Erzeuge Vector mit allen Objekten des Clusters
-				-> für computeDr
+				generates vector with all objects in the cluster
+				-> needed in computeDr
 		****/
 		if(clusterId[int(minDifference[1])]<0) 
 			append(temp,cluster[-clusterId[int(minDifference[1])] - 1].content,Exact()); 
@@ -1389,14 +1419,14 @@
 		cluster[allPWMsLength-n].content=temp;
 		clear(temp);
 		/****
-					Dr berechnet
+					computes Dr
 		****/
 		cluster[allPWMsLength-n].left=clusterId[int(minDifference[1])];
 		cluster[allPWMsLength-n].right=clusterId[int(minDifference[2])];
 		cluster[allPWMsLength-n].Dr=computeDr(cluster[allPWMsLength-n],copyCompare);
 		
 		/****
-					Wk berechnet
+					computes Wk
 		****/
 		
 		computeWk(allPWMsLength-n,cluster);
@@ -1405,12 +1435,14 @@
 		appendValue(traceback,clusterId[int(minDifference[1])]);
 		appendValue(traceback,clusterId[int(minDifference[2])]);
 		/****
-			Id's neu berechnen
+			change Id's 
 		****/
 		clusterId[int(minDifference[1])]=n-allPWMsLength-1;
 		for(j=0;j+minDifference[2]<allPWMsLength-1;++j)
 			clusterId[int(minDifference[2])+j]=clusterId[int(minDifference[2])+j+1];
-		
+		/****
+				compute new minDifference
+		****/
 		minDifferenceInMatrix(n-1,minDifference,compare);
 	}
 	
@@ -1425,11 +1457,11 @@
 }
 
 
-/*Prints the Mapping:
+/*****Prints the Mapping:
 Kmer	Seq1	Seq2	...	Seqn	CumulatedCounter
 -->Template
 
-*/
+*****/
 void PrintMap(  std::map<String<Dna5>,unsigned int> &Dna5CounterMap,
 				unsigned int SeqsNumber){
 	std::cout<<std::endl;
@@ -1464,7 +1496,7 @@
 
 void PrintMap(std::multimap<double,String<Iupac> > &pValueMap){
 	std::multimap<double,String<Iupac> >::iterator MapIterator;
-	//std::cout<<pValueMap.size()<<std::endl;
+	
 	int i=0;
 	for(MapIterator=pValueMap.begin();MapIterator !=pValueMap.end() && i<10;++MapIterator,++i){
 		std::cout<<(*MapIterator).first<<" ";
@@ -1483,37 +1515,41 @@
 }
 
 
-//Test the Map-lengths match eachother and with the sequences
-void DebugMap(  Seq &seq,
-				Seq &back,
-				std::map<String<Dna5>,std::vector<int> > &sequencesCounter,
-				std::map<String<Dna5>,std::vector<int> > &backgroundCounter){
-
-	typedef std::map<String<Dna5>,std::vector<int> > Dna5CounterMap;
-	Dna5CounterMap::iterator MapIterator;
-	MapIterator=sequencesCounter.begin();
-	Dna5CounterMap::iterator MapIteratorB;
-	MapIteratorB=backgroundCounter.begin();
-
-	
-	SEQAN_ASSERT_EQ(length(sequencesCounter),length(backgroundCounter));
-	SEQAN_ASSERT_EQ(length((*MapIterator).second),(length(seq.ids)+1));//+1, because of the last field in vector 
-	SEQAN_ASSERT_EQ(length((*MapIteratorB).second),(length(back.ids)+1));
-
-	//std::cout<<length(sequencesCounter)<<std::endl;
-	//std::cout<<length((*MapIterator).second)<<std::endl;
-	//std::cout<<length(backgroundCounter)<<std::endl;
-	//std::cout<<length((*MapIteratorB).second)<<std::endl;
-	//std::cout<<length(seq.ids)<<std::endl;
-	//std::cout<<length(back.ids)<<std::endl;
-}
-
-void DebugMultiMap( std::map<String<Dna5>,std::vector<int> > &sequencesCounter,
-					std::multimap<double,String<Dna5> > &SortedPValue){
-	SEQAN_ASSERT_EQ(length(sequencesCounter),SortedPValue.size());
-
-}
+////Test the Map-lengths match eachother and with the sequences
+//void DebugMap(  Seq &seq,
+//				Seq &back,
+//				std::map<String<Dna5>,std::vector<int> > &sequencesCounter,
+//				std::map<String<Dna5>,std::vector<int> > &backgroundCounter){
+//
+//	typedef std::map<String<Dna5>,std::vector<int> > Dna5CounterMap;
+//	Dna5CounterMap::iterator MapIterator;
+//	MapIterator=sequencesCounter.begin();
+//	Dna5CounterMap::iterator MapIteratorB;
+//	MapIteratorB=backgroundCounter.begin();
+//
+//	
+//	SEQAN_ASSERT_EQ(length(sequencesCounter),length(backgroundCounter));
+//	SEQAN_ASSERT_EQ(length((*MapIterator).second),(length(seq.ids)+1));//+1, because of the last field in vector 
+//	SEQAN_ASSERT_EQ(length((*MapIteratorB).second),(length(back.ids)+1));
+//
+//	//std::cout<<length(sequencesCounter)<<std::endl;
+//	//std::cout<<length((*MapIterator).second)<<std::endl;
+//	//std::cout<<length(backgroundCounter)<<std::endl;
+//	//std::cout<<length((*MapIteratorB).second)<<std::endl;
+//	//std::cout<<length(seq.ids)<<std::endl;
+//	//std::cout<<length(back.ids)<<std::endl;
+//}
+//
+//void DebugMultiMap( std::map<String<Dna5>,std::vector<int> > &sequencesCounter,
+//					std::multimap<double,String<Dna5> > &SortedPValue){
+//	SEQAN_ASSERT_EQ(length(sequencesCounter),SortedPValue.size());
+//
+//}
 
+/****
+		computes all needed logFactorial-values and saves them in p
+		only computed once
+****/
 void logFactorial(unsigned int len){
 	double* p;
 	unsigned int i=1;
@@ -1527,7 +1563,9 @@
 
 	logFac =p;
 }
-
+/****
+		computes the probability with the  hypergeometric distribution --> required by the fisher-exact-test 
+****/
 double calcFET( unsigned int a,
 				unsigned int b,
 				unsigned int c,
@@ -1537,7 +1575,9 @@
 		(logFac[a+b+c+d] + logFac[a]+ logFac[b] + logFac[c] +logFac[d]));
 }
 
-
+/****
+		modifys  a,b,c and d to be more extreme--> needed for the one-sided test
+****/
 void modifyFET( unsigned int a,
 				unsigned int b,
 				unsigned int c,
@@ -1547,7 +1587,6 @@
 	
 	
 	pValue= calcFET(a,b,c,d);
-	//	//std::cout<<(*MapI).first<<" "<<pValue<<"   ";
 	
 		while(b!=0 && c!=0){//modify to be more extrem
 			++a;
@@ -1555,12 +1594,9 @@
 			--c;
 			++d;
 			pValue += calcFET(a,b,c,d);
-			
-	//		//std::cout<<pValue<<"   ";
+	
 		}
 
-
-
 }
 
 
@@ -1576,19 +1612,19 @@
 
 pValue = exp(log((a+b)!(c+d)!(a+c)!(b+d)!/a!b!c!d!n!))
 
-a=In Sequenz gefunden	b=In Background gefunden
-c=In Sequenz !gefunden	d=In Background !gefunden
+a= Found in Sequence 	b=Found in Background 
+c= !Found in Sequence	d= !Found in Background 
 
 a = sequenceCounter		b= backgroundCounter
 a+c=SeqsNumber			b+d=backgroundNumber
 --> c= SeqsNumber - cumulated(sequenceCounter)
 	d= backgroundNumber - cumulated(backgroundCounter)
 
-Für den einseitigen Test zusätzlich:
+One-sided Test:
+	++a und --c ...
+Two-sided Test:
 	++a und --c
-Für den zweiseitigen Test:
-	++a und --c
-	--a und ++c
+	--a und ++c ...
 
 
 
@@ -1599,30 +1635,23 @@
 					 Seq &back){
 
 	
-	
-
 	double pValue=0;
 	typedef std::map<String<Dna5>,unsigned int >::iterator MapIterator;
 	MapIterator MapI=seq.seqCounter.begin();
 	MapIterator MapIB=back.seqCounter.begin();
-	//std::cout<<(*MapI).first<<" "<<(*MapI).second.back()<<std::endl;
-	//std::cout<<(*MapIB).first<<" "<<(*MapIB).second.back()<<std::endl;
 	
 	for(;MapI!=seq.seqCounter.end();++MapI,++MapIB){
 		
 
 		modifyFET((*MapI).second,(*MapIB).second,(seq.SeqsNumber - (*MapI).second),(back.SeqsNumber - (*MapIB).second),pValue);
 	
-	
-		//std::cout<<pValue<<std::endl;
-		//SortedPValue[pValue]=(*MapI).first;
 		seq.SortedPValue.insert(std::pair<double,String<Dna5> > (pValue, (*MapI).first));
 		seq.SortedPValueReversed.insert(std::pair<String<Iupac>,double > ((*MapI).first,pValue));
 	}
 
 
 }
-//--> templates verwenden
+
 void FisherExactTest(std::map<String<Iupac>,unsigned int > &SequenceCounter,
 					 std::map<String<Iupac>,unsigned int > &BackgroundCounter,
 					 Seq &seq, 
@@ -1635,16 +1664,12 @@
 	typedef std::map<String<Iupac>,unsigned int >::iterator MapIterator;
 	MapIterator MapI=SequenceCounter.begin();
 	MapIterator MapIB=BackgroundCounter.begin();
-	//std::cout<<(*MapI).first<<" "<<(*MapI).second.back()<<std::endl;
-	//std::cout<<(*MapIB).first<<" "<<(*MapIB).second.back()<<std::endl;
 	
 	for(;MapI!=SequenceCounter.end();++MapI,++MapIB){
 		
 		
 		modifyFET((*MapI).second,(*MapIB).second,(seq.SeqsNumber - (*MapI).second),(back.SeqsNumber - (*MapIB).second),pValue);
 	
-	
-		
 		seq.generalizedSortedPValue.insert(std::pair<double,String<Iupac> > (pValue, (*MapI).first));
 		seq.SortedPValueReversed.insert(std::pair< String<Iupac>,double> ((*MapI).first,pValue));
 	}
@@ -1661,19 +1686,16 @@
 	
 	
 	
-
-	//std::cout<<"begin Fisher "<<seq.generalizedKmer.size()<<" "<<back.generalizedKmer.size()<<std::endl;
-	
 	if(seq.generalizedKmer.size()==0)	
 		return 2;
 
+	double pValue=0;
 	typedef std::map<String<Iupac>,unsigned int >::iterator MapIterator;
-	
 	std::multimap<double,String<Iupac> >::iterator MapIterator2;
 	MapIterator MapI = seq.generalizedKmer.begin();
 	MapIterator MapIB= back.generalizedKmer.begin();
-	double pValue=0;
-	//std::cout<<generalizedKmerSequence.size();
+	
+
 	for(;MapI!=seq.generalizedKmer.end();++MapI,++MapIB){
 		
 		if((*MapI).second > seq.SeqsNumber || (*MapIB).second > back.SeqsNumber){ std::cout<<(*MapI).first<<" "<<(*MapI).second<<" "<<(*MapIB).first<<" "<<(*MapIB).second<<std::endl;}
@@ -1718,6 +1740,10 @@
 //
 //}
 
+/****
+		some Iupac-Mappings
+		needed in the generalization step
+****/
 void MapIupac(IupacMaps &IMaps ){
 
 	IMaps.IupacMap.get_allocator().allocate(16);
@@ -1809,26 +1835,26 @@
 void InitGeneralization(IupacMaps &IMaps,
 						Seq &seq,
 						Seq &back){
+	unsigned int i=0;
+	unsigned int limit;
 	std::multimap<double,String<Dna5> >::iterator MapIterator;
 	std::multimap<double,String<Iupac> >::iterator MapIteratorT;	
 	std::multimap<double,String<Iupac> > generalizedSortedPValueTemp;
 	std::map<String<Iupac>,unsigned int> generalizedKmerTemp;
 	std::map<String<Iupac>,unsigned int> generalizedKmerBackgroundTemp;
-	unsigned int i=0;
-	unsigned int limit;
-	if(seq.SortedPValue.size()>seq.seed)	limit=seq.seed;//seed meist = 100
+	
+	if(seq.SortedPValue.size()>seq.seed)	limit=seq.seed;//standard-seed = 100
 	else if(seq.SortedPValue.size()==0) return;
 	else	limit = seq.SortedPValue.size();
 	
-	for(MapIterator=seq.SortedPValue.begin();i<limit;++MapIterator,++i){//iterate over Top100
+	for(MapIterator=seq.SortedPValue.begin();i<limit;++MapIterator,++i){//iterate over Top100(TopSeedNumber)
 		GeneralizeKmer((*MapIterator).second,IMaps,seq,back);
 	}
 	/*
 		- only do the next function call, if in the last at least one pValue<treshold	
 		- call GeneralizeKmer in loop
 	*/
-	//PrintMap(seq.generalizedKmer);
-	//seq.generalizedSortedPValue.insert(seq.SortedPValue.begin(),seq.SortedPValue.end());
+	
 	double topPValue = FisherExactTest(seq,back,generalizedSortedPValueTemp);// lowest pValue from the first generalization
 	double topPValueOld =seq.SortedPValue.begin()->first;//lowest pValue before generalization
 	
@@ -1839,29 +1865,26 @@
 			while wird das erste mal mit generalizedKmer aufgerufen und dem temporären mapping der pValues
 			das temporäre mapping wird in das richtige mapping gemerged und gecleant, damit geschaut werden kann, ob bei den neuen pValues ein wert
 			über dem treshold ist --> falls nicht bricht die while ab
-			falls doch wird generalizedKmer kopiert und gecleant aus dem gleichen grund, damit, nur die neuen generalisierten Kmere untersucht werden
-			--> das Temp hier, um über alle alten zu gehen, um diese weiter zu generalisieren
+			falls doch wird generalizedKmer kopiert und gecleant aus dem gleichen grund, damit nur die neuen generalisierten Kmere untersucht werden
+			--> das Temp hier, um über alle alten zu gehen und um diese weiter zu generalisieren
 
 		*/
 
 		seq.generalizedSortedPValue.insert(generalizedSortedPValueTemp.begin(),generalizedSortedPValueTemp.end());
 
 	
-		
-	
 		generalizedKmerTemp.clear();
 		generalizedKmerBackgroundTemp.clear();
 		generalizedKmerTemp=seq.generalizedKmer;
 		generalizedKmerBackgroundTemp=back.generalizedKmer;
 		back.generalizedKmer.clear();
 		seq.generalizedKmer.clear();
-	//	generalizedMapIterator= generalizedKmerTemp.begin();
 		if(generalizedSortedPValueTemp.size()>seq.seed)	limit=seq.seed;
 		else if(generalizedSortedPValueTemp.size()==0) return;
 		else	limit = generalizedSortedPValueTemp.size();
 	
-		i=0;//only Top100
-		for(MapIteratorT=generalizedSortedPValueTemp.begin();i<limit;++MapIteratorT,++i){//iterate over Top100
+		i=0;//only Top100 (seed number)
+		for(MapIteratorT=generalizedSortedPValueTemp.begin();i<limit;++MapIteratorT,++i){//iterate over Top100 (seed number)
 		
 			//Temp ums zu finden, aber das normale auch übergeben, zum neu befüllen
 			
@@ -1870,11 +1893,9 @@
 			                                                                        
 	
 		}
-		generalizedSortedPValueTemp.clear();
-		//std::cout<<"nach for"<<std::endl;
+	generalizedSortedPValueTemp.clear();
 	topPValueOld =topPValue;
 	topPValue = FisherExactTest(seq,back,generalizedSortedPValueTemp);
-	//std::cout<<"nach Fisher "<<topPValue<<" "<<topPValueOld<<std::endl;
 		
 	};
 	
@@ -1909,25 +1930,25 @@
 			temp = Kmer;// reset temp
 			
 			if(*tempIt == *replaceIt) continue; // there is no Iupac for "AA", in return "AG" = "R"
-			//std::cout<<temp<<" "; 
+			
 			tempChar =*tempIt;//stores the current char because of temp2
 			*tempIt=*replaceIt;
-			temp2=temp;//temp2 ist nun das mit dem char für die neue wildcard
-			*tempIt=tempChar;//temp wieder das alte, wird aber im nächsten schritt mit einer neuen wildcard ergänzt
+			temp2=temp;//temp2 stores the char for the new wildcard
+			*tempIt=tempChar;//temp ist the temp from before -->gets expanded with a new wildcard in the next step
 			
 			*tempIt =IMaps.IupacMap[IMaps.IupacMapReversed[*tempIt] + IMaps.IupacMapReversed[*replaceIt]];//compute Iupac-letter--> A + G = R and replace the current location in temp
-			//std::cout<<Kmer<<" "<<temp<<" "<<temp2<<std::endl;
+			
 			if(seq.generalizedKmer.find(temp)!=seq.generalizedKmer.end()) continue;// if Kmer is in the Map -->nothing to do
-			//estimateCounter mit Kmer und temp2 aufrufen --> Kmer=AAA  temp2=TAA temp=WAA
+			//call estimateCounter with Kmer and temp2 --> Kmer=AAA  temp2=TAA temp=WAA
 			estimateCounter(seq,Kmer,temp2,counter);
 			
-			seq.generalizedKmer[temp]=counter;//temp ist das neue motiv
+			seq.generalizedKmer[temp]=counter;//temp = new motif
 			estimateCounter(back,Kmer,temp2,counter);
 			back.generalizedKmer[temp]=counter;
 		}
 	}
 
-	//PrintMap(seq.generalizedKmer);
+
 	
 
 }
@@ -1940,27 +1961,24 @@
 					IupacMaps &IMaps,
 					Seq &seq, 
 					Seq &back){
+	unsigned counter =0;
+	char tempChar;
 	String<Iupac> temp;//temporary String --> generalizedKmer[temp]
 	String<Iupac> temp2;//Kmer with replaced position--> relevant for estimateCounter
 	Iterator<String<Iupac> >::Type tempIt;//Iterator over temp --> same length as Kmer
 	String<Iupac> replace;
 	Iterator<String<Iupac> >::Type replaceIt;
-	unsigned int counter =0;
-	char tempChar;
+	
 	
 	temp = Kmer;
 	tempIt = begin(temp);
-	//std::cout<<temp<<" ";
 	for(;tempIt!=end(temp);++tempIt){//loop over each position in kmer
-		//if(*tempIt == 'A' || *tempIt == 'C' ||*tempIt == 'G' ||*tempIt == 'T') continue;//only replace the position with a wildcard
-		
-		
-		if(*tempIt =='N')continue;//gibt nichts mehr zu ersetzen
+				
+		if(*tempIt =='N')continue;//nothing to do
 		replace=IMaps.IupacMapReplace[*tempIt];
 		replaceIt = begin(replace);	
 		for(;replaceIt!=end(replace);++replaceIt){// loop over the replacement-chars, W=AT --> replace=CG
 			temp = Kmer;// reset temp
-			//std::cout<<*replaceIt<<std::endl;
 			tempChar =*tempIt;//stores the current char because of temp2
 			*tempIt=*replaceIt;//replace the current char for temp2
 			temp2=temp;
@@ -1970,34 +1988,13 @@
 			
 			if(seq.SortedPValueReversed[Kmer] >= 0.05 || seq.SortedPValueReversed[temp2] >= 0.05) continue;//only if Kmer and temp2 are significant estimate the counter
 			if(generalizedKmerTemp.find(temp)!=generalizedKmerTemp.end()) continue;
-			//std::cout<<Kmer<<" "<<temp<<" "<<temp2<<std::endl;
 			estimateCounter(seq,generalizedKmerTemp,Kmer,temp2,counter);
 			seq.generalizedKmer[temp]=counter;
 			estimateCounter(back,generalizedKmerBackgroundTemp,Kmer,temp2,counter);
 			back.generalizedKmer[temp]=counter;
-			//std::cout<<temp<<" "<<counter<<std::endl;
 		}
 
 		}
-		/**
-		- gehe über Kmer --> if ACGT continue
-		- else rufe IupacMapReplace auf
-		- -->for(;replaceIt!=end(replace);++replaceIt) --> loop über den String aus IupacMapReplace
-		- temp ist das neue Kmer und temp2 die neue wildcard--> estimateCounter aufrufen --> für fore- und background
-
-		- funktion wird in for-schleife aufgerufen --> geht über alle
-		- clear generaliedKmer vor der for-schleife
-		- --> wird neu befüllt und kann mit FisherExact aufgerufen werden
-		- SortedPValue wird berechnet (in temp) und überprüft ob noch ein wert drunter ist-->falls ja insertiere temp in den rest
-		- falls nein nehme die top100 und rufe exactSearch auf
-
-
-
-
-	**/
-
-
-
 
 }
 

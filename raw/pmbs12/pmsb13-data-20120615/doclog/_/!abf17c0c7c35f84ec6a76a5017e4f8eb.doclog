2012-07-02T09:01:35.467+02:00	READY	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	14743	1353	639
2012-07-02T09:01:35.714+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T09:01:47.955+02:00	SCROLL	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:01:50.594+02:00	SCROLL	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	14743	1353	639
2012-07-02T09:01:51.424+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	14743	1353	639
2012-07-02T09:01:51.562+02:00	LINK-http://docs.seqan.de/seqan/dev/FUNCTION.rewind.html	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	14743	1353	639
2012-07-02T09:01:51.660+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	14743	1353	639
2012-07-02T09:01:51.688+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T09:01:53.310+02:00	READY	http://docs.seqan.de/seqan/dev/FUNCTION.rewind.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:01:53.408+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Function_Input_2f_Output.html#rewind	193.52.161.170	-	0	0	167	639
2012-07-02T09:01:58.063+02:00	SCROLL	http://docs.seqan.de/seqan/dev/FUNCTION.rewind.html	193.52.161.170	-	0	21	1353	639
2012-07-02T09:02:03.942+02:00	SCROLL	http://docs.seqan.de/seqan/dev/INDEX_Function_Input_2f_Output.html#rewind	193.52.161.170	-	0	57	167	639
2012-07-02T09:02:14.022+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.rewind.html	193.52.161.170	-	0	21	1353	639
2012-07-02T09:02:22.385+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.rewind.html	193.52.161.170	-	0	21	1353	639
2012-07-02T09:02:22.965+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.rewind.html	193.52.161.170	-	0	21	1353	639
2012-07-02T09:02:23.441+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.rewind.html	193.52.161.170	-	0	21	1353	639
2012-07-02T09:02:25.357+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.rewind.html	193.52.161.170	-	0	21	1353	639
2012-07-02T09:02:25.924+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.rewind.html	193.52.161.170	-	0	21	1353	639
2012-07-02T09:02:26.859+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/FUNCTION.rewind.html	193.52.161.170	-	0	21	1353	639
2012-07-02T09:02:26.873+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Function_Input_2f_Output.html#rewind	193.52.161.170	-	0	57	167	639
2012-07-02T09:02:28.993+02:00	READY	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	14992	1353	639
2012-07-02T09:02:29.210+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T09:02:29.761+02:00	BLUR	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	15256	1353	639
2012-07-02T09:02:32.539+02:00	SCROLL	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	14743	1353	639
2012-07-02T09:02:34.153+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	14401	1353	639
2012-07-02T09:02:36.357+02:00	SCROLL	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:02:44.696+02:00	BLUR	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:02:44.718+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T09:02:44.892+02:00	LINK-http://docs.seqan.de/seqan/dev/INDEX_Function_Basic.html	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T09:02:44.988+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T09:02:45.979+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Function_Basic.html	193.52.161.170	-	0	0	180	25033
2012-07-02T09:02:46.423+02:00	LINK-http://docs.seqan.de/seqan/dev/INDEX_Function_Basic.html	http://docs.seqan.de/seqan/dev/INDEX_Function_Basic.html	193.52.161.170	-	0	0	180	25033
2012-07-02T09:02:46.443+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Function_Basic.html	193.52.161.170	-	0	0	180	25033
2012-07-02T09:02:47.279+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Function_Basic.html	193.52.161.170	-	0	0	180	25033
2012-07-02T09:02:56.786+02:00	SCROLL	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	627	1353	639
2012-07-02T09:02:59.180+02:00	BLUR	http://docs.seqan.de/seqan/dev/INDEX_Function_Basic.html	193.52.161.170	-	0	0	180	25033
2012-07-02T09:02:59.200+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	627	1353	639
2012-07-02T09:04:04.813+02:00	BLUR	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	627	1353	639
2012-07-02T09:04:10.250+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	627	1353	639
2012-07-02T09:04:25.198+02:00	BLUR	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	627	1353	639
2012-07-02T09:04:40.513+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	627	1353	639
2012-07-02T09:04:48.158+02:00	BLUR	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:04:48.262+02:00	SCROLL	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:04:53.621+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:04:54.339+02:00	BLUR	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:04:57.139+02:00	SCROLL	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	3301	1353	639
2012-07-02T09:05:04.186+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	3301	1353	639
2012-07-02T09:05:04.285+02:00	LINK-http://docs.seqan.de/seqan/dev/FUNCTION.at_End.html	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	3301	1353	639
2012-07-02T09:05:04.425+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Function_Basic.html	193.52.161.170	-	0	0	180	25033
2012-07-02T09:05:04.407+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	3301	1353	639
2012-07-02T09:05:06.066+02:00	READY	http://docs.seqan.de/seqan/dev/FUNCTION.at_End.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:05:06.159+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Function_Iteration.html#atEnd	193.52.161.170	-	0	0	167	798
2012-07-02T09:05:12.622+02:00	SCROLL	http://docs.seqan.de/seqan/dev/FUNCTION.at_End.html	193.52.161.170	-	0	57	1353	639
2012-07-02T09:06:05.138+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.at_End.html	193.52.161.170	-	0	57	1353	639
2012-07-02T09:06:13.913+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.at_End.html	193.52.161.170	-	0	57	1353	639
2012-07-02T09:06:14.769+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.at_End.html	193.52.161.170	-	0	57	1353	639
2012-07-02T09:06:17.647+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.at_End.html	193.52.161.170	-	0	57	1353	639
2012-07-02T09:06:18.669+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.at_End.html	193.52.161.170	-	0	57	1353	639
2012-07-02T09:06:20.450+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.at_End.html	193.52.161.170	-	0	57	1353	639
2012-07-02T09:06:22.383+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.at_End.html	193.52.161.170	-	0	57	1353	639
2012-07-02T09:08:40.865+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.at_End.html	193.52.161.170	-	0	57	1353	639
2012-07-02T09:08:46.167+02:00	SCROLL	http://docs.seqan.de/seqan/dev/INDEX_Function_Iteration.html#atEnd	193.52.161.170	-	0	399	167	798
2012-07-02T09:08:52.045+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.at_End.html	193.52.161.170	-	0	57	1353	639
2012-07-02T09:08:52.055+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEX_Function_Iteration.html#atEnd	193.52.161.170	-	0	399	167	798
2012-07-02T09:08:52.184+02:00	LINK-http://docs.seqan.de/seqan/dev/FUNCTION.go_Begin.html	http://docs.seqan.de/seqan/dev/INDEX_Function_Iteration.html#atEnd	193.52.161.170	-	0	399	167	798
2012-07-02T09:08:52.291+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/FUNCTION.at_End.html	193.52.161.170	-	0	57	1353	639
2012-07-02T09:08:52.309+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Function_Iteration.html#atEnd	193.52.161.170	-	0	399	167	798
2012-07-02T09:08:54.261+02:00	READY	http://docs.seqan.de/seqan/dev/FUNCTION.go_Begin.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:08:54.325+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Function_Iteration.html#goBegin	193.52.161.170	-	0	0	167	716
2012-07-02T09:09:02.871+02:00	SCROLL	http://docs.seqan.de/seqan/dev/FUNCTION.go_Begin.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:09:09.223+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.go_Begin.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:11:59.910+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.go_Begin.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:12:00.748+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.go_Begin.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:12:02.437+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.go_Begin.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:12:04.216+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.go_Begin.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:15:40.448+02:00	SCROLL	http://docs.seqan.de/seqan/dev/INDEX_Function_Iteration.html#goBegin	193.52.161.170	-	0	285	167	716
2012-07-02T09:22:05.904+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.go_Begin.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:22:06.169+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/FUNCTION.go_Begin.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:22:06.185+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Function_Iteration.html#goBegin	193.52.161.170	-	0	285	167	716
2012-07-02T09:22:07.787+02:00	READY	http://docs.seqan.de/seqan/dev/FUNCTION.position.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:22:07.834+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Function_Iteration.html#position	193.52.161.170	-	0	0	167	639
2012-07-02T09:22:08.849+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.position.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:27:20.823+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.position.html	193.52.161.170	-	0	0	1353	639
2012-07-02T09:27:21.423+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.position.html	193.52.161.170	-	0	0	1353	639
2012-07-02T10:54:16.505+02:00	READY	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	285	1353	639
2012-07-02T10:54:22.999+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	1254	1353	639
2012-07-02T10:54:32.556+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	1653	1353	639
2012-07-02T10:54:42.242+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	1710	1353	639
2012-07-02T10:54:48.836+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	2052	1353	639
2012-07-02T10:54:53.814+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	1596	1353	639
2012-07-02T10:55:10.953+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	3648	1353	639
2012-07-02T10:55:44.350+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	4332	1353	639
2012-07-02T10:55:44.679+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	4332	1353	639
2012-07-02T10:57:22.979+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	4332	1353	639
2012-07-02T10:57:23.484+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	4332	1353	639
2012-07-02T10:57:26.224+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	1042	1353	639
2012-07-02T10:57:35.274+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	1213	1353	639
2012-07-02T10:57:45.858+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	1213	1353	639
2012-07-02T10:57:55.008+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	1213	1353	639
2012-07-02T10:57:57.168+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	1042	1353	639
2012-07-02T10:58:09.367+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	5032	1353	639
2012-07-02T10:58:20.898+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	1083	1353	639
2012-07-02T10:58:24.142+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	1083	1353	639
2012-07-02T10:58:29.796+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	1197	1353	639
2012-07-02T10:58:34.150+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-02T10:58:37.540+02:00	TYPING-proj-search-	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-02T10:58:37.693+02:00	TYPING-proj-search-o	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-02T10:58:38.011+02:00	TYPING-proj-search-of	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-02T10:58:38.154+02:00	TYPING-proj-search-ofs	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-02T10:58:38.368+02:00	TYPING-proj-search-ofst	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-02T10:58:38.471+02:00	TYPING-proj-search-ofstr	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-02T10:58:38.580+02:00	TYPING-proj-search-ofstre	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-02T10:58:38.708+02:00	TYPING-proj-search-ofstrea	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-02T10:58:38.884+02:00	TYPING-proj-search-ofstream	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-02T10:58:39.672+02:00	UNLOAD	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-02T10:58:42.680+02:00	READY	http://trac.seqan.de/search?q=ofstream	193.52.161.170	-	0	0	1366	639
2012-07-02T10:58:43.899+02:00	LINK-http://trac.seqan.de/wiki/Tutorial/FileIO2	http://trac.seqan.de/search?q=ofstream	193.52.161.170	-	0	0	1366	639
2012-07-02T10:58:44.466+02:00	UNLOAD	http://trac.seqan.de/search?q=ofstream	193.52.161.170	-	0	0	1366	639
2012-07-02T10:58:46.443+02:00	READY	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-02T10:58:49.358+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	969	1353	639
2012-07-02T10:58:53.464+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	1083	1353	639
2012-07-02T10:58:53.687+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	1083	1353	639
2012-07-02T10:58:58.918+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	1083	1353	639
2012-07-02T10:59:03.780+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	1197	1353	639
2012-07-02T10:59:06.449+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	1368	1353	639
2012-07-02T10:59:09.203+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	1653	1353	639
2012-07-02T10:59:18.682+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	2964	1353	639
2012-07-02T10:59:19.556+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	2964	1353	639
2012-07-02T11:49:07.426+02:00	READY	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:49:08.345+02:00	READY	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T11:49:09.191+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#CharString	193.52.161.170	-	0	0	180	2150
2012-07-02T11:49:16.179+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	2052	1353	639
2012-07-02T11:49:22.000+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	2622	1353	639
2012-07-02T11:49:32.786+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	6270	1353	639
2012-07-02T11:49:35.342+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	3803	1353	639
2012-07-02T11:49:39.267+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	3888	1353	639
2012-07-02T11:49:44.717+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	3803	1353	639
2012-07-02T11:49:47.111+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T11:49:51.088+02:00	BLUR	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T11:49:51.104+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#CharString	193.52.161.170	-	0	0	180	2150
2012-07-02T11:49:51.222+02:00	LINK-http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#CharString	193.52.161.170	-	0	0	180	2150
2012-07-02T11:49:51.252+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T11:49:51.266+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#CharString	193.52.161.170	-	0	0	180	2150
2012-07-02T11:49:53.180+02:00	READY	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T11:49:53.245+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#CharString	193.52.161.170	-	0	0	180	2150
2012-07-02T11:50:04.178+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	513	1353	639
2012-07-02T11:50:20.377+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T11:50:24.104+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	57	1353	639
2012-07-02T11:50:29.923+02:00	BLUR	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T11:50:30.073+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T11:50:39.664+02:00	READY	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T11:50:40.160+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#Dna5String	193.52.161.170	-	0	0	180	639
2012-07-02T11:50:43.683+02:00	READY	http://docs.seqan.de/seqan/dev2/files/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T11:50:49.020+02:00	READY	http://trac.seqan.de/browser/trunk/seqan/projects/tests/modifier/test_modifier_shortcuts.h?rev=5591	193.52.161.170	-	0	0	1353	639
2012-07-02T11:50:57.814+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:00.321+02:00	FOCUS	http://docs.seqan.de/seqan/dev2/files/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:01.603+02:00	READY	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:02.921+02:00	READY	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:04.555+02:00	FOCUS	http://trac.seqan.de/browser/trunk/seqan/projects/tests/modifier/test_modifier_shortcuts.h?rev=5591	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:07.802+02:00	SCROLL	http://trac.seqan.de/browser/trunk/seqan/projects/tests/modifier/test_modifier_shortcuts.h?rev=5591	193.52.161.170	-	0	285	1353	639
2012-07-02T11:51:14.268+02:00	SCROLL	http://trac.seqan.de/browser/trunk/seqan/projects/tests/modifier/test_modifier_shortcuts.h?rev=5591	193.52.161.170	-	0	1311	1353	639
2012-07-02T11:51:20.398+02:00	BLUR	http://trac.seqan.de/browser/trunk/seqan/projects/tests/modifier/test_modifier_shortcuts.h?rev=5591	193.52.161.170	-	0	3363	1353	639
2012-07-02T11:51:20.409+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:23.463+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:23.475+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:27.750+02:00	TYPING-proj-search-	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:27.980+02:00	TYPING-proj-search-c	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:28.019+02:00	TYPING-proj-search-ch	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:28.151+02:00	TYPING-proj-search-cha	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:28.315+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:28.736+02:00	TYPING-proj-search-char	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:28.853+02:00	TYPING-proj-search-cha	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:29.011+02:00	TYPING-proj-search-ch	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:29.176+02:00	TYPING-proj-search-c	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:29.350+02:00	TYPING-proj-search-	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:29.649+02:00	TYPING-proj-search-	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:29.897+02:00	TYPING-proj-search-c	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:30.485+02:00	TYPING-proj-search-ch	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:30.655+02:00	TYPING-proj-search-cha	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:31.001+02:00	TYPING-proj-search-char	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:31.082+02:00	TYPING-proj-search-chars	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:31.270+02:00	TYPING-proj-search-charst	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:31.319+02:00	TYPING-proj-search-charstr	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:31.396+02:00	TYPING-proj-search-charstri	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:31.513+02:00	TYPING-proj-search-charstrin	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:31.657+02:00	TYPING-proj-search-charstring	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:32.297+02:00	UNLOAD	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:34.536+02:00	READY	http://trac.seqan.de/search?q=charstring	193.52.161.170	-	0	171	1353	639
2012-07-02T11:51:39.502+02:00	READY	http://trac.seqan.de/wiki/Tutorial/BasicTechniquesOverview	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:39.912+02:00	BLUR	http://trac.seqan.de/search?q=charstring	193.52.161.170	-	0	171	1353	639
2012-07-02T11:51:39.924+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	0	1353	639
2012-07-02T11:51:46.709+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	627	1353	639
2012-07-02T11:51:55.101+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	1368	1353	639
2012-07-02T11:52:10.877+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	1995	1353	639
2012-07-02T11:52:22.938+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	2736	1353	639
2012-07-02T11:52:26.421+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	2223	1353	639
2012-07-02T11:52:35.647+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	2622	1353	639
2012-07-02T11:52:38.145+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	2622	1353	639
2012-07-02T11:52:38.154+02:00	FOCUS	http://trac.seqan.de/search?q=charstring	193.52.161.170	-	0	171	1353	639
2012-07-02T11:52:39.966+02:00	BLUR	http://trac.seqan.de/search?q=charstring	193.52.161.170	-	0	171	1353	639
2012-07-02T11:52:39.980+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/BasicTechniquesOverview	193.52.161.170	-	0	0	1353	639
2012-07-02T11:52:48.804+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/BasicTechniquesOverview	193.52.161.170	-	0	1425	1353	639
2012-07-02T11:52:52.698+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/BasicTechniquesOverview	193.52.161.170	-	0	1710	1353	639
2012-07-02T11:53:08.212+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/BasicTechniquesOverview	193.52.161.170	-	0	2736	1353	639
2012-07-02T11:53:11.337+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/BasicTechniquesOverview	193.52.161.170	-	0	1238	1353	639
2012-07-02T11:53:20.091+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/BasicTechniquesOverview	193.52.161.170	-	0	1289	1353	639
2012-07-02T11:53:20.443+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/BasicTechniquesOverview	193.52.161.170	-	0	1289	1353	639
2012-07-02T11:53:20.449+02:00	FOCUS	http://trac.seqan.de/search?q=charstring	193.52.161.170	-	0	171	1353	639
2012-07-02T11:53:24.103+02:00	SCROLL	http://trac.seqan.de/search?q=charstring	193.52.161.170	-	0	0	1353	639
2012-07-02T11:53:24.152+02:00	BLUR	http://trac.seqan.de/search?q=charstring	193.52.161.170	-	0	0	1353	639
2012-07-02T11:53:25.553+02:00	FOCUS	http://trac.seqan.de/search?q=charstring	193.52.161.170	-	0	0	1353	639
2012-07-02T11:53:26.640+02:00	BLUR	http://trac.seqan.de/search?q=charstring	193.52.161.170	-	0	0	1353	639
2012-07-02T11:53:28.586+02:00	FOCUS	http://trac.seqan.de/search?q=charstring	193.52.161.170	-	0	0	1353	639
2012-07-02T11:53:29.092+02:00	UNLOAD	http://trac.seqan.de/search?q=charstring	193.52.161.170	-	0	0	1353	639
2012-07-02T11:54:40.992+02:00	READY	http://trac.seqan.de/wiki/Tutorial/PatternMatching	193.52.161.170	-	0	0	1353	639
2012-07-02T11:54:41.754+02:00	READY	http://trac.seqan.de/wiki/Tutorial/PatternMatching/Assignment1	193.52.161.170	-	0	0	1353	639
2012-07-02T11:55:20.104+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/PatternMatching	193.52.161.170	-	0	0	1353	639
2012-07-02T11:55:30.892+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/PatternMatching	193.52.161.170	-	0	627	1353	639
2012-07-02T11:55:40.234+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/PatternMatching	193.52.161.170	-	0	2679	1353	639
2012-07-02T11:55:49.631+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/PatternMatching	193.52.161.170	-	0	3021	1353	639
2012-07-02T11:55:52.581+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/PatternMatching	193.52.161.170	-	0	3448	1353	639
2012-07-02T11:55:52.775+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/PatternMatching	193.52.161.170	-	0	3448	1353	639
2012-07-02T11:55:52.785+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/PatternMatching/Assignment1	193.52.161.170	-	0	0	1353	639
2012-07-02T11:55:53.066+02:00	UNLOAD	http://trac.seqan.de/wiki/Tutorial/PatternMatching	193.52.161.170	-	0	0	0	0
2012-07-02T11:55:59.214+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/PatternMatching/Assignment1	193.52.161.170	-	0	400	1353	639
2012-07-02T11:55:59.493+02:00	UNLOAD	http://trac.seqan.de/wiki/Tutorial/PatternMatching/Assignment1	193.52.161.170	-	0	0	0	0
2012-07-02T11:56:03.840+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	2622	1353	639
2012-07-02T11:56:04.470+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	2622	1353	639
2012-07-02T11:56:04.483+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T11:56:12.059+02:00	BLUR	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	171	1353	639
2012-07-02T11:56:12.118+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	171	1353	639
2012-07-02T11:57:50.569+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	1140	1353	639
2012-07-02T11:57:56.461+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	791	1353	639
2012-07-02T11:58:00.471+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	620	1353	639
2012-07-02T11:58:00.567+02:00	BLUR	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	620	1353	639
2012-07-02T11:58:00.708+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	620	1353	639
2012-07-02T11:58:00.589+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#CharString	193.52.161.170	-	0	0	180	2150
2012-07-02T11:58:05.031+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	449	1353	639
2012-07-02T11:58:31.910+02:00	BLUR	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#CharString	193.52.161.170	-	0	0	180	2150
2012-07-02T13:33:45.298+02:00	READY	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T13:33:45.365+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#Dna5String	193.52.161.170	-	0	0	180	639
2012-07-02T13:32:51.294+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	1504	1353	639
2012-07-02T13:33:07.862+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	3803	1353	639
2012-07-02T13:33:12.352+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	3786	1353	639
2012-07-02T13:33:09.823+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	3803	1353	639
2012-07-02T13:32:59.534+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	1561	1353	639
2012-07-02T13:32:38.265+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	2622	1353	639
2012-07-02T13:32:48.464+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	3306	1353	639
2012-07-02T13:32:19.887+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#CharString	193.52.161.170	-	0	0	180	2150
2012-07-02T13:32:23.369+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#CharString	193.52.161.170	-	0	0	180	2150
2012-07-02T13:32:19.988+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	449	1353	639
2012-07-02T13:32:46.712+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	2964	1353	639
2012-07-02T13:32:23.353+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T13:32:19.963+02:00	BLUR	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#CharString	193.52.161.170	-	0	0	180	2150
2012-07-02T13:32:43.168+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/Seed-and-Extend	193.52.161.170	-	0	2850	1353	639
2012-07-02T14:13:52.104+02:00	READY	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	5496	1353	639
2012-07-02T14:12:09.813+02:00	BLUR	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:11:27.120+02:00	BLUR	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:12:09.370+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:11:25.085+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:10:26.366+02:00	BLUR	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:10:25.922+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:14:54.516+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:14:54.903+02:00	BLUR	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:12:39.048+02:00	BLUR	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:12:38.364+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:39:32.217+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:39:34.556+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	5496	1353	639
2012-07-02T14:39:34.539+02:00	BLUR	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:39:37.366+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	5496	1353	639
2012-07-02T14:39:37.375+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:39:42.072+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:39:44.723+02:00	BLUR	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:39:44.739+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#Dna5String	193.52.161.170	-	0	0	180	639
2012-07-02T14:39:45.491+02:00	LINK-http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Input_2f_Output.html	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#Dna5String	193.52.161.170	-	0	0	180	639
2012-07-02T14:39:45.601+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#Dna5String	193.52.161.170	-	0	0	180	639
2012-07-02T14:39:46.742+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Input_2f_Output.html	193.52.161.170	-	0	0	180	639
2012-07-02T14:39:50.014+02:00	LINK-http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Iterators.html	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Input_2f_Output.html	193.52.161.170	-	0	0	180	639
2012-07-02T14:39:50.099+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Input_2f_Output.html	193.52.161.170	-	0	0	180	639
2012-07-02T14:39:51.408+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Iterators.html	193.52.161.170	-	0	0	180	639
2012-07-02T14:39:52.691+02:00	LINK-http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Modifier.html	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Iterators.html	193.52.161.170	-	0	0	180	639
2012-07-02T14:39:52.767+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Iterators.html	193.52.161.170	-	0	0	180	639
2012-07-02T14:39:53.705+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Modifier.html	193.52.161.170	-	0	0	167	639
2012-07-02T14:39:55.283+02:00	LINK-http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Scoring.html	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Modifier.html	193.52.161.170	-	0	0	167	639
2012-07-02T14:39:55.357+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Modifier.html	193.52.161.170	-	0	0	167	639
2012-07-02T14:39:56.450+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Scoring.html	193.52.161.170	-	0	0	180	639
2012-07-02T14:39:58.550+02:00	LINK-http://docs.seqan.de/seqan/dev/INDEXPAGE_Spec.html	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Scoring.html	193.52.161.170	-	0	0	180	639
2012-07-02T14:39:58.633+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/SHORTCUT_Dna5_String.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:39:58.651+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Scoring.html	193.52.161.170	-	0	0	180	639
2012-07-02T14:40:00.212+02:00	READY	http://docs.seqan.de/seqan/dev/INDEXPAGE_Spec.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:40:00.824+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEXPAGE_Spec.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:40:06.412+02:00	READY	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:40:07.738+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T14:41:06.638+02:00	SCROLL	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	285	1353	639
2012-07-02T14:41:10.484+02:00	SCROLL	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	456	1353	639
2012-07-02T14:41:18.903+02:00	SCROLL	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	741	1353	639
2012-07-02T14:41:21.353+02:00	SCROLL	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	684	1353	639
2012-07-02T14:41:27.737+02:00	BLUR	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	684	1353	639
2012-07-02T14:42:22.499+02:00	SCROLL	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:42:27.625+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	741	1353	639
2012-07-02T14:42:27.693+02:00	BLUR	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	741	1353	639
2012-07-02T14:42:28.045+02:00	TYPING-search-re	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T14:42:28.171+02:00	TYPING-search-rea	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T14:42:27.711+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T14:42:27.828+02:00	TYPING-search-	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T14:42:27.928+02:00	TYPING-search-r	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T14:42:28.982+02:00	SCROLL	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	741	1353	639
2012-07-02T14:42:29.297+02:00	TYPING-search-read	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T14:42:29.399+02:00	TYPING-search-readr	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T14:42:29.607+02:00	TYPING-search-readre	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T14:42:30.276+02:00	TYPING-search-readrec	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T14:42:30.617+02:00	TYPING-search-readreco	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T14:42:31.015+02:00	TYPING-search-readrecord	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T14:42:30.806+02:00	TYPING-search-readrecor	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T14:42:39.435+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEXPAGE_Function.html	193.52.161.170	-	0	741	1353	639
2012-07-02T14:42:39.458+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Function.html	193.52.161.170	-	0	0	180	25033
2012-07-02T14:42:41.342+02:00	READY	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:42:41.398+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Function_Input_2f_Output.html#readRecord	193.52.161.170	-	0	0	167	1144
2012-07-02T14:42:44.998+02:00	SCROLL	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:42:56.414+02:00	SCROLL	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	342	1353	639
2012-07-02T14:42:57.464+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	342	1353	639
2012-07-02T14:43:00.659+02:00	SCROLL	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	525	1353	639
2012-07-02T14:43:05.358+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	525	1353	639
2012-07-02T14:43:28.464+02:00	SCROLL	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	525	1353	639
2012-07-02T14:43:34.607+02:00	SCROLL	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:43:38.246+02:00	SCROLL	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	399	1353	639
2012-07-02T14:43:43.160+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	399	1353	639
2012-07-02T14:49:29.962+02:00	READY	http://trac.seqan.de/wiki/Tutorial/ReadingSequenceFiles#RecordReadingAPI	193.52.161.170	-	0	370	1353	639
2012-07-02T14:49:33.968+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/ReadingSequenceFiles#RecordReadingAPI	193.52.161.170	-	0	370	1353	639
2012-07-02T14:49:34.252+02:00	UNLOAD	http://trac.seqan.de/wiki/Tutorial/ReadingSequenceFiles#RecordReadingAPI	193.52.161.170	-	0	0	0	0
2012-07-02T14:49:38.802+02:00	READY	http://trac.seqan.de/wiki/Tutorial/ReadingSequenceFiles#RecordReadingAPI	193.52.161.170	-	0	370	1353	639
2012-07-02T14:49:46.397+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/ReadingSequenceFiles#RecordReadingAPI	193.52.161.170	-	0	370	1353	639
2012-07-02T14:49:47.468+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/ReadingSequenceFiles#RecordReadingAPI	193.52.161.170	-	0	370	1353	639
2012-07-02T14:50:10.532+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/ReadingSequenceFiles#RecordReadingAPI	193.52.161.170	-	0	370	1353	639
2012-07-02T14:50:22.359+02:00	READY	http://docs.seqan.de/seqan/dev/SPEC_Double-_Pass+_Record_Reader.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:50:22.506+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Spec_Input+_2f+_Output.html#Double-Pass%20RecordReader	193.52.161.170	-	0	0	180	1656
2012-07-02T14:50:30.742+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SPEC_Double-_Pass+_Record_Reader.html	193.52.161.170	-	0	285	1353	639
2012-07-02T14:50:35.766+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SPEC_Double-_Pass+_Record_Reader.html	193.52.161.170	-	0	1038	1353	639
2012-07-02T14:50:40.054+02:00	LINK-http://docs.seqan.de/seqan/dev/FUNCTION.start_Second_Pass.html	http://docs.seqan.de/seqan/dev/SPEC_Double-_Pass+_Record_Reader.html	193.52.161.170	-	0	1038	1353	639
2012-07-02T14:50:40.180+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/SPEC_Double-_Pass+_Record_Reader.html	193.52.161.170	-	0	1038	1353	639
2012-07-02T14:50:40.200+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Spec_Input+_2f+_Output.html#Double-Pass%20RecordReader	193.52.161.170	-	0	0	180	1656
2012-07-02T14:50:41.894+02:00	READY	http://docs.seqan.de/seqan/dev/FUNCTION.start_Second_Pass.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:50:42.023+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Function_Input_2f_Output.html#startSecondPass	193.52.161.170	-	0	0	167	639
2012-07-02T14:50:46.019+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.start_Second_Pass.html	193.52.161.170	-	0	0	1353	639
2012-07-02T14:51:12.914+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/ReadingSequenceFiles#RecordReadingAPI	193.52.161.170	-	0	370	1353	639
2012-07-02T14:51:17.365+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/ReadingSequenceFiles#RecordReadingAPI	193.52.161.170	-	0	0	1353	639
2012-07-02T14:51:21.493+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/ReadingSequenceFiles#RecordReadingAPI	193.52.161.170	-	0	0	1353	639
2012-07-02T14:51:42.389+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/ReadingSequenceFiles#RecordReadingAPI	193.52.161.170	-	0	0	1353	639
2012-07-02T14:51:51.378+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/ReadingSequenceFiles#RecordReadingAPI	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:11.653+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/ReadingSequenceFiles#RecordReadingAPI	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:13.414+02:00	LINK-http://trac.seqan.de/newticket	http://trac.seqan.de/wiki/Tutorial/ReadingSequenceFiles#RecordReadingAPI	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:13.908+02:00	UNLOAD	http://trac.seqan.de/wiki/Tutorial/ReadingSequenceFiles#RecordReadingAPI	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:16.909+02:00	READY	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:16.974+02:00	TYPING-field-description-	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:17.362+02:00	TYPING-field-description-	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:19.746+02:00	TYPING-field-description-For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams).	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:20.338+02:00	TYPING-field-description-For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams).	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:20.831+02:00	TYPING-field-description-For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:21.527+02:00	TYPING-field-description-For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:21.799+02:00	TYPING-field-description-For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:21.862+02:00	TYPING-field-description-For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:22.439+02:00	TYPING-field-description-"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:23.600+02:00	TYPING-field-description-"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:23.972+02:00	TYPING-field-description-\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:24.476+02:00	TYPING-field-description-\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:24.641+02:00	TYPING-field-description-\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:24.786+02:00	TYPING-field-description-\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:27.066+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:33.372+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:41.744+02:00	TYPING-field-description-    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }   \n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:41.923+02:00	TYPING-field-description-    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }  \n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:42.113+02:00	TYPING-field-description-    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      } \n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:42.415+02:00	TYPING-field-description-    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:47.532+02:00	LINK-http://trac.seqan.de/wiki/WikiFormatting	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:48.229+02:00	UNLOAD	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:52:51.614+02:00	READY	http://trac.seqan.de/wiki/WikiFormatting	193.52.161.170	-	0	171	1353	639
2012-07-02T14:53:02.301+02:00	SCROLL	http://trac.seqan.de/wiki/WikiFormatting	193.52.161.170	-	0	1425	1353	639
2012-07-02T14:53:22.178+02:00	TYPING-field-description-{{{#!    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:20.372+02:00	TYPING-field-description-{{{#    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:20.327+02:00	TYPING-field-description-{{{#    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:20.031+02:00	READY	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:20.174+02:00	TYPING-field-description-{{{    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:11.571+02:00	UNLOAD	http://trac.seqan.de/wiki/WikiFormatting	193.52.161.170	-	0	1425	1353	639
2012-07-02T14:53:24.732+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:24.707+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:24.672+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:24.649+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:24.050+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:22.731+02:00	TYPING-field-description-{{{#!c    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:24.896+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:24.854+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:24.825+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:24.799+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:24.766+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:25.018+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:24.979+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:24.962+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:24.916+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:25.127+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:25.111+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:25.070+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:25.041+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:25.249+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:25.218+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:25.188+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:25.157+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:25.379+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:25.340+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:25.309+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:25.278+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:25.489+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:25.461+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:25.429+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:25.399+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:26.381+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:26.205+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:26.160+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:25.825+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:28.179+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:28.011+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:27.651+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:26.547+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:45.315+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:38.324+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:33.975+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	228	1353	639
2012-07-02T14:53:28.344+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:46.601+02:00	TYPING-field-description-\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:46.476+02:00	TYPING-field-description-\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:45.910+02:00	TYPING-field-description-\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:45.733+02:00	TYPING-field-description-{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:57.719+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:55.765+02:00	TYPING-field-description-\n{{{\n\n}}}\n\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:48.344+02:00	LINK-http://trac.seqan.de/newticket#	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:53:46.767+02:00	TYPING-field-description-\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:03.020+02:00	TYPING-field-description-H\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:02.583+02:00	TYPING-field-description-\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:02.304+02:00	TYPING-field-description-\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:01.027+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:04.517+02:00	TYPING-field-description-Hello\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:03.464+02:00	TYPING-field-description-Hell\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:03.290+02:00	TYPING-field-description-Hel\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:03.116+02:00	TYPING-field-description-He\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:07.591+02:00	TYPING-field-description-Hello\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:05.353+02:00	TYPING-field-description-Hello,\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:05.193+02:00	TYPING-field-description-Hello,\n\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:04.757+02:00	TYPING-field-description-Hello,\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:08.237+02:00	TYPING-field-description-Hello Se\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:08.118+02:00	TYPING-field-description-Hello S\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:07.904+02:00	TYPING-field-description-Hello \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:07.785+02:00	TYPING-field-description-Hello \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:08.887+02:00	TYPING-field-description-Hello Seqan-\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:08.816+02:00	TYPING-field-description-Hello Seqan\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:08.577+02:00	TYPING-field-description-Hello Seqa\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:08.449+02:00	TYPING-field-description-Hello Seq\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:09.334+02:00	TYPING-field-description-Hello Seqan-Tea\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:09.293+02:00	TYPING-field-description-Hello Seqan-Te\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:09.113+02:00	TYPING-field-description-Hello Seqan-T\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:09.003+02:00	TYPING-field-description-Hello Seqan-\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:10.922+02:00	TYPING-field-description-Hello Seqan-Team,\n\n\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:10.025+02:00	TYPING-field-description-Hello Seqan-Team,\n\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:09.835+02:00	TYPING-field-description-Hello Seqan-Team,\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:09.499+02:00	TYPING-field-description-Hello Seqan-Team\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:12.219+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI w\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:12.038+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:11.238+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:11.012+02:00	TYPING-field-description-Hello Seqan-Team,\n\n\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:12.740+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wante\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:12.600+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:12.458+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wan\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:12.364+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wa\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:13.215+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:13.041+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:12.985+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:12.830+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:13.613+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to rea\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:13.518+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to re\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:13.417+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to r\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:13.349+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:14.525+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:13.922+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:13.855+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:13.702+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:14.964+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fast\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:14.832+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fas\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:14.673+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fa\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:14.626+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a f\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:15.759+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-fi\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:15.673+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-f\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:15.617+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:15.301+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:18.847+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:18.818+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:18.319+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:15.814+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-fil\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:18.998+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:18.970+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:18.963+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:18.878+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:20.354+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:20.052+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:19.060+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:19.029+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:22.786+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a Fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:22.612+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a Fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:20.546+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a astq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:20.360+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:23.884+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a Fast-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:23.818+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a Fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:23.133+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a Fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:22.967+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a Fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:27.377+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a FastQ-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:26.877+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a FastQ-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:24.895+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a FastQ-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:24.051+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a Fast-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:27.675+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a FastQ-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:27.471+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a FastQ-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:27.439+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a FastQ-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:27.412+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a FastQ-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:29.043+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a Fas-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:29.010+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a Fast-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:28.508+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a FastQ-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:27.967+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a FastQ-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:29.600+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:29.521+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a -file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:29.333+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a F-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:29.070+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a Fa-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:30.263+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read afa-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:30.097+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read afas-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:29.800+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read afa-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:29.753+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read af-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:30.836+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a f-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:30.751+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a -file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:30.675+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:30.437+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read af-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:31.785+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:31.158+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fast-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:31.049+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fas-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:30.922+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fa-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:46.935+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:38.490+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file s\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:37.736+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:33.718+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:47.977+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file in s\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:47.583+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file in \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:47.326+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file in\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:47.102+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file i\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:49.337+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file in\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:49.154+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file in \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:48.965+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file in a\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:48.131+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file in \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:51.233+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file in\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:50.289+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file i\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:50.099+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:49.527+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file i\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:56.678+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file an\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:56.562+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file a\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:56.473+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:51.407+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file i\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:00.314+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file an\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:00.156+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file and\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:59.973+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file and \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:54:56.807+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file and\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:02.050+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:01.837+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:01.779+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:00.472+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file a\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:02.575+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to pro\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:02.435+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to pr\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:02.334+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to p\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:02.247+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:03.179+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:03.080+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to proces\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:02.922+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to proce\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:02.710+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to proc\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:04.086+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:03.580+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:03.453+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process i\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:03.366+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:04.558+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:04.549+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:04.283+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it an\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:04.162+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it a\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:04.904+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and not \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:04.780+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and not\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:04.636+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and no\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:04.568+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and n\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:06.020+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and not \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:05.986+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and not t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:05.486+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and not to\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:05.015+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and not t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:06.324+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and no\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:06.157+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and not\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:06.794+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and do\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:06.676+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and d\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:06.619+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:06.480+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and n\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:07.834+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and don't\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:07.722+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and don'\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:07.471+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and don\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:07.411+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and don\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:08.400+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and don't wan\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:08.243+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and don't wa\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:08.131+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and don't w\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:07.965+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and don't \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:08.851+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and don't want to\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:08.628+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and don't want t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:08.588+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and don't want \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:08.417+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and don't want\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:14.687+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:12.663+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:12.175+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wante to read a fastq-file to process it and don't want to \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:11.882+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI wanted to read a fastq-file to process it and don't want to \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:15.073+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to stor\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:14.979+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to sto\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:14.862+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to st\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:14.751+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to s\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:15.576+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store th\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:15.477+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:15.332+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:15.154+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:16.569+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the te\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:16.202+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:16.029+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:15.721+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:17.128+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the en\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:16.995+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the e\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:16.788+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:16.588+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:18.232+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entrie\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:18.028+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entri\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:17.414+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entr\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:17.319+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the ent\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:18.747+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:18.540+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries i\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:18.462+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:18.342+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:19.250+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in mem\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:19.077+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in me\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:18.991+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in m\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:18.919+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:19.875+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory.\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:19.694+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:19.595+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memor\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:19.361+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memo\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:20.514+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Th\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:20.412+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. T\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:20.222+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:20.021+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:21.227+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Theref\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:21.115+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. There\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:20.869+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Ther\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:20.735+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. The\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:22.042+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefor\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:21.987+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefo\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:21.888+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefoe\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:21.431+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefo\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:22.860+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:22.621+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:22.491+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:22.139+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:23.369+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I sti\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:23.204+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I st\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:23.086+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I s\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:22.998+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:24.177+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick w\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:24.163+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:24.153+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:23.458+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stic\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:24.378+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:24.282+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:24.267+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick wit\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:24.189+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick wi\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:24.959+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:24.748+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:24.661+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with th\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:24.515+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:25.753+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the Rec\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:25.595+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the Re\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:25.238+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the R\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:25.128+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:26.472+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the Record \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:26.190+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the Record\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:26.085+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the Recor\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:25.896+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the Reco\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:26.944+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordRe\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:26.764+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordR\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:26.688+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the Record\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:26.524+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the Record \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:27.702+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:27.556+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:27.284+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReade\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:27.190+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordRead\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:27.032+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordRea\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:28.608+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as i\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:28.435+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:27.871+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:27.782+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader a\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:29.137+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it wa\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:29.074+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it w\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:28.989+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:28.980+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:29.665+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was pr\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:29.554+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was p\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:29.454+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:29.234+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:30.702+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was prop\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:29.904+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was pro\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:31.017+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was propo\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:31.200+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was propos\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:31.342+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was propose\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:31.416+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:31.697+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:31.834+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed s\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:31.951+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed so\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:32.062+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed som\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:32.257+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed some\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:32.354+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somew\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:32.502+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewh\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:32.628+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhe\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:32.731+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewher\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:32.788+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:32.903+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:32.998+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere i\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:33.292+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:33.205+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:33.581+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:33.445+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in th\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:33.407+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:34.293+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:34.382+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the d\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:34.516+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the di\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:34.843+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the dic\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:35.635+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the dict\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:35.809+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the dic\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:35.975+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the di\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:36.141+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the d\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:36.927+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:37.016+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the w\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:37.198+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wi\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:37.356+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wik\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:37.538+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:44.477+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki.\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:44.497+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki.\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:44.587+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:44.769+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. A\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:44.855+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Ad\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:45.200+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Adi\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:45.291+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Ad\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:45.411+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Add\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:45.543+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Addi\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:45.662+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Addit\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:45.734+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additi\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:45.900+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additio\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:46.086+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Addition\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:46.239+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additiona\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:46.637+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additional\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:46.732+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionall\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:46.938+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:47.976+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:48.205+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:48.380+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally,\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:48.545+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:48.902+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, i\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:49.111+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:49.200+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:49.451+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in a\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:49.608+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:49.870+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:50.035+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:50.168+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in o\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:50.247+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in on\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:50.372+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:50.642+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:50.706+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:50.887+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one to\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:51.036+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one tot\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:51.548+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one totu\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:51.730+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one tot\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:52.088+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one to\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:52.308+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:52.474+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one tu\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:52.785+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one tut\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:53.286+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one tuto\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:54.037+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one tutor\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:54.168+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one tutori\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:54.327+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one tutoria\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:55:56.376+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:04.968+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	399	1353	639
2012-07-02T14:56:08.009+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	342	1353	639
2012-07-02T14:56:09.157+02:00	SCROLL	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	342	1353	639
2012-07-02T14:56:13.160+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:15.242+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one tutorial\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:15.743+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one tutoria\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:15.773+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one tutori\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:15.805+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one tutor\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:15.926+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:15.865+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one tut\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:15.894+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one tu\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:15.835+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one tuto\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:16.178+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in o\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:16.016+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in on\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:15.990+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:15.959+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in one \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:16.668+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in th\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:16.500+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:16.444+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:16.986+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the d\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:16.908+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:16.738+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:17.302+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the doc\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:17.120+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the do\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:17.728+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs i\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:17.571+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:17.399+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:18.090+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it i\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:18.022+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:17.841+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:18.517+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is m\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:18.431+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:18.243+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:18.840+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is ment\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:18.722+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is men\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:18.642+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is me\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:18.943+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is menti\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:19.179+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentio\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:19.313+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mention\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:19.522+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentione\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:20.802+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:20.784+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned th\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:20.323+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:20.414+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:20.532+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:20.793+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned tha\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:23.342+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that fo\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:23.160+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that for\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:21.960+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that fo\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:21.610+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that f\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:21.540+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:24.735+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:24.172+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned th\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:24.014+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned tha\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:23.840+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:23.690+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:23.516+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that f\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:25.481+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:25.324+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned ta\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:25.174+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned tat\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:24.821+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned ta\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:25.989+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that on\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:25.952+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that o\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:25.842+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:25.694+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:25.613+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned tha\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:25.525+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned th\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:26.596+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one us\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:26.350+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one u\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:26.314+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:26.133+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:29.749+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:29.164+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:26.899+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:26.785+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one use\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:30.711+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses Dp\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:30.561+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses Dpi\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:30.098+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses Dp\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:30.012+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses D\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:31.478+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses Doub\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:31.271+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses Dou\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:31.017+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses Do\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:30.900+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses D\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:32.436+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses Double\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:32.224+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses Double\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:31.893+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses Double\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:31.610+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses Doubl\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:33.376+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:32.970+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePas\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:32.757+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePa\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:32.645+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoubleP\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:34.177+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:33.909+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<>\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:33.758+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:33.678+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:34.777+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:34.515+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:34.397+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> fo\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:34.248+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> f\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:35.292+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:35.204+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for bes\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:35.092+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for be\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:34.887+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for b\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:36.322+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best per\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:36.141+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best pe\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:36.052+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best p\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:35.953+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:36.835+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfoma\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:36.722+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfom\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:36.590+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfo\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:36.379+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perf\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:37.579+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:37.433+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:37.046+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomanc\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:36.951+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfoman\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:38.953+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:38.679+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:38.489+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:38.283+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:39.896+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:39.730+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:39.557+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:39.277+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:41.263+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:40.883+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:40.691+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:40.070+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:42.293+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:42.183+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:41.594+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:41.444+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:43.052+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:42.768+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:42.609+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:42.451+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:44.043+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:43.954+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:43.787+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:43.194+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:45.062+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:44.872+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:44.722+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:44.549+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:46.454+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:46.305+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:45.784+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:45.602+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:47.407+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:46.960+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:46.794+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:46.636+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:55.060+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\n\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:54.730+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\n\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:54.089+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:53.915+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:59.935+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:59.820+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThi\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:59.666+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nTh\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:56:59.579+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nT\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:00.437+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis wor\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:00.389+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis wo\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:00.234+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis w\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:00.120+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:01.388+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works w\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:01.317+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:00.970+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:00.640+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis work\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:02.243+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:01.977+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:01.737+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works wel\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:01.555+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works we\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:03.012+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:02.536+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:02.456+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well fo\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:02.292+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well f\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:03.483+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fast\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:03.344+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fas\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:03.216+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fa\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:03.145+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for f\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:04.422+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-fi\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:04.350+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-f\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:04.240+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:04.068+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:04.925+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:04.765+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:04.717+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-file\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:04.459+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-fil\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:05.300+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:05.239+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files tha\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:05.143+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files th\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:05.026+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:05.948+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that hav\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:05.791+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that ha\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:05.671+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that h\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:05.626+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:06.547+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have le\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:06.319+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have l\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:06.202+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:05.989+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:08.177+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less t\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:07.230+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:06.795+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:06.697+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have les\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:10.660+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:08.465+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:08.295+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less tha\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:08.186+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less th\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:11.686+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 e\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:11.590+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:11.123+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:10.826+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 5\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:12.244+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 entri\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:12.104+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 entr\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:12.008+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 ent\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:11.811+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 en\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:12.782+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 entries \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:12.644+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 entries \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:12.555+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 entries\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:12.425+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 entrie\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:15.606+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 entrie\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:15.578+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 entries\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:15.545+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 entries \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:15.046+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 entries (\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:15.728+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 en\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:15.700+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 ent\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:15.667+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 entr\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:15.639+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 entri\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:17.346+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:17.184+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 s\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:16.726+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:16.067+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 e\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:17.938+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 data\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:17.686+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 dat\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:17.536+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 da\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:17.431+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 d\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:18.396+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 dataset\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:18.232+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datase\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:18.129+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datas\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:19.980+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:18.715+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:18.599+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:18.582+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:21.364+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 2\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:21.176+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:20.372+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:20.094+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (s\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:21.992+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 l\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:21.905+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:21.740+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:21.423+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 22\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:22.499+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:22.367+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 line\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:22.186+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lin\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:22.141+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 li\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:24.407+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines)\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:24.187+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines).\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:23.004+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines)\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:22.558+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:24.896+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:24.744+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), a\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:24.669+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:24.566+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines),\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:25.692+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at lea\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:25.366+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at le\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:25.218+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at l\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:25.101+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:26.432+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:26.264+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at leas\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:26.148+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at leas \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:25.700+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at leas\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:27.247+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least a\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:27.142+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:27.028+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least i\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:26.677+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:27.852+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:27.710+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at m\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:27.546+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:27.364+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:28.361+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my com\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:28.305+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my co\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:28.148+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my c\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:28.067+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:28.752+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my comput\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:28.690+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my compu\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:28.580+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my comp\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:29.922+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:29.648+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:29.012+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:28.871+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my compute\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:37.634+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:37.478+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:37.370+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:36.951+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:38.418+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB o\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:38.324+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:38.111+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:37.864+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 G\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:38.914+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of me\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:38.803+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of m\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:38.726+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:38.537+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:39.509+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of menmor\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:39.166+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of menmo\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:39.072+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of menm\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:38.922+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of men\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:40.195+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of me\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:39.999+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of men\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:39.833+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of menm\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:39.666+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of menmo\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:40.792+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:40.595+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memor\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:40.367+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memo\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:40.267+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of mem\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:45.650+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:41.448+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory)\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:40.922+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:50.512+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:50.593+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:57:50.680+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:06.571+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory).\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:06.578+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory).\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:06.772+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:07.883+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). I\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:08.033+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:08.567+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory).\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:08.626+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:08.827+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:09.105+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). I\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:09.356+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). I \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:09.460+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). I s\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:09.570+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). I st\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:09.734+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). I sti\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:09.815+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). I stic\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:10.213+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). I stick\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:10.395+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). I stic\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:10.561+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). I sti\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:10.727+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). I st\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:12.332+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). I \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:12.489+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). I\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:10.885+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). I s\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:12.819+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:13.310+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:13.593+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). I\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:13.934+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It w\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:13.711+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:14.193+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It wor\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:13.876+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:14.105+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It wo\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:14.814+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works pe\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:14.728+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works p\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:14.667+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works \n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:14.458+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:14.333+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It work\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T15:01:22.189+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\n    D na5String seq;\n    CharString id;\n    CharString qual;\n\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T15:01:21.520+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\n    D na5String seq;\n    CharString id;\n    CharString qual;\n\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T15:01:21.332+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\n    D na5String seq;\n    CharString id;\n    CharString qual;\n\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T15:01:20.527+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\n   D na5String seq;\n    CharString id;\n    CharString qual;\n\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T15:01:19.312+02:00	READY	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T15:01:15.037+02:00	UNLOAD	http://trac.seqan.de/wiki/Tutorial/ReadingSequenceFiles#RecordReadingAPI	193.52.161.170	-	0	0	1353	639
2012-07-02T15:01:13.223+02:00	READY	http://trac.seqan.de/wiki/Tutorial/ReadingSequenceFiles#RecordReadingAPI	193.52.161.170	-	0	0	1353	639
2012-07-02T15:01:09.620+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\n   Dna5String seq;\n    CharString id;\n    CharString qual;\n\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T15:01:09.798+02:00	UNLOAD	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:15.864+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectl\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:15.653+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfect\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:15.557+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfec\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:15.375+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfe\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:15.130+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perf\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T14:58:15.027+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works per\n\n{{{#!c\n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n    int i = 0;\n    sets = 0;\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T15:02:05.660+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	57	1353	639
2012-07-02T15:02:05.080+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	57	1353	639
2012-07-02T15:02:01.607+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	57	1353	639
2012-07-02T15:01:25.402+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\n    Dna5String seq;\n    CharString id;\n    CharString qual;\n\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T15:01:24.686+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\n    Dna5String seq;\n    CharString id;\n    CharString qual;\n\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	0	1353	639
2012-07-02T15:04:57.506+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\n    Dna5String seq;\n    CharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:04:57.986+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\n    Dna5String seq;\n    CharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:04:58.215+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:04:48.865+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	698	1353	639
2012-07-02T15:04:46.076+02:00	READY	http://trac.seqan.de/newticket	193.52.161.170	-	0	641	1353	639
2012-07-02T15:04:37.548+02:00	UNLOAD	http://trac.seqan.de/newticket	193.52.161.170	-	0	241	1353	639
2012-07-02T15:04:22.646+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	57	1353	639
2012-07-02T15:04:59.682+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\n    CharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:04:59.508+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\n    CharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:04:59.238+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\n    CharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:04:59.000+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\n    CharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:04:58.307+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\n    Dna5String seq;\n    CharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:00.852+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\n    CharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:00.431+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\n    CharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:00.120+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\n    CharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:04:59.848+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\n    CharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:01.882+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:01.731+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:01.518+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:01.314+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:02.994+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:02.679+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:02.368+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:02.048+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\n    CharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:04.242+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:04.045+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:03.751+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:03.548+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:25.403+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:32.721+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:04.558+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:04.416+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:10.683+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:35.944+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:09.243+02:00	TYPING-field-cc-Checkou	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:28.639+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n  cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:08.246+02:00	TYPING-field-cc-C	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:06:18.565+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:37.418+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:30.694+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n  cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:36.571+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:06.098+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:32.381+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:15.165+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:08.065+02:00	TYPING-field-cc-	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:24.685+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:07.880+02:00	TYPING-field-cc-	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:13.737+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:10.253+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:35.398+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:08:07.733+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:10.096+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:14.230+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:21.243+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:30.247+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n  cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:24.187+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:39.208+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:39.835+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:33.896+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:32.277+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:05.345+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:07.399+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:20.791+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:08.754+02:00	TYPING-field-cc-Check	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:08.148+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:23.855+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:11.949+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:17.556+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:34.268+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:21.053+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:17.198+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:08.547+02:00	TYPING-field-cc-Chec	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:38.384+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:27.109+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n  cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:38.052+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:32.078+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:14.397+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:21.417+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:32.871+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:30.555+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n  cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:13.595+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:08.869+02:00	TYPING-field-cc-Checko	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:06.382+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:09.353+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:32.555+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:20.720+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:30.893+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n   cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:29.736+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n  cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:10.704+02:00	TYPING-field-cc-Checkout vo	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:24.487+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:11.747+02:00	TYPING-field-cc-Checkout vo	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:08:04.508+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:35.604+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:08.243+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:17.914+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:37.647+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:38.869+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:31.417+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:13.223+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:38.552+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:22.408+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:27.275+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n  cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:33.401+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:04.830+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:27.433+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n  cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:10.857+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:10.279+02:00	TYPING-field-cc-Checkout f	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:38.694+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:05.887+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:22.670+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\nif (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:26.484+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n  cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:34.659+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:18.806+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:09.419+02:00	TYPING-field-cc-Checkout	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:28.917+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n  cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:39.034+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:08.750+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:15.777+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:26.619+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n  cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:16.119+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:06.564+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:26.777+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n  cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:31.623+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:06.232+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:15.499+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:10.538+02:00	TYPING-field-cc-Checkout v	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:24.337+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:09.631+02:00	TYPING-field-cc-Checkout 	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:35.778+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:12.537+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:19.704+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:08.425+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:29.967+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n  cerr << "ERROR reading FASTQ" << endl;\n   return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:26.943+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n  cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:19.395+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:14.777+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:11.408+02:00	TYPING-field-cc-Checkout vom	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:25.844+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:08:08.669+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:09:08.332+02:00	TYPING-field-cc-Ch	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:34.102+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:14.975+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:37.139+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:10.411+02:00	TYPING-field-cc-Checkout 	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:24.021+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:35.320+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:23.556+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:35.113+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:23.387+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:14.065+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:24.979+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:31.020+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:13.421+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:37.822+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:22.932+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:22.188+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:06.715+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:14.595+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:18.272+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:05.110+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \n    ifstream fastq(argv[1], ios_base::in | ios_base::binary);\n    if (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:16.752+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:23.681+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:07.211+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:09:08.411+02:00	TYPING-field-cc-Che	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:08.585+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:10.612+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:11.023+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:05:08.021+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\n    RecordReader<ifstream, SinglePass<> > reader(fastq);\n\n    while (!atEnd(reader)) {\n      if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n        cerr << "ERROR reading FASTQ" << endl;\n        return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:22.975+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:05:30.365+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n  cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n      }\n      //... some processing\n    }\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	639
2012-07-02T15:09:12.177+02:00	TYPING-field-cc-Checkout v	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:37:24.175+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	926	1353	639
2012-07-02T15:37:29.637+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	356	1353	639
2012-07-02T15:38:19.875+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	413	1353	639
2012-07-02T15:38:23.004+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	413	1353	639
2012-07-02T15:42:22.902+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	413	1353	639
2012-07-02T15:42:23.452+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	413	1353	639
2012-07-02T15:52:56.357+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	413	1353	639
2012-07-02T15:52:58.010+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	413	1353	639
2012-07-02T15:55:05.593+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	413	1353	639
2012-07-02T15:55:06.499+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	413	1353	639
2012-07-02T15:55:28.536+02:00	READY	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1881	1353	639
2012-07-02T15:55:33.562+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	2166	1353	639
2012-07-02T15:55:40.781+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	2166	1353	639
2012-07-02T15:55:51.445+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1824	1353	639
2012-07-02T15:57:36.794+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1311	1353	639
2012-07-02T15:58:30.928+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1368	1353	639
2012-07-02T15:58:34.066+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1482	1353	639
2012-07-02T15:58:54.737+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1938	1353	639
2012-07-02T15:59:05.693+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1938	1353	639
2012-07-02T15:59:09.351+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	2052	1353	639
2012-07-02T16:00:17.640+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	2052	1353	639
2012-07-02T16:00:21.382+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	2052	1353	639
2012-07-02T16:00:25.315+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1938	1353	639
2012-07-02T16:01:05.962+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1938	1353	639
2012-07-02T16:05:56.777+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1938	1353	639
2012-07-02T16:05:57.773+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1938	1353	639
2012-07-02T16:22:58.836+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1938	1353	675
2012-07-02T16:23:00.305+02:00	RESIZE	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1938	1353	675
2012-07-02T16:23:00.394+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1938	1353	675
2012-07-02T17:02:47.136+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1938	1353	675
2012-07-02T17:02:49.019+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1938	1353	675
2012-07-02T17:07:13.764+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1938	1353	675
2012-07-02T17:07:16.739+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	2223	1353	675
2012-07-02T17:07:21.300+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1824	1353	675
2012-07-02T17:07:22.325+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1824	1353	675
2012-07-02T17:07:37.770+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	2052	1353	675
2012-07-02T17:07:50.047+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	2052	1353	675
2012-07-02T17:07:53.158+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	2109	1353	675
2012-07-02T17:07:53.815+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	2109	1353	675
2012-07-02T17:12:01.343+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	2109	1353	675
2012-07-02T17:12:01.570+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	2109	1353	675
2012-07-02T17:12:01.580+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	413	1353	675
2012-07-02T17:12:03.103+02:00	RESIZE	http://trac.seqan.de/newticket	193.52.161.170	-	0	413	1353	675
2012-07-02T17:12:06.474+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	755	1353	675
2012-07-02T17:12:12.039+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	755	1353	675
2012-07-02T17:14:51.907+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	755	1353	675
2012-07-02T17:14:55.200+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:14:55.587+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:14:56.049+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:14:56.453+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:14:56.650+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\n{	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:14:56.848+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\n{{	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:14:57.136+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\n{{{	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:14:57.984+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\n{{{\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:14:58.137+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\n{{{\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:00.390+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\n{{{\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:00.527+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\n{{{\n\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:04.373+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:05.030+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:05.154+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:05.376+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:05.673+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:13.643+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:13.810+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:13.891+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\n\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:14.650+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nT\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:14.753+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nTh\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:14.896+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:15.084+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:14.284+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\n\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:15.603+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fast\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:15.461+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fas\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:15.312+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fa\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:15.250+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe f\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:16.604+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-en\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:16.406+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-e\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:16.151+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:15.728+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:18.189+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entr\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:17.853+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-ent\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:17.394+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entr\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:16.834+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-ent\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:18.747+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:18.986+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:20.300+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:20.893+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:21.082+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. R\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:21.444+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. Re\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:21.608+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. R\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:22.635+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:22.935+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. y\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:23.107+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. y\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:23.246+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:23.373+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. Y\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:23.523+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. Yo\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:23.811+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:24.333+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:24.444+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You c\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:24.483+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You ca\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:24.715+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:24.886+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:24.981+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can r\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:25.106+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can re\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:25.243+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can rep\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:25.525+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repe\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:25.876+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repea\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:26.077+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:26.260+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:26.374+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat i\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:26.479+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:26.642+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:26.738+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it f\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:26.855+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it fo\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:26.959+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:27.370+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:27.862+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for exa\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:27.615+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for e\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:28.199+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for exampl\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:28.075+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for examp\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:27.781+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for ex\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:27.982+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for exam\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:28.898+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:28.719+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:31.648+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 5\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:30.403+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 1\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:31.615+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:36.542+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 50\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:36.732+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 5\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:38.200+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:38.709+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 5\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:39.030+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:39.194+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55 \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:39.281+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55 t\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:39.391+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55 ti\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:39.492+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55 tim\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:39.728+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55 time\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:39.855+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55 times\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:40.024+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55 times,\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:40.119+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55 times, \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:41.428+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55 times\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:41.368+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55 times, \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:41.402+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55 times,\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:40.868+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55 times, t\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:41.551+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55 t\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:41.518+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55 ti\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:41.490+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55 tim\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:41.462+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55 time\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:43.582+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:42.014+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 5\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:41.834+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:41.579+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 55 \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:44.323+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 tim\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:44.152+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 ti\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:43.993+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 t\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:43.818+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:45.240+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times,\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:45.057+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:44.561+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 time\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:46.248+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, the\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:46.136+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, th\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:45.971+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, t\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:45.900+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:48.241+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:48.136+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then i\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:47.931+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:46.502+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:48.703+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it wor\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:48.577+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it wo\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:48.477+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it w\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:48.363+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:49.374+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:49.187+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:48.964+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:48.867+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it work\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:50.025+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. re\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:49.947+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. rep\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:49.597+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. re\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:49.460+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. r\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:50.535+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. R\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:50.404+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:50.286+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. r\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:50.127+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. re\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:51.366+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repea\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:51.127+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repe\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:50.874+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Rep\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:50.607+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Re\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:51.809+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:51.674+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeatin\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:51.596+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeati\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:51.478+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeat\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:52.974+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:52.168+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:52.060+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating i\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:51.949+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:53.504+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 t\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:53.424+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:53.269+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:53.180+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 5\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:53.938+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:53.855+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 time\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:53.659+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 tim\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:53.598+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 ti\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:56.249+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times tho\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:56.171+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times th\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:56.076+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times t\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:56.005+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:57.226+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times th\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:57.173+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times tho\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:56.999+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times thor\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:57.851+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:57.722+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throw\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:57.509+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times thro\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:57.392+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times thr\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:58.368+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws the\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:58.258+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws th\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:58.118+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws t\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:58.063+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:59.235+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws the r\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:59.062+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws the rr\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:58.861+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws the r\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:58.638+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws the \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:59.722+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws the err\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:59.603+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws the er\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:59.412+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws the e\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:59.271+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws the \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:00.315+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws the error\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:15:59.832+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws the erro\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:04.901+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws the error\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:05.403+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws the erro\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:05.436+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws the err\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:05.557+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws the\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:05.495+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws the e\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:05.524+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws the \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:05.463+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws the er\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:05.676+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:05.646+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:05.615+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws t\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:05.586+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throws th\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:05.799+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times th\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:05.767+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times thr\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:05.740+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times thro\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:05.707+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times throw\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:05.827+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times t\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:08.546+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:09.234+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times m\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:12.070+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:12.104+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times m\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:12.275+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times ma\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:12.329+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times mak\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:12.861+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times make\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:13.294+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times makes\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:13.539+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times makes \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:13.649+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times makes i\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:13.809+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times makes it\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:18.945+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times makes \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:18.914+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times makes i\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:18.498+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times makes it \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:18.884+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times makes it\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:19.066+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times ma\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:19.036+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times mak\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:19.006+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times make\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:18.975+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times makes\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:19.655+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times fo\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:19.522+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times f\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:19.394+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:19.095+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times m\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:20.607+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forc\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:20.532+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times for\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:20.431+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times fore\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:20.028+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times for\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:21.520+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces t\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:21.456+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:21.302+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:21.044+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times force\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:21.963+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:21.778+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:21.645+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces th\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:22.322+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the prog\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:22.252+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the pro\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:22.032+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the p\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:22.158+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the pr\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:23.251+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the programm\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:22.715+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:22.534+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the progra\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:22.390+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the progr\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:24.123+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:23.917+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program t\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:23.861+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:23.593+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:25.731+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to thr\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:25.579+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to th\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:25.430+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to t\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:25.351+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:26.563+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw t\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:26.491+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:26.296+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:25.918+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to thro\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:27.513+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the e\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:27.338+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:26.837+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:26.695+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw th\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:28.515+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:28.108+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the erro\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:27.991+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the err\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:27.703+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the er\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:29.200+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error mes\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:29.002+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error me\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:28.761+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error m\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:28.750+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:29.628+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:29.547+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error messag\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:29.303+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error mess\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:29.469+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error messa\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:30.578+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (E\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:30.395+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:29.871+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:29.733+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:31.724+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:31.452+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERRO\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:30.920+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERR\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:30.800+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ER\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:32.411+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR rea\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:32.323+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR re\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:32.222+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR r\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:32.104+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:32.884+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:32.710+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR readin\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:32.607+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR readi\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:32.535+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR read\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:33.219+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FA\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:33.156+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading F\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:33.046+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:32.926+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:35.111+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ)\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:34.311+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:33.534+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FAST\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:33.432+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FAS\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:35.395+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:35.278+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ)\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:35.236+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ)\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:35.956+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:35.928+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:35.895+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:36.079+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:36.051+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:36.017+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:35.989+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:36.139+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:36.110+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:36.259+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:36.229+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:36.199+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:36.169+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:36.379+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:36.353+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:36.319+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:36.290+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:36.411+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:36.440+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:37.437+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:36.848+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:36.767+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message (ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:45.046+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ").\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:44.881+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ").\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:44.744+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ").\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:38.277+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ")\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:45.401+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBeloThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ").\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:45.332+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ").\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:45.143+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBeThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ").\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:47.196+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ").\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:46.244+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow he fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ").\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:46.113+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow The fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ").\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:45.753+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelowThe fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ").\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:49.362+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:49.198+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ").\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:49.042+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ").\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:48.244+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ").\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:50.170+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:49.758+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:49.630+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). Bu\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:49.528+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). B\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:50.858+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:50.432+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:50.305+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But i\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:51.382+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:51.167+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it als\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:50.972+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it a\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:51.071+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it al\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:52.318+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also cra\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:52.179+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also cr\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:51.975+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also c\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:51.625+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:53.054+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also cras\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:52.926+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also cra\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:52.828+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crah\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:53.884+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:53.594+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:53.480+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashe\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:53.148+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crash\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:54.408+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:54.169+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes wit\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:54.098+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes wi\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:53.973+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes w\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:59.461+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with ori\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:58.681+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with or\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:58.490+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with o\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:58.333+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:00.199+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with origina\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:00.006+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with origin\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:59.850+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with origi\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:16:59.661+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with orig\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:00.823+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fd\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:00.746+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original f\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:00.737+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:00.422+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:01.552+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fd\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:01.370+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fda\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:01.196+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fdas\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:00.884+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fda\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:03.286+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fast\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:03.167+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fas\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:02.970+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fa\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:02.899+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original f\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:04.360+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq-f\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:04.243+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq-\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:04.126+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:04.650+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq-fiel\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:04.464+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq-fie\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:04.447+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq-fi\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:05.131+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq-fiels\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:05.313+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq-fiel\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:05.495+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq-fie\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:05.748+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq-fi\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:05.793+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq-fil\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:06.005+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq-file\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:06.263+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq-files\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:06.764+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq-file\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:06.797+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq-fil\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:06.882+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq-\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:06.856+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq-f\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:06.822+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq-fi\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:07.004+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fa\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:06.977+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fas\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:06.943+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fast\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:06.914+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original fastq\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:07.128+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with origina\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:07.094+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:07.070+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:07.036+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with original f\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:07.246+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with ori\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:07.216+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with orig\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:07.188+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with origi\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:07.156+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with origin\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:08.039+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with oth\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:07.953+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with ot\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:07.826+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with o\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:07.279+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with or\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:08.352+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:08.214+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:08.142+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with othe\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:08.792+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fast\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:08.682+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fas\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:08.540+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fa\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:08.470+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other f\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:09.283+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-fi\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:09.180+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-f\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:09.092+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:08.981+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:09.589+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:09.507+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-file\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:09.321+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-fil\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:26.812+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong.\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:26.931+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:27.207+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong \n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:27.558+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong o\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:27.576+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong \n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:27.802+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong \n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:28.016+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:28.567+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or \n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:28.301+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:28.132+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (o\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:29.283+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:29.171+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or wha\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:29.051+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or wh\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:28.879+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or w\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:30.037+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what \n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:29.898+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what i\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:29.892+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what i\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:29.455+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what \n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:30.715+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I mi\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:30.614+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I m\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:30.455+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I \n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:30.236+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:31.362+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missun\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:31.142+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missu\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:31.054+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I miss\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:30.912+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I mis\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:31.860+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunders\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:31.733+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunder\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:31.623+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunde\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:31.465+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missund\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:32.409+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:32.343+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstoo\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:32.264+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missundersto\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:32.010+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderst\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:32.721+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood)\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:32.475+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:43.200+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood).\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:43.218+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood).\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:43.436+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). \n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:43.867+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:43.877+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I \n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:43.959+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I c\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:44.091+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I co\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:44.284+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I cou\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:44.440+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I coul\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:44.825+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I could\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:44.833+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I could\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:45.299+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldN\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:45.467+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I could\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:45.510+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I could\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:45.693+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldN\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:45.888+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldN'\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:46.193+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldN't\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:46.351+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldN'\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:46.517+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldN\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:46.689+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I could\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:46.768+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:46.895+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:47.114+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn'\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:47.550+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't \n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:47.614+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't f\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:47.291+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:48.198+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find \n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:48.160+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:47.785+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't fin\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:47.724+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't fi\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:49.028+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any \n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:48.801+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:48.647+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find an\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:48.309+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find a\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:49.894+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any fu\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:49.786+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any f\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:49.680+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any \n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:49.541+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any e\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:50.477+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any furthe\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:50.391+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any furth\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:50.121+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any furt\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:50.083+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any fur\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:51.287+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further ex\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:51.174+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further e\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:50.944+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further \n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:50.669+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:51.787+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explan\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:51.636+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further expla\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:51.480+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further expl\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:51.389+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further exp\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:18:09.857+02:00	UNLOAD	http://trac.seqan.de/newticket	193.52.161.170	-	0	1001	1353	675
2012-07-02T17:17:52.003+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanat\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:17:51.931+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explana\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	869	1353	675
2012-07-02T17:18:13.448+02:00	READY	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:18:15.146+02:00	TYPING-field-cc-Checkout 2012-03-14	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:18:20.063+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:18:59.349+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:19:14.200+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:19:28.337+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:19:28.725+02:00	TYPING-field-cc-Checkout 	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:19:28.882+02:00	TYPING-field-cc-Checkout 	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:19:29.116+02:00	TYPING-field-cc-R	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:19:29.490+02:00	TYPING-field-cc-Re	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:19:30.341+02:00	TYPING-field-cc-Revisi	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:19:30.221+02:00	TYPING-field-cc-Revis	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:19:29.985+02:00	TYPING-field-cc-Rev	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:19:30.078+02:00	TYPING-field-cc-Revi	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:19:30.578+02:00	TYPING-field-cc-Revisio	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:19:33.348+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:19:36.698+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:19:37.201+02:00	TYPING-field-cc-Revision	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:19:41.762+02:00	TYPING-field-summary-	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:41.900+02:00	TYPING-field-summary-	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:42.057+02:00	TYPING-field-summary-F	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:42.491+02:00	TYPING-field-summary-Fast	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:42.172+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:42.159+02:00	TYPING-field-summary-Fa	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:42.384+02:00	TYPING-field-summary-Fas	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:43.700+02:00	TYPING-field-summary-Fastq-f	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:43.606+02:00	TYPING-field-summary-Fastq-	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:43.480+02:00	TYPING-field-summary-Fastq	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:42.671+02:00	TYPING-field-summary-Fastq	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:44.579+02:00	TYPING-field-summary-Fastq-file 	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:44.384+02:00	TYPING-field-summary-Fastq-file	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:43.850+02:00	TYPING-field-summary-Fastq-fil	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:43.788+02:00	TYPING-field-summary-Fastq-fi	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:45.302+02:00	TYPING-field-summary-Fastq-file read	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:44.918+02:00	TYPING-field-summary-Fastq-file rea	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:44.791+02:00	TYPING-field-summary-Fastq-file re	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:44.690+02:00	TYPING-field-summary-Fastq-file r	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:47.075+02:00	TYPING-field-summary-Fastq-file 	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:45.832+02:00	TYPING-field-summary-Fastq-file r	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:45.658+02:00	TYPING-field-summary-Fastq-file re	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:45.484+02:00	TYPING-field-summary-Fastq-file rea	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:47.565+02:00	TYPING-field-summary-Fastq-file read	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:47.417+02:00	TYPING-field-summary-Fastq-file rea	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:47.287+02:00	TYPING-field-summary-Fastq-file re	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:47.194+02:00	TYPING-field-summary-Fastq-file r	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:48.450+02:00	TYPING-field-summary-Fastq-file reading	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:48.243+02:00	TYPING-field-summary-Fastq-file reading	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:47.768+02:00	TYPING-field-summary-Fastq-file readin	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:47.651+02:00	TYPING-field-summary-Fastq-file readi	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:48.988+02:00	TYPING-field-summary-Re	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:48.807+02:00	TYPING-field-summary-R	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:19:48.685+02:00	TYPING-field-summary-Fastq-file reading	http://trac.seqan.de/newticket	193.52.161.170	-	0	965	1353	675
2012-07-02T17:20:05.228+02:00	READY	http://trac.seqan.de/newticket	193.52.161.170	-	0	73	1353	675
2012-07-02T17:20:02.370+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:20:02.402+02:00	UNLOAD	http://trac.seqan.de/newticket	193.52.161.170	-	0	1136	1353	675
2012-07-02T17:20:09.610+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	301	1353	675
2012-07-02T17:20:15.716+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	358	1353	675
2012-07-02T17:20:31.422+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	415	1353	675
2012-07-02T17:20:39.067+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	757	1353	675
2012-07-02T17:20:56.459+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	301	1353	675
2012-07-02T17:20:58.866+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	358	1353	675
2012-07-02T17:21:10.955+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:13.169+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:13.319+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory,). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:15.780+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, ). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:16.662+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, ). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:17.279+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubu). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:16.859+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, U). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:17.017+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ub). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:18.215+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubunu). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:18.018+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubun). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:17.899+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubu). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:17.679+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubut). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:19.914+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:18.318+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubunut). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:35.065+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:38.329+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubunutu). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:38.496+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubunutu). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:39.232+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubuntu). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:38.849+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubunutu). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:40.352+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubuntu). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:40.123+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubuntu). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:39.635+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubuntu). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:39.462+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubuntu). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:45.070+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubuntu 11 x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:44.838+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubuntu 1 x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:44.615+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubuntu  x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:44.454+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubuntu x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:46.414+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubuntu 11.1 x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:46.210+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubuntu 11.12 x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:45.273+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubuntu 11.1 x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:45.187+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubuntu 11. x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:48.560+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubuntu  x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:47.506+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubuntu 1 x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:47.324+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubuntu 11 x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:46.582+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubuntu 11. x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:49.258+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubu x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:49.082+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubun x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:48.926+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubunt x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:48.742+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ubuntu x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:50.490+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:50.042+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory,  x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:49.596+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, U x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:49.430+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, Ub x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:52.441+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:52.282+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:51.733+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:51.136+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory,x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:53.614+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:52.946+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:52.780+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:52.607+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:58.520+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, 3.). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:57.353+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, 3). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:57.081+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, ). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:53.782+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64,). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:59.143+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, L). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:58.930+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, ). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:58.712+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, ). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:58.670+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, 3). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:59.928+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:59.504+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linu). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:59.387+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Lin). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:21:59.333+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Li). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:01.312+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:00.906+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:00.235+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:00.068+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux ). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:02.750+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-1). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:02.683+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:02.541+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:02.214+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:04.463+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-ge). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:04.225+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-g). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:04.098+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:03.878+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:05.166+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generi). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:04.986+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-gener). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:04.834+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-gene). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:04.652+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-gen). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:29.728+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	757	1353	675
2012-07-02T17:22:23.897+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	757	1353	675
2012-07-02T17:22:19.201+02:00	FOCUS	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:11.312+02:00	BLUR	http://trac.seqan.de/newticket	193.52.161.170	-	0	700	1353	675
2012-07-02T17:22:31.462+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. \nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	757	1353	675
2012-07-02T17:22:31.263+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. \nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	757	1353	675
2012-07-02T17:22:31.221+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	757	1353	675
2012-07-02T17:22:30.871+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass.\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	757	1353	675
2012-07-02T17:23:11.064+02:00	UNLOAD	http://trac.seqan.de/newticket	193.52.161.170	-	0	985	1353	675
2012-07-02T17:22:32.039+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. Seq\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	757	1353	675
2012-07-02T17:22:31.778+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. Se\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	757	1353	675
2012-07-02T17:22:31.668+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. S\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	757	1353	675
2012-07-02T17:23:14.508+02:00	READY	http://trac.seqan.de/newticket	193.52.161.170	-	0	318	1353	675
2012-07-02T17:23:43.886+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:47.536+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. Seqan is the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:47.827+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. Seqan is the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:48.040+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. ISeqan is the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:48.605+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I useSeqan is the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:48.494+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I usSeqan is the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:48.323+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I uSeqan is the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:48.251+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I Seqan is the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:49.101+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used thSeqan is the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:48.968+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used tSeqan is the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:48.866+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used Seqan is the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:48.731+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I usedSeqan is the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:50.538+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used thean is the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:50.372+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used theqan is the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:50.206+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used theeqan is the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:50.016+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used theSeqan is the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:51.194+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used thes the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:51.036+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used theis the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:50.926+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the is the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:50.696+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used then is the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:53.215+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:52.717+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:51.901+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used thethe current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:51.372+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:53.336+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:53.306+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:53.275+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:23:53.248+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:24:17.404+02:00	READY	http://trac.seqan.de/newticket	193.52.161.170	-	0	57	1353	675
2012-07-02T17:24:13.802+02:00	UNLOAD	http://trac.seqan.de/newticket	193.52.161.170	-	0	1108	1353	675
2012-07-02T17:24:13.708+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	1108	1353	675
2012-07-02T17:23:53.368+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision in SVN (12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	831	1353	675
2012-07-02T17:24:21.054+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	342	1353	675
2012-07-02T17:24:34.169+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	969	1353	675
2012-07-02T17:24:38.490+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	342	1353	675
2012-07-02T17:24:43.603+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	513	1353	675
2012-07-02T17:24:46.564+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	570	1353	675
2012-07-02T17:24:55.991+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	912	1353	675
2012-07-02T17:25:02.072+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	912	1353	675
2012-07-02T17:25:02.956+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DouPass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	912	1353	675
2012-07-02T17:25:02.559+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DPass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	912	1353	675
2012-07-02T17:25:03.145+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoubPass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	912	1353	675
2012-07-02T17:25:02.677+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoPass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	912	1353	675
2012-07-02T17:25:02.234+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, SinglePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	912	1353	675
2012-07-02T17:25:07.037+02:00	UNLOAD	http://trac.seqan.de/newticket	193.52.161.170	-	0	1026	1353	675
2012-07-02T17:25:03.248+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublPass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	912	1353	675
2012-07-02T17:25:12.946+02:00	READY	http://trac.seqan.de/newticket	193.52.161.170	-	0	603	1353	675
2012-07-02T17:25:20.449+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	489	1353	675
2012-07-02T17:25:24.185+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	546	1353	675
2012-07-02T17:25:28.132+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	318	1353	675
2012-07-02T17:25:34.300+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:48.964+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:49.058+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic).  It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:49.584+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:49.471+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). Bu It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:49.172+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic).  It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:49.338+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). B It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:52.271+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if  It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:51.554+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:51.401+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But i It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:51.028+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But  It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:53.006+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the  It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:52.571+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:52.481+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if th It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:52.326+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if t It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:53.440+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:53.258+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the fil It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:53.196+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the fi It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:53.086+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the f It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:54.344+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:54.168+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file ha It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:54.102+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file h It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:53.996+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file  It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:54.894+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has mor It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:54.786+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has mo It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:54.683+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has m It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:54.564+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has  It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:55.575+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more en It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:55.488+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more e It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:55.337+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more  It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:55.102+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:56.221+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entrie It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:55.983+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entri It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:55.843+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entr It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:55.748+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more ent It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:57.564+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries th It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:57.442+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries t It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:57.354+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries  It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:57.190+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:59.671+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 5 It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:59.434+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than  It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:57.903+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:25:57.684+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries tha It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:05.815+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, i It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:05.769+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54,  It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:05.605+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:05.454+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54 It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:07.437+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it cr It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:07.265+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it c It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:07.138+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it  It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:05.975+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:10.286+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it  It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:08.371+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it c It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:08.205+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it cr It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:08.055+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it cra It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:11.699+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it c It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:12.006+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it  It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:11.525+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it cr It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:10.837+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it c It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:12.978+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it says It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:12.760+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it say It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:12.498+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it sa It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:12.132+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it s It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:13.403+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it says tha It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:13.326+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it says th It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:13.254+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it says t It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:13.109+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it says  It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:14.608+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it says that  It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:14.283+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it says that i It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:13.668+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it says that  It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:26:13.512+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it says that It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:27:28.172+02:00	READY	http://trac.seqan.de/newticket	193.52.161.170	-	0	449	1353	675
2012-07-02T17:27:23.828+02:00	UNLOAD	http://trac.seqan.de/newticket	193.52.161.170	-	0	1108	1353	675
2012-07-02T17:27:23.571+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	1108	1353	675
2012-07-02T17:26:14.717+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it says that i It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	1059	1353	675
2012-07-02T17:27:40.951+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	905	1353	675
2012-07-02T17:27:46.370+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I used the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	905	1353	675
2012-07-02T17:27:52.058+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	620	1353	675
2012-07-02T17:28:04.149+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:07.180+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:07.678+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files w\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:07.565+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:07.913+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files wit\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:07.842+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files wi\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:08.380+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with m\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:08.292+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:07.458+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:08.128+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:08.914+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:08.727+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:08.613+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with mor\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:08.432+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with mo\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:09.404+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:09.244+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more tha\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:09.124+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more th\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:09.032+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more t\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:10.386+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than 54 \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:10.208+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than 54\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:10.023+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than 5\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:09.931+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than \n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:10.884+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than 54 entr\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:10.773+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than 54 ent\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:10.592+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than 54 en\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:10.528+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than 54 e\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:25.303+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than 54 entries.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:11.279+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than 54 entries\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:11.231+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than 54 entrie\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:10.995+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory. Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than 54 entri\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:26.301+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than 54 entries.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:26.097+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memoryTherefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than 54 entries.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:25.869+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memoryTherefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than 54 entries.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:25.492+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory.Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than 54 entries.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:50.585+02:00	UNLOAD	http://trac.seqan.de/newticket	193.52.161.170	-	0	1125	1353	675
2012-07-02T17:28:27.217+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory (ITherefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than 54 entries.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:26.985+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory (Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than 54 entries.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:26.895+02:00	TYPING-field-description-Hello Seqan-Team,\n\nI want to read a fastq-file to process it and don't want to store the entries in memory (Therefore I stick with the RecordReader as it was proposed somewhere in the wiki. Additionally, in the docs it is mentioned that one uses DoublePass<> for best perfomance:\n\n"For FASTQ-Files a double-Pass implementation of RecordReader is implemented, which offers better performance. Just pass a Double-Pass reader object (only works with seekable Streams)."\n\nThis works well for fastq-files that have less than 55 datasets (so 220 lines), at least at my computer (4 GB of memory, x86_64, Linux 3.0.0-12-generic). But if the file has more entries than 54, it can't read the fastq-file (but it does up to the 54 datasets). It works perfectly with SinglePass, so I use that now. I just wanted to know what I am doing wrong (or what I missunderstood). I couldn't find any further explanation of the DoublePass. I use the the current revision of Seqan (svn revision 12235).\n\nThanks,\nOliver\n\nMy code snippet used for reading in the file:\n\n{{{#!c\nDna5String seq;\nCharString id;\nCharString qual;\n     \nifstream fastq(argv[1], ios_base::in | ios_base::binary);\nif (!fastq.good()) return 1;\nRecordReader<ifstream, DoublePass<> > reader(fastq);\n\nwhile (!atEnd(reader)) {\n  if (readRecord(id, seq, qual, reader, Fastq()) != 0) {\n    cerr << "ERROR reading FASTQ" << endl;\n    return 1;\n  }\n  //... some processing\n}\n}}}\n\nBelow the fastq-entry. You can repeat it for example 54 times, then it works. Repeating it 55 times forces the program to throw the error message ("ERROR reading FASTQ"). But it also crashes with other fastq-files with more than 54 entries.\n\n{{{\n@ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nAGGAGGTAAATCTATCTTGAGCNAGTNAGNTNNNNNNNNAGGCATTATNNNANCTGACTTCAANATATATAACACAGCTATAGNAATCANNANANCNTNN\n+ERR024163.1 EAS51_210:1:1:1072:4554 length=100\nEFFDEFFFFFDAEDBDFD?B@@!@C/!77!7!!!!!!!!6961=7AA;!!!<!AAB>=B?>?@!CAAAACBD5CBC?AEAA?A!#####!!#!#!#!#!!\n}}}	http://trac.seqan.de/newticket	193.52.161.170	-	0	962	1353	675
2012-07-02T17:28:57.195+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	221	1353	675
2012-07-02T17:28:54.711+02:00	READY	http://trac.seqan.de/newticket	193.52.161.170	-	0	164	1353	675
2012-07-02T17:29:12.522+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	335	1353	675
2012-07-02T17:29:19.116+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	506	1353	675
2012-07-02T17:29:28.912+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	506	1353	675
2012-07-02T17:29:38.908+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	848	1353	675
2012-07-02T17:29:46.965+02:00	SCROLL	http://trac.seqan.de/newticket	193.52.161.170	-	0	1125	1353	675
2012-07-02T17:29:52.262+02:00	UNLOAD	http://trac.seqan.de/newticket	193.52.161.170	-	0	1125	1353	675
2012-07-02T17:29:54.454+02:00	UNLOAD	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	0	0
2012-07-02T17:29:57.674+02:00	READY	http://trac.seqan.de/captcha	193.52.161.170	-	0	0	1366	675
2012-07-02T17:29:58.787+02:00	TYPING-captcha_response-c	http://trac.seqan.de/captcha	193.52.161.170	-	0	0	1366	675
2012-07-02T17:29:58.074+02:00	TYPING-captcha_response-	http://trac.seqan.de/captcha	193.52.161.170	-	0	0	1366	675
2012-07-02T17:29:59.686+02:00	TYPING-captcha_response-caqo	http://trac.seqan.de/captcha	193.52.161.170	-	0	0	1366	675
2012-07-02T17:29:59.458+02:00	TYPING-captcha_response-caq	http://trac.seqan.de/captcha	193.52.161.170	-	0	0	1366	675
2012-07-02T17:29:59.090+02:00	TYPING-captcha_response-ca	http://trac.seqan.de/captcha	193.52.161.170	-	0	0	1366	675
2012-07-02T17:29:59.887+02:00	TYPING-captcha_response-caqoq	http://trac.seqan.de/captcha	193.52.161.170	-	0	0	1366	675
2012-07-02T17:30:04.721+02:00	UNLOAD	http://trac.seqan.de/captcha	193.52.161.170	-	0	0	1366	675
2012-07-02T17:30:08.356+02:00	READY	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	0	1353	675
2012-07-02T17:30:10.940+02:00	BLUR	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	0	1353	675
2012-07-02T17:30:28.029+02:00	UNLOAD	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	2964	1353	675
2012-07-02T18:59:51.823+02:00	READY	http://trac.seqan.de/ticket/955	82.251.216.114	-	0	0	1353	624
2012-07-02T19:00:04.694+02:00	FOCUS	http://trac.seqan.de/ticket/955	82.251.216.114	-	0	0	1353	624
2012-07-02T19:00:07.263+02:00	UNLOAD	http://trac.seqan.de/ticket/955	82.251.216.114	-	0	128	1353	624
2012-07-02T19:00:11.548+02:00	READY	http://trac.seqan.de/ticket/955	82.251.216.114	-	0	1180	1353	624
2012-07-02T19:00:16.855+02:00	SCROLL	http://trac.seqan.de/ticket/955	82.251.216.114	-	0	0	1353	624
2012-07-02T19:00:33.712+02:00	LINK-http://trac.seqan.de/report	http://trac.seqan.de/ticket/955	82.251.216.114	-	0	57	1353	624
2012-07-02T19:00:34.191+02:00	UNLOAD	http://trac.seqan.de/ticket/955	82.251.216.114	-	0	57	1353	624
2012-07-02T19:00:51.900+02:00	READY	http://trac.seqan.de/report/1	82.251.216.114	-	0	171	1353	624
2012-07-02T19:00:56.231+02:00	SCROLL	http://trac.seqan.de/report/1	82.251.216.114	-	0	0	1353	624
2012-07-02T19:01:00.902+02:00	LINK-http://trac.seqan.de/ticket/280	http://trac.seqan.de/report/1	82.251.216.114	-	0	0	1353	624
2012-07-02T19:01:01.754+02:00	UNLOAD	http://trac.seqan.de/report/1	82.251.216.114	-	0	0	1353	624
2012-07-02T19:01:09.389+02:00	READY	http://trac.seqan.de/ticket/280	82.251.216.114	-	0	285	1353	624
2012-07-02T19:01:17.293+02:00	UNLOAD	http://trac.seqan.de/ticket/280	82.251.216.114	-	0	2736	1353	624
2012-07-02T19:01:29.165+02:00	READY	http://trac.seqan.de/report/1	82.251.216.114	-	0	399	1353	624
2012-07-02T19:01:37.265+02:00	BLUR	http://trac.seqan.de/report/1	82.251.216.114	-	0	570	1353	624
2012-07-02T19:01:34.895+02:00	SCROLL	http://trac.seqan.de/report/1	82.251.216.114	-	0	570	1353	624
2012-07-02T19:01:45.500+02:00	READY	http://trac.seqan.de/ticket/356	82.251.216.114	-	0	285	1353	624
2012-07-02T19:01:44.907+02:00	READY	http://trac.seqan.de/ticket/345	82.251.216.114	-	0	0	1353	624
2012-07-02T19:01:55.797+02:00	SCROLL	http://trac.seqan.de/ticket/356	82.251.216.114	-	0	627	1353	624
2012-07-02T19:01:58.531+02:00	BLUR	http://trac.seqan.de/ticket/356	82.251.216.114	-	0	627	1353	624
2012-07-02T19:01:58.541+02:00	FOCUS	http://trac.seqan.de/ticket/345	82.251.216.114	-	0	0	1353	624
2012-07-02T19:01:58.826+02:00	UNLOAD	http://trac.seqan.de/ticket/356	82.251.216.114	-	0	0	0	0
2012-07-02T19:02:02.100+02:00	SCROLL	http://trac.seqan.de/ticket/345	82.251.216.114	-	0	228	1353	624
2012-07-02T19:02:05.153+02:00	FOCUS	http://trac.seqan.de/report/1	82.251.216.114	-	0	570	1353	624
2012-07-02T19:02:04.426+02:00	SCROLL	http://trac.seqan.de/ticket/345	82.251.216.114	-	0	0	1353	624
2012-07-02T19:02:05.141+02:00	BLUR	http://trac.seqan.de/ticket/345	82.251.216.114	-	0	0	1353	624
2012-07-02T19:02:10.109+02:00	SCROLL	http://trac.seqan.de/report/1	82.251.216.114	-	0	969	1353	624
2012-07-02T19:02:18.059+02:00	SCROLL	http://trac.seqan.de/report/1	82.251.216.114	-	0	2508	1353	624
2012-07-02T19:02:21.376+02:00	BLUR	http://trac.seqan.de/report/1	82.251.216.114	-	0	0	1353	624
2012-07-02T19:08:17.407+02:00	READY	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	82.251.216.114	-	0	0	1353	650
2012-07-02T19:08:17.457+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Function_Input_2f_Output.html#readRecord	82.251.216.114	-	0	0	167	1144
2012-07-02T19:08:22.166+02:00	SCROLL	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	82.251.216.114	-	0	0	1353	650
2012-07-02T19:08:26.798+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	82.251.216.114	-	0	0	1353	650
2012-07-02T21:48:00.390+02:00	READY	http://trac.seqan.de/ticket/955	82.251.216.114	-	0	912	1353	650
2012-07-02T21:48:04.079+02:00	BLUR	http://trac.seqan.de/ticket/955	82.251.216.114	-	0	1154	1353	650
2012-07-03T10:48:46.969+02:00	READY	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	0	1353	675
2012-07-03T10:48:50.526+02:00	BLUR	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	0	1353	675
2012-07-03T10:48:57.223+02:00	SCROLL	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	684	1353	675
2012-07-03T10:49:33.270+02:00	FOCUS	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	684	1353	675
2012-07-03T10:49:34.599+02:00	BLUR	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	684	1353	675
2012-07-03T10:51:06.920+02:00	FOCUS	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	684	1353	675
2012-07-03T10:51:11.757+02:00	BLUR	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	627	1353	675
2012-07-03T10:51:12.792+02:00	SCROLL	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	627	1353	675
2012-07-03T10:51:27.901+02:00	FOCUS	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	627	1353	675
2012-07-03T10:51:28.424+02:00	BLUR	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	627	1353	675
2012-07-03T10:51:42.861+02:00	READY	http://trac.seqan.de/wiki/Tutorial/SamBamIO	193.52.161.170	-	0	0	1353	675
2012-07-03T10:52:18.620+02:00	LINK-http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	http://trac.seqan.de/wiki/Tutorial/SamBamIO	193.52.161.170	-	0	0	1353	675
2012-07-03T10:52:20.669+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	485	1353	675
2012-07-03T10:52:22.055+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	485	1353	675
2012-07-03T10:52:26.913+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	485	1353	675
2012-07-03T10:54:51.074+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	542	1353	675
2012-07-03T10:55:59.596+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	599	1353	675
2012-07-03T10:56:22.626+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	770	1353	675
2012-07-03T10:56:30.602+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	941	1353	675
2012-07-03T10:56:36.450+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1226	1353	675
2012-07-03T10:56:37.405+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1226	1353	675
2012-07-03T10:56:51.932+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1226	1353	675
2012-07-03T10:56:56.127+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1853	1353	675
2012-07-03T10:57:01.047+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2024	1353	675
2012-07-03T10:57:25.024+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3392	1353	675
2012-07-03T10:57:32.442+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	4333	1353	675
2012-07-03T10:57:43.168+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3763	1353	675
2012-07-03T10:57:49.084+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2623	1353	675
2012-07-03T10:58:04.861+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2053	1353	675
2012-07-03T10:58:20.088+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2053	1353	675
2012-07-03T11:03:51.814+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2053	1353	675
2012-07-03T11:03:52.210+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2053	1353	675
2012-07-03T11:04:06.761+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2053	1353	675
2012-07-03T11:04:07.235+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2053	1353	675
2012-07-03T11:06:37.811+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2053	1353	675
2012-07-03T11:06:39.675+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2053	1353	675
2012-07-03T11:11:39.241+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2053	1353	675
2012-07-03T11:11:57.222+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3820	1353	675
2012-07-03T11:12:01.715+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	4333	1353	675
2012-07-03T11:12:09.743+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1026	1353	675
2012-07-03T11:12:37.944+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1596	1353	675
2012-07-03T11:16:33.341+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1710	1353	675
2012-07-03T11:16:37.114+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1881	1353	675
2012-07-03T11:16:40.907+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2052	1353	675
2012-07-03T11:16:55.425+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2280	1353	675
2012-07-03T11:16:57.668+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2280	1353	675
2012-07-03T11:18:59.512+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2280	1353	675
2012-07-03T11:19:00.783+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2280	1353	675
2012-07-03T11:39:05.705+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2280	1353	675
2012-07-03T11:39:08.208+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2280	1353	675
2012-07-03T11:40:10.651+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2052	1353	675
2012-07-03T11:40:53.413+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1653	1353	675
2012-07-03T11:43:13.584+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-03T11:43:25.353+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-03T11:43:27.385+02:00	READY	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	675
2012-07-03T11:43:27.922+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Spec_Input+_2f+_Output.html#BGZF%20Stream	193.52.161.170	-	0	0	167	781
2012-07-03T11:43:28.520+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1596	1353	675
2012-07-03T11:43:31.941+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	456	1353	675
2012-07-03T11:43:33.225+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	456	1353	675
2012-07-03T11:44:13.740+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	285	1353	675
2012-07-03T11:44:34.199+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1767	1353	675
2012-07-03T11:45:17.765+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1767	1353	675
2012-07-03T11:45:18.611+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1767	1353	675
2012-07-03T11:45:21.120+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1767	1353	675
2012-07-03T11:45:22.720+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1767	1353	675
2012-07-03T11:45:31.892+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2280	1353	675
2012-07-03T11:45:41.508+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2109	1353	675
2012-07-03T11:45:47.554+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-03T11:46:49.222+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	4333	1353	675
2012-07-03T11:47:14.656+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1255	1353	675
2012-07-03T11:47:15.048+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1255	1353	675
2012-07-03T11:47:15.488+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1255	1353	675
2012-07-03T11:47:15.498+02:00	FOCUS	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	627	1353	675
2012-07-03T11:47:17.765+02:00	UNLOAD	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	627	1353	675
2012-07-03T11:47:23.838+02:00	READY	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	1129	1353	675
2012-07-03T11:47:27.225+02:00	SCROLL	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	0	1353	675
2012-07-03T11:47:40.750+02:00	BLUR	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	0	1353	675
2012-07-03T11:49:53.487+02:00	FOCUS	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	0	1353	675
2012-07-03T11:49:54.322+02:00	BLUR	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	0	1353	675
2012-07-03T11:49:54.333+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	675
2012-07-03T11:49:55.951+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1255	1353	675
2012-07-03T11:49:55.934+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	675
2012-07-03T11:49:57.532+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1255	1353	675
2012-07-03T11:49:57.541+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	675
2012-07-03T11:50:01.042+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	126	1353	675
2012-07-03T11:50:37.356+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	126	1353	675
2012-07-03T11:50:40.056+02:00	READY	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	2736	1353	675
2012-07-03T11:50:42.253+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	675
2012-07-03T11:50:42.491+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:43.994+02:00	RESIZE	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:45.625+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:46.571+02:00	TYPING-proj-search-	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:46.678+02:00	TYPING-proj-search-f	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:46.865+02:00	TYPING-proj-search-fil	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:46.759+02:00	TYPING-proj-search-fi	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:47.233+02:00	TYPING-proj-search-file	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:47.903+02:00	TYPING-proj-search-file s	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:47.341+02:00	TYPING-proj-search-file 	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:48.491+02:00	TYPING-proj-search-fi	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:48.401+02:00	TYPING-proj-search-file 	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:48.463+02:00	TYPING-proj-search-fil	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:48.431+02:00	TYPING-proj-search-file	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:48.613+02:00	TYPING-proj-search-	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:48.582+02:00	TYPING-proj-search-	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:48.555+02:00	TYPING-proj-search-	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:48.525+02:00	TYPING-proj-search-f	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:52.032+02:00	UNLOAD	http://trac.seqan.de/wiki/Tutorial/FileIO2	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:58.126+02:00	READY	http://trac.seqan.de/search?q=reading+files	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:58.319+02:00	TYPING-proj-search-gtetting	http://trac.seqan.de/search?q=reading+files	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:58.874+02:00	TYPING-proj-search-gtett	http://trac.seqan.de/search?q=reading+files	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:58.816+02:00	TYPING-proj-search-gtettin	http://trac.seqan.de/search?q=reading+files	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:58.844+02:00	TYPING-proj-search-gtetti	http://trac.seqan.de/search?q=reading+files	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:58.906+02:00	TYPING-proj-search-gtet	http://trac.seqan.de/search?q=reading+files	193.52.161.170	-	0	0	1353	639
2012-07-03T11:51:02.285+02:00	UNLOAD	http://trac.seqan.de/search?q=reading+files	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:59.272+02:00	TYPING-proj-search-gt	http://trac.seqan.de/search?q=reading+files	193.52.161.170	-	0	0	1353	639
2012-07-03T11:50:59.071+02:00	TYPING-proj-search-gte	http://trac.seqan.de/search?q=reading+files	193.52.161.170	-	0	0	1353	639
2012-07-03T11:51:05.214+02:00	READY	http://trac.seqan.de/search?q=getting+started	193.52.161.170	-	0	0	1353	639
2012-07-03T11:51:12.223+02:00	BLUR	http://trac.seqan.de/search?q=getting+started	193.52.161.170	-	0	0	1353	639
2012-07-03T11:51:20.626+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1255	1353	639
2012-07-03T11:51:20.855+02:00	RESIZE	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1255	1353	639
2012-07-03T11:51:24.651+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1255	1353	639
2012-07-03T11:51:21.972+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1255	1353	639
2012-07-03T11:51:19.203+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1255	1353	639
2012-07-03T11:51:38.784+02:00	UNLOAD	http://trac.seqan.de/search?q=getting+started	193.52.161.170	-	0	0	1353	639
2012-07-03T11:51:42.221+02:00	READY	http://trac.seqan.de/wiki/Tutorial	193.52.161.170	-	0	0	1353	639
2012-07-03T11:51:51.149+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial	193.52.161.170	-	0	0	1353	639
2012-07-03T11:51:51.553+02:00	LINK-http://trac.seqan.de/	http://trac.seqan.de/wiki/Tutorial	193.52.161.170	-	0	0	1353	639
2012-07-03T11:51:51.867+02:00	UNLOAD	http://trac.seqan.de/wiki/Tutorial	193.52.161.170	-	0	0	1353	639
2012-07-03T11:51:54.008+02:00	READY	http://trac.seqan.de/	193.52.161.170	-	0	0	1353	639
2012-07-03T11:51:55.076+02:00	UNLOAD	http://trac.seqan.de/	193.52.161.170	-	0	0	1353	639
2012-07-03T11:51:59.057+02:00	READY	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	13	1353	639
2012-07-03T11:52:03.484+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1197	1353	639
2012-07-03T11:52:10.443+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1653	1353	639
2012-07-03T11:52:14.869+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1653	1353	639
2012-07-03T11:52:44.088+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1653	1353	639
2012-07-03T11:54:32.485+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1653	1353	639
2012-07-03T11:54:35.379+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1653	1353	639
2012-07-03T11:59:07.689+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1653	1353	639
2012-07-03T11:59:07.950+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1653	1353	639
2012-07-03T11:59:11.755+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1653	1353	639
2012-07-03T11:59:14.162+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1653	1353	639
2012-07-03T12:05:17.462+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	126	1353	639
2012-07-03T12:05:18.943+02:00	RESIZE	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	126	1353	639
2012-07-03T12:05:19.158+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	126	1353	639
2012-07-03T12:08:21.166+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	126	1353	639
2012-07-03T12:08:23.708+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	126	1353	639
2012-07-03T12:11:33.623+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	126	1353	639
2012-07-03T12:11:34.828+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	126	1353	639
2012-07-03T12:11:56.147+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	126	1353	639
2012-07-03T12:11:56.763+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	126	1353	639
2012-07-03T12:11:56.779+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1255	1353	639
2012-07-03T12:12:00.449+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1255	1353	639
2012-07-03T12:12:45.771+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1255	1353	639
2012-07-03T12:12:51.593+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	172	1353	639
2012-07-03T12:13:01.972+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	742	1353	639
2012-07-03T12:13:08.759+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1711	1353	639
2012-07-03T12:13:16.577+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1825	1353	639
2012-07-03T12:13:12.728+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1768	1353	639
2012-07-03T12:13:35.811+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	628	1353	639
2012-07-03T12:13:41.356+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1939	1353	639
2012-07-03T12:13:44.656+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1825	1353	639
2012-07-03T12:14:20.883+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	685	1353	639
2012-07-03T12:14:26.366+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2110	1353	639
2012-07-03T12:14:26.450+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2110	1353	639
2012-07-03T12:18:45.274+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2110	1353	639
2012-07-03T12:18:46.556+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2110	1353	639
2012-07-03T12:23:02.591+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	126	1353	639
2012-07-03T12:23:11.424+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:23:12.345+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:23:12.359+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2110	1353	639
2012-07-03T12:23:04.054+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	126	1353	639
2012-07-03T12:23:08.044+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	126	1353	639
2012-07-03T12:23:13.137+02:00	FOCUS	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	0	1353	639
2012-07-03T12:23:14.643+02:00	RESIZE	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	0	1353	639
2012-07-03T12:23:13.124+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2110	1353	639
2012-07-03T12:23:17.907+02:00	UNLOAD	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	0	1353	639
2012-07-03T12:23:17.958+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2110	1353	639
2012-07-03T12:23:21.308+02:00	READY	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	0	1353	639
2012-07-03T12:23:26.277+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3421	1353	639
2012-07-03T12:23:36.672+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3913	1353	639
2012-07-03T12:23:30.614+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3991	1353	639
2012-07-03T12:24:17.281+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3742	1353	639
2012-07-03T12:24:05.851+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3457	1353	639
2012-07-03T12:24:21.941+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3742	1353	639
2012-07-03T12:24:59.649+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1405	1353	639
2012-07-03T12:25:02.276+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1462	1353	639
2012-07-03T12:25:07.493+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1462	1353	639
2012-07-03T12:25:18.282+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1576	1353	639
2012-07-03T12:25:35.688+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1804	1353	639
2012-07-03T12:25:47.339+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1861	1353	639
2012-07-03T12:25:51.344+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2146	1353	639
2012-07-03T12:26:07.402+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2374	1353	639
2012-07-03T12:26:10.566+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1914	1353	639
2012-07-03T12:26:11.873+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1914	1353	639
2012-07-03T12:26:13.633+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1914	1353	639
2012-07-03T12:26:14.694+02:00	READY	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:26:14.750+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-03T12:26:19.824+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2149	1353	639
2012-07-03T12:26:21.955+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2758	1353	639
2012-07-03T12:26:34.614+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3065	1353	639
2012-07-03T12:26:43.267+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3503	1353	639
2012-07-03T12:26:55.627+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3617	1353	639
2012-07-03T12:27:03.212+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	4369	1353	639
2012-07-03T12:27:03.094+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:27:10.859+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:27:17.267+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	456	1353	639
2012-07-03T12:27:19.012+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	465	1353	639
2012-07-03T12:27:19.620+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	465	1353	639
2012-07-03T12:27:54.381+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	351	1353	639
2012-07-03T12:28:03.464+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	465	1353	639
2012-07-03T12:28:15.505+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	465	1353	639
2012-07-03T12:28:16.537+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	465	1353	639
2012-07-03T12:28:18.707+02:00	READY	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:28:18.756+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Function_Input_2f_Output.html#readRecord	193.52.161.170	-	0	0	167	1144
2012-07-03T12:28:20.869+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:28:20.844+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	465	1353	639
2012-07-03T12:28:25.043+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:28:25.055+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	465	1353	639
2012-07-03T12:28:28.639+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	294	1353	639
2012-07-03T12:28:28.923+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	294	1353	639
2012-07-03T12:28:32.570+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	294	1353	639
2012-07-03T12:28:39.323+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	639
2012-07-03T12:28:43.527+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	465	1353	639
2012-07-03T12:28:45.596+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	639
2012-07-03T12:28:46.601+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	639
2012-07-03T12:34:35.588+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:34:37.506+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:34:37.523+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:34:38.736+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:34:38.754+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	639
2012-07-03T12:34:41.986+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	639
2012-07-03T12:35:46.072+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	639
2012-07-03T12:35:46.715+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	639
2012-07-03T12:35:46.726+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:35:53.047+02:00	SCROLL	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	342	1353	639
2012-07-03T12:35:55.596+02:00	SCROLL	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	525	1353	639
2012-07-03T12:36:14.953+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	525	1353	639
2012-07-03T12:36:54.351+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	525	1353	639
2012-07-03T12:36:58.609+02:00	LINK-http://docs.seqan.de/seqan/dev/FUNCTION.read2.html	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	525	1353	639
2012-07-03T12:36:58.749+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	525	1353	639
2012-07-03T12:36:58.773+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Function_Input_2f_Output.html#readRecord	193.52.161.170	-	0	0	167	1144
2012-07-03T12:37:01.720+02:00	READY	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	525	1353	639
2012-07-03T12:37:02.488+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Function_Input_2f_Output.html#readRecord	193.52.161.170	-	0	0	167	1144
2012-07-03T12:37:05.763+02:00	SCROLL	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	126	1353	639
2012-07-03T12:37:10.219+02:00	SCROLL	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	285	1353	639
2012-07-03T12:37:14.637+02:00	LINK-http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	285	1353	639
2012-07-03T12:37:14.668+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/FUNCTION.read_Record.html	193.52.161.170	-	0	285	1353	639
2012-07-03T12:37:14.691+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Function_Input_2f_Output.html#readRecord	193.52.161.170	-	0	0	167	1144
2012-07-03T12:37:16.459+02:00	READY	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:37:16.562+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-03T12:37:17.660+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:38:18.996+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:38:25.863+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	57	1353	639
2012-07-03T12:38:27.106+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	57	1353	639
2012-07-03T12:38:29.837+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	57	1353	639
2012-07-03T12:38:35.219+02:00	LINK-http://docs.seqan.de/seqan/dev/MEMVAR_Bam_Alignment_Record_23cigar.html	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	57	1353	639
2012-07-03T12:38:35.334+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	57	1353	639
2012-07-03T12:38:35.358+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-03T12:38:37.083+02:00	READY	http://docs.seqan.de/seqan/dev/MEMVAR_Bam_Alignment_Record_23cigar.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:38:37.112+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Class.html#	193.52.161.170	-	0	0	167	639
2012-07-03T12:38:39.301+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/MEMVAR_Bam_Alignment_Record_23cigar.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:38:39.316+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Class.html#	193.52.161.170	-	0	0	167	639
2012-07-03T12:38:40.730+02:00	READY	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	57	1353	639
2012-07-03T12:38:40.908+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-03T12:38:44.349+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:38:48.448+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:38:48.465+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-03T12:38:48.585+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:38:48.603+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-03T12:38:50.540+02:00	READY	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:38:50.741+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-03T12:38:53.475+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:38:53.494+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	639
2012-07-03T12:38:56.131+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	639
2012-07-03T12:38:56.145+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:38:57.236+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:38:57.258+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	4369	1353	639
2012-07-03T12:39:11.835+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3001	1353	639
2012-07-03T12:39:22.861+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1063	1353	639
2012-07-03T12:39:25.165+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1063	1353	639
2012-07-03T12:40:02.163+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1633	1353	639
2012-07-03T12:40:13.321+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1975	1353	639
2012-07-03T12:40:18.312+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2545	1353	639
2012-07-03T12:40:22.437+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2944	1353	639
2012-07-03T12:40:27.297+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	2944	1353	639
2012-07-03T12:40:36.822+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	4369	1353	639
2012-07-03T12:40:41.882+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	4198	1353	639
2012-07-03T12:40:47.381+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	493	1353	639
2012-07-03T12:40:50.543+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	664	1353	639
2012-07-03T12:40:50.768+02:00	UNLOAD	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	664	1353	639
2012-07-03T12:40:53.072+02:00	READY	http://docs.seqan.de/seqan/dev/CLASS_Bam_I_O_Context.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:40:53.117+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamIOContext	193.52.161.170	-	0	0	180	861
2012-07-03T12:40:55.742+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_I_O_Context.html	193.52.161.170	-	0	243	1353	639
2012-07-03T12:40:56.779+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/CLASS_Bam_I_O_Context.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:40:56.793+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamIOContext	193.52.161.170	-	0	0	180	861
2012-07-03T12:40:58.527+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:41:00.147+02:00	READY	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	664	1353	639
2012-07-03T12:41:02.965+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:41:08.010+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	399	1353	639
2012-07-03T12:41:19.283+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	465	1353	639
2012-07-03T12:41:24.164+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	465	1353	639
2012-07-03T12:41:26.204+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	465	1353	639
2012-07-03T12:41:38.881+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	237	1353	639
2012-07-03T12:41:45.730+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	294	1353	639
2012-07-03T12:41:47.092+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	294	1353	639
2012-07-03T12:41:47.329+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	294	1353	639
2012-07-03T12:42:30.324+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	639
2012-07-03T12:42:54.909+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	639
2012-07-03T12:42:55.977+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	639
2012-07-03T12:43:00.737+02:00	READY	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	639
2012-07-03T12:43:00.796+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-03T12:43:01.688+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	639
2012-07-03T12:45:00.479+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	639
2012-07-03T12:45:00.561+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	639
2012-07-03T12:45:00.588+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-03T12:45:02.771+02:00	BLUR	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-03T12:45:05.359+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamHeader	193.52.161.170	-	0	0	167	639
2012-07-03T12:45:05.450+02:00	READY	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:45:19.401+02:00	LINK-http://docs.seqan.de/seqan/dev/MEMVAR_Bam_Header_23records.html	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:45:19.501+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:45:19.522+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamHeader	193.52.161.170	-	0	0	167	639
2012-07-03T12:45:21.343+02:00	READY	http://docs.seqan.de/seqan/dev/MEMVAR_Bam_Header_23records.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:45:21.383+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Class.html#	193.52.161.170	-	0	0	167	639
2012-07-03T12:45:22.007+02:00	BLUR	http://docs.seqan.de/seqan/dev/MEMVAR_Bam_Header_23records.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:45:22.024+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-03T12:45:22.990+02:00	BLUR	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-03T12:45:25.822+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-03T12:45:26.015+02:00	BLUR	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-03T12:45:26.028+02:00	FOCUS	http://docs.seqan.de/seqan/dev/MEMVAR_Bam_Header_23records.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:45:28.538+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/MEMVAR_Bam_Header_23records.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:45:28.564+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Class.html#	193.52.161.170	-	0	0	167	639
2012-07-03T12:45:29.769+02:00	READY	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:45:30.366+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamHeader	193.52.161.170	-	0	0	167	639
2012-07-03T12:45:32.360+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:49:36.350+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:49:36.911+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:50:00.024+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:50:02.441+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:50:27.996+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:50:29.826+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:50:30.099+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamHeaderRecord	193.52.161.170	-	0	0	167	644
2012-07-03T12:50:30.060+02:00	READY	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T12:50:30.315+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:19:52.101+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:19:54.987+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	25	1353	639
2012-07-03T13:19:55.448+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	25	1353	639
2012-07-03T13:20:04.764+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	25	1353	639
2012-07-03T13:20:04.958+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	25	1353	639
2012-07-03T13:20:04.972+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:20:07.456+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:21:14.904+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	25	1353	639
2012-07-03T13:21:11.901+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:21:11.842+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:21:11.998+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:21:12.422+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:21:12.435+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	25	1353	639
2012-07-03T13:22:27.501+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	25	1353	639
2012-07-03T13:22:27.787+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	25	1353	639
2012-07-03T13:22:34.792+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	25	1353	639
2012-07-03T13:22:31.346+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	25	1353	639
2012-07-03T13:23:33.192+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	25	1353	639
2012-07-03T13:23:25.256+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	25	1353	639
2012-07-03T13:23:25.241+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:23:20.602+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:23:20.583+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	25	1353	639
2012-07-03T13:23:20.034+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	25	1353	639
2012-07-03T13:23:50.959+02:00	READY	http://docs.seqan.de/seqan/dev/FUNCTION.get_Tag_Value.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:23:48.256+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	25	1353	639
2012-07-03T13:23:34.397+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:23:48.280+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamHeaderRecord	193.52.161.170	-	0	0	167	644
2012-07-03T13:23:33.207+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:23:34.197+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:23:33.419+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:23:40.110+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	25	1353	639
2012-07-03T13:23:34.406+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header_Record.html	193.52.161.170	-	0	25	1353	639
2012-07-03T13:23:50.999+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Function_B_A_M+_I_2f_O.html#getTagValue	193.52.161.170	-	0	0	167	789
2012-07-03T13:24:02.846+02:00	SCROLL	http://docs.seqan.de/seqan/dev/FUNCTION.get_Tag_Value.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:24:01.695+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.get_Tag_Value.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:23:53.727+02:00	SCROLL	http://docs.seqan.de/seqan/dev/FUNCTION.get_Tag_Value.html	193.52.161.170	-	0	171	1353	639
2012-07-03T13:30:22.274+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:31:27.314+02:00	BLUR	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-03T13:30:22.293+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-03T13:30:20.667+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:30:20.059+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.get_Tag_Value.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:30:20.652+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.get_Tag_Value.html	193.52.161.170	-	0	0	1353	639
2012-07-03T13:31:34.187+02:00	BLUR	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-03T13:31:34.107+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-03T13:31:38.642+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	675
2012-07-03T13:31:34.201+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	675
2012-07-03T13:31:28.134+02:00	RESIZE	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	675
2012-07-03T13:32:17.172+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	675
2012-07-03T13:32:25.177+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	675
2012-07-03T13:32:47.661+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	675
2012-07-03T13:32:50.475+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Class_Fragment+_Store.html#CigarElement	193.52.161.170	-	0	0	167	675
2012-07-03T13:32:50.436+02:00	READY	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T13:32:50.706+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	675
2012-07-03T13:32:50.717+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T13:33:13.292+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T13:33:32.330+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T13:33:29.767+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T13:33:35.015+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T13:34:05.498+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T13:34:08.411+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T13:34:09.059+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T13:34:55.932+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T13:34:55.949+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	66	1353	675
2012-07-03T13:34:52.126+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T13:35:09.589+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	429	1353	675
2012-07-03T13:35:07.583+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	429	1353	675
2012-07-03T13:35:28.737+02:00	READY	http://trac.seqan.de/changeset/11570/trunk/seqan/extras/include/seqan/bam_io/read_bam.h	193.52.161.170	-	0	0	1353	675
2012-07-03T13:35:33.681+02:00	SCROLL	http://trac.seqan.de/changeset/11570/trunk/seqan/extras/include/seqan/bam_io/read_bam.h	193.52.161.170	-	0	114	1353	675
2012-07-03T13:35:48.677+02:00	SCROLL	http://trac.seqan.de/changeset/11570/trunk/seqan/extras/include/seqan/bam_io/read_bam.h	193.52.161.170	-	0	171	1353	675
2012-07-03T13:36:00.545+02:00	SCROLL	http://trac.seqan.de/changeset/11570/trunk/seqan/extras/include/seqan/bam_io/read_bam.h	193.52.161.170	-	0	386	1353	675
2012-07-03T13:36:25.739+02:00	BLUR	http://trac.seqan.de/changeset/11570/trunk/seqan/extras/include/seqan/bam_io/read_bam.h	193.52.161.170	-	0	386	1353	675
2012-07-03T13:38:00.994+02:00	FOCUS	http://trac.seqan.de/changeset/11570/trunk/seqan/extras/include/seqan/bam_io/read_bam.h	193.52.161.170	-	0	386	1353	675
2012-07-03T13:38:04.897+02:00	BLUR	http://trac.seqan.de/changeset/11570/trunk/seqan/extras/include/seqan/bam_io/read_bam.h	193.52.161.170	-	0	443	1353	675
2012-07-03T13:38:03.973+02:00	SCROLL	http://trac.seqan.de/changeset/11570/trunk/seqan/extras/include/seqan/bam_io/read_bam.h	193.52.161.170	-	0	443	1353	675
2012-07-03T13:38:48.459+02:00	SCROLL	http://trac.seqan.de/changeset/11570/trunk/seqan/extras/include/seqan/bam_io/read_bam.h	193.52.161.170	-	0	101	1353	675
2012-07-03T13:41:06.649+02:00	FOCUS	http://trac.seqan.de/changeset/11570/trunk/seqan/extras/include/seqan/bam_io/read_bam.h	193.52.161.170	-	0	101	1353	675
2012-07-03T13:41:06.846+02:00	BLUR	http://trac.seqan.de/changeset/11570/trunk/seqan/extras/include/seqan/bam_io/read_bam.h	193.52.161.170	-	0	101	1353	675
2012-07-03T14:14:06.817+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:14:05.695+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.get_Tag_Value.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:14:06.801+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.get_Tag_Value.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:14:06.838+02:00	RESIZE	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:14:05.171+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:14:05.676+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:14:03.124+02:00	BLUR	http://trac.seqan.de/changeset/11570/trunk/seqan/extras/include/seqan/bam_io/read_bam.h	193.52.161.170	-	0	101	1353	675
2012-07-03T14:14:02.410+02:00	FOCUS	http://trac.seqan.de/changeset/11570/trunk/seqan/extras/include/seqan/bam_io/read_bam.h	193.52.161.170	-	0	101	1353	675
2012-07-03T14:14:36.686+02:00	READY	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	637	1353	675
2012-07-03T14:14:07.396+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:14:10.366+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:14:08.357+02:00	RESIZE	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamHeader	193.52.161.170	-	0	0	167	675
2012-07-03T14:14:08.311+02:00	RESIZE	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:14:07.377+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:14:07.191+02:00	RESIZE	http://docs.seqan.de/seqan/dev/FUNCTION.get_Tag_Value.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:14:22.462+02:00	UNLOAD	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	0	1353	675
2012-07-03T14:14:19.292+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	664	1353	675
2012-07-03T14:14:19.622+02:00	RESIZE	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	664	1353	675
2012-07-03T14:14:18.136+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	664	1353	675
2012-07-03T14:14:19.303+02:00	FOCUS	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	0	1353	675
2012-07-03T14:14:19.443+02:00	SCROLL	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	171	1353	675
2012-07-03T14:14:18.119+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	171	1353	675
2012-07-03T14:14:12.085+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	429	1353	675
2012-07-03T14:14:12.070+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:14:08.164+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:16:57.256+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	664	1353	675
2012-07-03T14:16:57.245+02:00	BLUR	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	637	1353	675
2012-07-03T14:16:54.517+02:00	FOCUS	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	637	1353	675
2012-07-03T14:17:05.891+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-03T14:17:02.615+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1301	1353	675
2012-07-03T14:17:05.495+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-03T14:18:30.198+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-03T14:18:31.512+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-03T14:18:28.343+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-03T14:18:21.003+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-03T14:19:06.645+02:00	BLUR	http://trac.seqan.de/changeset/11570/trunk/seqan/extras/include/seqan/bam_io/read_bam.h	193.52.161.170	-	0	101	1353	675
2012-07-03T14:19:04.196+02:00	FOCUS	http://trac.seqan.de/changeset/11570/trunk/seqan/extras/include/seqan/bam_io/read_bam.h	193.52.161.170	-	0	101	1353	675
2012-07-03T14:19:00.132+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-03T14:18:59.946+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-03T14:19:24.008+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:19:17.797+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.get_Tag_Value.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:19:17.816+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:19:12.511+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:19:12.529+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.get_Tag_Value.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:19:10.861+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:20:53.497+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:19:37.739+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:19:53.305+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:19:38.913+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:21:31.719+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:21:30.934+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:21:42.285+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:21:10.684+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:21:34.040+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:21:43.402+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:21:07.495+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:21:07.406+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:21:07.350+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:21:03.436+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:19:38.898+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:21:46.105+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	171	1353	675
2012-07-03T14:23:16.886+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	171	1353	675
2012-07-03T14:21:43.918+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	171	1353	675
2012-07-03T14:21:43.909+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:21:40.944+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:21:35.374+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:23:18.146+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	171	1353	675
2012-07-03T14:21:43.387+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	171	1353	675
2012-07-03T14:21:42.298+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	171	1353	675
2012-07-03T14:48:14.951+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	675
2012-07-03T14:48:15.338+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	675
2012-07-03T17:33:07.446+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	639
2012-07-03T17:33:08.952+02:00	RESIZE	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	639
2012-07-03T17:33:09.466+02:00	FOCUS	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	637	1353	639
2012-07-03T17:33:09.452+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	639
2012-07-03T17:33:10.971+02:00	RESIZE	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	637	1353	639
2012-07-03T17:33:12.793+02:00	UNLOAD	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	637	1353	639
2012-07-03T17:33:15.734+02:00	READY	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	637	1353	639
2012-07-03T17:33:19.900+02:00	BLUR	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	342	1353	639
2012-07-03T17:33:20.683+02:00	SCROLL	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	342	1353	639
2012-07-03T17:37:41.437+02:00	FOCUS	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	342	1353	639
2012-07-03T17:37:41.593+02:00	BLUR	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	342	1353	639
2012-07-03T18:11:08.857+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	639
2012-07-03T18:11:09.713+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	639
2012-07-03T18:15:30.098+02:00	RESIZE	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	639
2012-07-03T18:15:28.582+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	171	1353	639
2012-07-03T18:15:29.689+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	639
2012-07-03T18:15:28.599+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	639
2012-07-03T18:15:27.355+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	639
2012-07-03T18:15:27.738+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Cigar_Element.html	193.52.161.170	-	0	0	1353	639
2012-07-03T18:15:27.100+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T18:15:27.755+02:00	FOCUS	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	171	1353	639
2012-07-03T18:15:26.615+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	639
2012-07-03T18:15:26.807+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_B_G_Z_F+_Stream.html	193.52.161.170	-	0	0	1353	639
2012-07-03T18:15:27.082+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.get_Tag_Value.html	193.52.161.170	-	0	0	1353	639
2012-07-03T18:15:27.337+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Header.html	193.52.161.170	-	0	0	1353	639
2012-07-03T18:15:26.826+02:00	FOCUS	http://docs.seqan.de/seqan/dev/FUNCTION.get_Tag_Value.html	193.52.161.170	-	0	0	1353	639
2012-07-03T18:28:57.775+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	639
2012-07-03T18:28:54.252+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	639
2012-07-04T09:23:53.410+02:00	READY	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T09:23:54.754+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T09:34:07.797+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T09:34:09.019+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T09:34:10.502+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T09:34:11.586+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T09:34:15.288+02:00	READY	http://docs.seqan.de/seqan/dev/FUNCTION.position.html	193.52.161.170	-	0	0	1353	675
2012-07-04T09:34:16.843+02:00	BLUR	http://docs.seqan.de/seqan/dev/FUNCTION.position.html	193.52.161.170	-	0	0	1353	675
2012-07-04T09:34:15.809+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Function_Iteration.html#position	193.52.161.170	-	0	0	167	675
2012-07-04T09:34:20.279+02:00	READY	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	908	1353	675
2012-07-04T09:34:22.138+02:00	BLUR	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	734	1353	675
2012-07-04T09:34:24.243+02:00	SCROLL	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	730	1353	675
2012-07-04T09:52:17.682+02:00	FOCUS	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	730	1353	675
2012-07-04T09:52:18.620+02:00	BLUR	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	730	1353	675
2012-07-04T09:53:21.012+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T09:53:23.350+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T10:02:07.551+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T10:02:08.762+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T10:02:58.484+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T10:02:59.376+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T10:03:21.982+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T10:03:24.678+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T10:04:19.334+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T10:04:21.167+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T10:04:46.447+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T10:04:47.813+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T10:10:11.888+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T10:10:12.433+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T12:19:52.267+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	675
2012-07-04T12:19:54.293+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	639
2012-07-04T12:19:55.798+02:00	RESIZE	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	1938	1353	639
2012-07-04T12:19:59.372+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3935	1353	639
2012-07-04T12:20:04.387+02:00	RESIZE	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	730	1353	639
2012-07-04T12:20:05.669+02:00	UNLOAD	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	730	1353	639
2012-07-04T12:20:08.631+02:00	READY	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	730	1353	639
2012-07-04T12:20:15.171+02:00	READY	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	1353	639
2012-07-04T12:20:17.426+02:00	SCROLL	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1653	1353	639
2012-07-04T13:07:57.745+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1653	1353	639
2012-07-04T13:07:58.584+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1653	1353	639
2012-07-04T13:08:59.375+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1653	1353	639
2012-07-04T13:09:00.671+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	1653	1353	639
2012-07-04T13:09:01.662+02:00	UNLOAD	http://trac.seqan.de/wiki/Tutorial/GettingStarted	193.52.161.170	-	0	0	0	0
2012-07-04T13:09:29.134+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3935	1353	639
2012-07-04T13:09:30.138+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3935	1353	639
2012-07-04T13:09:31.356+02:00	FOCUS	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3935	1353	639
2012-07-04T13:09:34.841+02:00	BLUR	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3935	1353	639
2012-07-04T13:09:37.040+02:00	READY	http://docs.seqan.de/seqan/dev/CLASS_Bam_Tags_Dict.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:09:37.084+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamTagsDict	193.52.161.170	-	0	0	180	814
2012-07-04T13:09:39.384+02:00	BLUR	http://docs.seqan.de/seqan/dev/CLASS_Bam_Tags_Dict.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:09:39.405+02:00	FOCUS	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamTagsDict	193.52.161.170	-	0	0	180	814
2012-07-04T13:09:39.649+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/CLASS_Bam_Tags_Dict.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:09:39.661+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamTagsDict	193.52.161.170	-	0	0	180	814
2012-07-04T13:09:41.280+02:00	READY	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:09:41.336+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-04T13:09:44.558+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Class_B_A_M+_I_2f_O.html#BamAlignmentRecord	193.52.161.170	-	0	0	180	1083
2012-07-04T13:09:44.428+02:00	LINK-http://docs.seqan.de/seqan/dev/MEMVAR_Bam_Alignment_Record_23q_Name.html	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:09:44.540+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/CLASS_Bam_Alignment_Record.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:09:46.285+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Class.html#	193.52.161.170	-	0	0	167	639
2012-07-04T13:09:46.197+02:00	READY	http://docs.seqan.de/seqan/dev/MEMVAR_Bam_Alignment_Record_23q_Name.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:09:50.676+02:00	LINK-http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	http://docs.seqan.de/seqan/dev/MEMVAR_Bam_Alignment_Record_23q_Name.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:09:50.771+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/MEMVAR_Bam_Alignment_Record_23q_Name.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:09:50.787+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Class.html#	193.52.161.170	-	0	0	167	639
2012-07-04T13:09:52.353+02:00	READY	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:09:53.268+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#CharString	193.52.161.170	-	0	0	180	2150
2012-07-04T13:09:56.857+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	969	1353	639
2012-07-04T13:10:03.369+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	1532	1353	639
2012-07-04T13:10:11.296+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	734	1353	639
2012-07-04T13:10:17.591+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	506	1353	639
2012-07-04T13:10:21.440+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	620	1353	639
2012-07-04T13:10:24.301+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	791	1353	639
2012-07-04T13:10:30.687+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	221	1353	639
2012-07-04T13:10:33.519+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	164	1353	639
2012-07-04T13:10:42.496+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	278	1353	639
2012-07-04T13:11:27.165+02:00	BLUR	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	278	1353	639
2012-07-04T13:14:56.520+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	1140	1353	639
2012-07-04T13:15:26.201+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:15:26.212+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#CharString	193.52.161.170	-	0	0	180	2150
2012-07-04T13:15:05.158+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	1368	1353	639
2012-07-04T13:14:46.048+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	342	1353	639
2012-07-04T13:14:42.484+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:14:38.898+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	278	1353	639
2012-07-04T13:17:31.565+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_Alloc+_String.html	193.52.161.170	-	0	3280	1353	639
2012-07-04T13:17:27.221+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_Alloc+_String.html	193.52.161.170	-	0	3280	1353	639
2012-07-04T13:17:02.773+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Spec_Strings.html#Alloc%20String	193.52.161.170	-	0	0	180	3898
2012-07-04T13:17:02.677+02:00	READY	http://docs.seqan.de/seqan/dev/SPEC_Alloc+_String.html	193.52.161.170	-	0	3280	1353	639
2012-07-04T13:15:13.353+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	1532	1353	639
2012-07-04T13:18:14.352+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	1026	1353	639
2012-07-04T13:18:10.623+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	969	1353	639
2012-07-04T13:18:04.828+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	513	1353	639
2012-07-04T13:18:02.696+02:00	READY	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	391	1353	639
2012-07-04T13:18:02.769+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#CharString	193.52.161.170	-	0	0	180	2150
2012-07-04T13:17:58.720+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Spec_Strings.html#Alloc%20String	193.52.161.170	-	0	0	180	3898
2012-07-04T13:17:58.703+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/SPEC_Alloc+_String.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:17:52.332+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SPEC_Alloc+_String.html	193.52.161.170	-	0	3280	1353	639
2012-07-04T13:17:52.855+02:00	BLUR	http://docs.seqan.de/seqan/dev/SPEC_Alloc+_String.html	193.52.161.170	-	0	3280	1353	639
2012-07-04T13:18:46.665+02:00	BLUR	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:18:45.736+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:18:40.159+02:00	BLUR	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:18:28.221+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:18:19.841+02:00	SCROLL	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	1083	1353	639
2012-07-04T13:19:06.833+02:00	READY	http://docs.seqan.de/seqan/dev/FUNCTION.to_C_String.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:19:06.898+02:00	READY	http://docs.seqan.de/seqan/dev/INDEX_Function_Containers.html#toCString	193.52.161.170	-	0	0	167	639
2012-07-04T13:19:01.617+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-04T13:19:01.632+02:00	UNLOAD	http://docs.seqan.de/seqan/dev/INDEX_Shortcut_Strings.html#CharString	193.52.161.170	-	0	0	180	2150
2012-07-04T13:19:00.192+02:00	FOCUS	http://docs.seqan.de/seqan/dev/SHORTCUT_Char_String.html	193.52.161.170	-	0	0	1353	639
2012-07-05T10:18:49.736+02:00	READY	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	673	1353	675
2012-07-05T10:18:52.149+02:00	BLUR	http://trac.seqan.de/ticket/955	193.52.161.170	-	0	0	1353	675
2012-07-05T10:18:55.989+02:00	READY	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3935	1353	675
2012-07-05T10:50:13.436+02:00	UNLOAD	http://trac.seqan.de/wiki/Tutorial/SamBamIO#TheSAMandBAMFormats	193.52.161.170	-	0	3935	1353	675

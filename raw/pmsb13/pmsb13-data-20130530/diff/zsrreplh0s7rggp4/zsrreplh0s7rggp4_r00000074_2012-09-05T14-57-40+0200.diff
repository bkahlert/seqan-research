diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x /home/gabriel/Development/seqan-trunk/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/zsrreplh0s7rggp4_stats.txt -x /home/gabriel/Development/seqan-trunk/misc/seqan_instrumentation/userdata/zsrreplh0s7rggp4_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x /home/gabriel/Development/seqan-trunk/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x /home/gabriel/Development/seqan-trunk/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x /home/gabriel/Development/seqan-trunk/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x /home/gabriel/Development/seqan-trunk/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x /home/gabriel/Development/seqan-trunk/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/my_sandbox/apps/first_app/first_app.cpp ./sandbox/my_sandbox/apps/first_app/first_app.cpp
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/my_sandbox/apps/first_app/first_app.cpp	2012-09-05 14:20:01.000000000 +0200
+++ ./sandbox/my_sandbox/apps/first_app/first_app.cpp	2012-09-05 14:57:34.608122081 +0200
@@ -1,12 +1,289 @@
-#include <seqan/sequence.h>
-#include <seqan/index.h>
+// #include <seqan/sequence.h>
+// #include <seqan/index.h>
+// #include <iostream>
+// #include <seqan/sequence_journaled.h>
+// #include <seqan/journaled_set.h>
+// 
+// using namespace std;
+// using namespace seqan;
+// 
+// 
+// template <typename TString, typename TStream, typename TSpec>
+// inline int
+// loadAndJoin(StringSet<TString, Owner<JournaledSet> > & journalSet,
+//             TStream & stream,
+//             JoinConfig<TSpec> const & joinConfig)
+// {
+//     typedef typename Host<TString>::Type THost;
+//     // Define the RecordReader.
+//     RecordReader<std::ifstream, SinglePass<> > reader(stream);
+//     // [A] Ensure the Journal Set is not occupied by other sequences.
+//     clear(journalSet);
+//     // Construct the temporary buffers for the read id and sequence.
+//     String<char> tempSeqId;
+//     THost tempSeq;
+//     // No sequences in the fasta file!
+//     if (atEnd(reader))
+//     {
+//         std::cerr << "Empty FASTA file." << std::endl;
+//         return -1;
+//     }
+//     // First read sequence for reference sequence.
+//     if (readRecord(tempSeqId, tempSeq, reader, Fasta()) != 0)
+//     {
+//         std::cerr << "ERROR reading FASTA." << std::endl;
+//         return 1;
+//     }
+//     // [B] Set the reference sequence to the Journal Set
+//     createGlobalReference(journalSet, tempSeq);
+//     // Read remaining sequences.
+//     while (!atEnd(reader))
+//     {
+//         if (readRecord(tempSeqId, tempSeq, reader, Fasta()) != 0)
+//         {
+//             std::cerr << "ERROR reading FASTA." << std::endl;
+//             return 1;
+//         }
+//         // [C] Append and join the current read sequence.
+//     appendValue(journalSet,tempSeq);
+//     join(journalSet,length(journalSet)-1,joinConfig);  
+//       
+//     }
+//     return 0;
+// }
+// 
+// 
+// template <typename TString, typename TPattern>
+// void searchPattern(StringSet<String<int> > & hitSet,
+//                    StringSet<TString, Owner<JournaledSet> > const & journalSet,
+//                    TPattern const & pattern)
+// {
+//     typedef typename Host<TString>::Type THost;
+//     // Check for valid initial state.
+//     if (empty(globalReference(journalSet)))
+//     {
+//         ::std::cout << "No reference set. Aborted search!" << std::endl;
+//         return;
+//     }
+//     // Reset the hitSet to avoid phantom hits coming from a previous search.
+//     clear(hitSet);
+//     resize(hitSet, length(journalSet) + 1);
+//         // Access the reference sequence.
+//     THost & globalRef = globalReference(journalSet);
+//     // Search for pattern in the reference sequence.
+//     findPatternInReference(hitSet[0], globalRef, pattern);
+//         // Search for pattern in the journaled sequences.
+//     for (unsigned i = 0; i < length(journalSet); ++i)
+//         findPatternInJournalString(hitSet[i+1], journalSet[i], pattern, hitSet[0]);
+// }
+// 
+// 
+// 
+// template <typename TString, typename TPattern>
+// void findPatternInReference(String<int> & hits,
+//                             TString const & reference,
+//                             TPattern const & pattern)
+// {
+//     // [A] Check whether pattern fits into the sequence.
+//     if (length(pattern) > length(reference))
+//         return;
+//     // [B] Iterate over all positions at which the pattern might occur.
+//     for (unsigned pos = 0; pos < length(reference) - length(pattern) + 1; ++pos)
+//     {
+//         bool isHit = true;
+//         // [C] Evaluate all positions of the pattern until you find a mismatch or you have found a hit.
+//         for (unsigned posPattern = 0; posPattern < length(pattern); ++posPattern)
+//         {
+//             if(pattern[posPattern] != reference[posPattern + pos])
+//             {
+//                 isHit = false;
+//                 break;
+//             }
+//         }
+//         // [D] Report begin position at which pattern matches the sequence.
+//         if(isHit)
+//             appendValue(hits, pos);
+//     }
+// }
+// 
+// template <typename TJournalEntriesIterator, typename TPattern>
+// void _findInOriginalNode(String<int> & hitTarget,
+//                          TJournalEntriesIterator & entriesIt,
+//                          TPattern const & pattern,
+//                          String<int> const & refHits)
+// {
+//     // [A] Check if hits exist in the reference.
+//     if(!empty(refHits)){
+//     // [B] Find upper bound to current physical position in sorted refHits using ::std::upper_bound.
+//     THitIterator itHit = std::upper_bound(begin(refHits),end(refHits),entriesIt->physicalPosition);
+//     // [C] Make sure we do not miss hits that begin at physical position of current node.
+//     if(itHit != begin(refHits) && *(itHit - 1) >= (int)entriesIt->physicalPosition)
+//             --itHit;
+//     // [D] Store all hits that are found in the region of the reference which is covered by this node.
+//    while((int)*itHit < ((int)entriesIt->physicalPosition + (int)entriesIt->length - (int)length(pattern) + 1) && itHit != end(refHits))
+//         {
+//             // [E] Store the correct virtual position and check next hit.
+//             appendValue(hitTarget, entriesIt->virtualPosition + (*itHit - (int)entriesIt->physicalPosition));
+//             ++itHit;
+//         }
+//     }
+// }
+// 
+// int main()
+// {
+//     // Definition of the used types.
+//     typedef String<Dna,Alloc<> > TSequence;
+//     typedef String<Dna,Journaled<Alloc<>,SortedArray,Alloc<> > > TJournal;
+//     typedef StringSet< TJournal, Owner<JournaledSet> > TJournaledSet;
+//     // Open the stream to the file containing the sequences.
+//     String<char> seqDatabasePath = "/home/gabriel/Downloads/sequences.fasta";
+//     std::ifstream databaseFile(toCString(seqDatabasePath), std::ios_base::in);
+//     if(!databaseFile.good())
+//     {
+//         std::cerr << "Cannot open file <" << seqDatabasePath << ">!" << std::endl;
+//     }
+//     // Reading each sequence and journal them.
+//     // [D] Construct Journaled Set and call loadAndJoin
+//     TJournaledSet journalSet;
+//     JoinConfig<GlobalAlign<JournaledCompact> > joinConfig;
+//     loadAndJoin(journalSet, databaseFile, joinConfig);
+//     databaseFile.close();
+//     return 0;
+// }
+
 #include <iostream>
-#include <seqan/sequence_journaled.h>
+#include <seqan/find.h>
+#include <seqan/seq_io.h>
 #include <seqan/journaled_set.h>
 
-using namespace std;
 using namespace seqan;
 
+template <typename TJournalEntriesIterator, typename TJournal, typename TPattern>
+void _searchAtBorder(String<int> & hitTarget,
+                    TJournalEntriesIterator & entriesIt,
+                    TJournal const & journal,
+                    TPattern const & needle)
+{
+    typedef typename Position<TJournal>::Type TPosition;
+    // Define region before the border to the next node to search for the pattern.
+    TPosition infixBegin = entriesIt->virtualPosition + _max(0,(int)entriesIt->length - (int)length(needle) + 1);
+    TPosition infixEnd = _min(length(journal),entriesIt->virtualPosition + entriesIt->length + length(needle) - 1);
+    TPattern tmpInsBuffer = infix(journal, infixBegin, infixEnd);
+    Finder<TPattern const> finder(tmpInsBuffer);
+    Pattern<TPattern, Horspool> pattern(needle);
+    while (find(finder, pattern))
+    {
+        appendValue(hitTarget, infixBegin + beginPosition(finder));
+    }
+}
+
+template <typename TJournalEntriesIterator, typename TJournal, typename TPattern>
+void _findInPatchNode(String<int> & hitTarget,
+                      TJournalEntriesIterator & entriesIt,
+                      TJournal const & journal,
+                      TPattern const & needle)
+{
+    typedef typename Position<TJournal>::Type TPosition;
+    TPosition infixBegin = entriesIt->virtualPosition;
+    TPosition infixEnd = entriesIt->virtualPosition + entriesIt->length;
+    TPattern tmpInsBuffer = infix(journal, infixBegin, infixEnd);
+    Finder<TPattern const> finder(tmpInsBuffer);
+    Pattern<TPattern, Horspool> pattern(needle);
+    while (find(finder, pattern))
+        appendValue(hitTarget, entriesIt->virtualPosition + beginPosition(finder));
+}
+
+template <typename TJournalEntriesIterator, typename TPattern>
+void _findInOriginalNode(String<int> & hitTarget,
+                         TJournalEntriesIterator & entriesIt,
+                         TPattern const & pattern,
+                         String<int> const & refHits)
+{
+    // Define an Iterator which iterates over the reference hit set.
+    typedef typename Iterator<String<int> const, Standard>::Type THitIterator;
+    // Check if hits exist in the reference.
+    if(!empty(refHits))
+    {
+        // Find upper bound to physical position in sorted refHits.
+        THitIterator itHit = std::upper_bound(begin(refHits),end(refHits),entriesIt->physicalPosition);
+        // Make sure we do not miss hits that begin at physical position of current node.
+        if(itHit != begin(refHits) && *(itHit - 1) >= (int)entriesIt->physicalPosition)
+            --itHit;
+        // Store all hits that are found in the region of the reference which is covered by this node.
+        while((int)*itHit < ((int)entriesIt->physicalPosition + (int)entriesIt->length - (int)length(pattern) + 1) && itHit != end(refHits))
+        {
+            appendValue(hitTarget, entriesIt->virtualPosition + (*itHit - (int)entriesIt->physicalPosition));
+            ++itHit;
+        }
+    }
+}
+
+template <typename TValue, typename THostSpec, typename TJournalSpec, typename TBufferSpec, typename TPattern>
+void findPatternInJournalString(String<int> & hitTarget,
+                           String<TValue, Journaled<THostSpec, TJournalSpec, TBufferSpec> > const & journal,
+                           TPattern const & pattern,
+                           String<int> const & refHits)
+{
+    typedef String<TValue, Journaled<THostSpec, TJournalSpec, TBufferSpec> > TJournal;
+    typedef typename JournalType<TJournal>::Type TJournalEntries;
+    typedef typename Iterator<TJournalEntries>::Type TJournalEntriesIterator;
+    if (length(pattern) > length(journal))
+        return;
+    TJournalEntriesIterator it = begin(journal._journalEntries);
+    TJournalEntriesIterator itEnd = findInJournalEntries(journal._journalEntries, length(journal) - length(pattern) + 1) + 1;
+    while(it != itEnd)
+    {
+        if (it->segmentSource == SOURCE_ORIGINAL)
+        {   // Find a possible hit in the current source vertex.
+            _findInOriginalNode(hitTarget, it, pattern, refHits);
+        }
+        if (it->segmentSource == SOURCE_PATCH)
+        {  // Search for pattern within the patch node.
+            _findInPatchNode(hitTarget, it, journal, pattern);
+        }
+        // Scan the border for a possible match.
+        _searchAtBorder(hitTarget, it, journal, pattern);
+        ++it;
+    }
+}
+
+template <typename TString>
+void findPatternInReference(String<int> & hits,
+                            TString const & reference,
+                            TString const & needle)
+{
+    // Check whether the pattern fits into the sequence.
+    if (length(needle) > length(reference))
+        return;
+    Finder<TString const> finder(reference);
+    Pattern<TString, Horspool> pattern(needle);
+    while (find(finder, pattern))
+        appendValue(hits, beginPosition(finder));
+}
+
+template <typename TString, typename TPattern>
+void searchPattern(StringSet<String<int> > & hitSet,
+                   StringSet<TString, Owner<JournaledSet> > const & journalSet,
+                   TPattern const & pattern)
+{
+    typedef typename Host<TString>::Type THost;
+    // Check for valid initial state.
+    if (empty(globalReference(journalSet)))
+    {
+        ::std::cout << "No reference set. Aborted search!" << std::endl;
+        return;
+    }
+    // Reset the hitSet to avoid phantom hits coming from a previous search.
+    clear(hitSet);
+    resize(hitSet, length(journalSet) + 1);
+    // Access the reference sequence.
+    THost & globalRef = globalReference(journalSet);
+    // Search for pattern in the reference sequence.
+    findPatternInReference(hitSet[0], globalRef, pattern);
+    // Search for pattern in the journaled sequences.
+    for (unsigned i = 0; i < length(journalSet); ++i)
+        findPatternInJournalString(hitSet[i+1], journalSet[i], pattern, hitSet[0]);
+}
 
 template <typename TString, typename TStream, typename TSpec>
 inline int
@@ -15,13 +292,10 @@
             JoinConfig<TSpec> const & joinConfig)
 {
     typedef typename Host<TString>::Type THost;
-    // Define the RecordReader.
     RecordReader<std::ifstream, SinglePass<> > reader(stream);
-    // [A] Ensure the Journal Set is not occupied by other sequences.
     clear(journalSet);
-    // Construct the temporary buffers for the read id and sequence.
-    String<char> tempSeqId;
-    THost tempSeq;
+    String<char> seqId;
+    THost sequence;
     // No sequences in the fasta file!
     if (atEnd(reader))
     {
@@ -29,55 +303,27 @@
         return -1;
     }
     // First read sequence for reference sequence.
-    if (readRecord(tempSeqId, tempSeq, reader, Fasta()) != 0)
+    if (readRecord(seqId, sequence, reader, Fasta()) != 0)
     {
         std::cerr << "ERROR reading FASTA." << std::endl;
         return 1;
     }
-    // [B] Set the reference sequence to the Journal Set
-    createGlobalReference(journalSet, tempSeq);
-    // Read remaining sequences.
+    // We have to create the global reference sequence otherwise we loose the information after this function terminates.
+    createGlobalReference(journalSet, sequence);
+    // If there are more
     while (!atEnd(reader))
     {
-        if (readRecord(tempSeqId, tempSeq, reader, Fasta()) != 0)
+        if (readRecord(seqId, sequence, reader, Fasta()) != 0)
         {
             std::cerr << "ERROR reading FASTA." << std::endl;
             return 1;
         }
-        // [C] Append and join the current read sequence.
-    appendValue(journalSet,tempSeq);
-    join(journalSet,length(journalSet)-1,joinConfig);  
-      
+        appendValue(journalSet, sequence);
+        join(journalSet, length(journalSet) - 1, joinConfig);
     }
     return 0;
 }
 
-template <typename TString, typename TPattern>
-void findPatternInReference(String<int> & hits,
-                            TString const & reference,
-                            TPattern const & pattern)
-{
-    // [A] Check whether pattern fits into the sequence.
-    if (length(pattern) > length(reference))
-        return;
-    // [B] Iterate over all positions at which the pattern might occur.
-    for (unsigned pos = 0; pos < length(reference) - length(pattern) + 1; ++pos)
-    {
-        bool isHit = true;
-        // [C] Evaluate all positions of the pattern until you find a mismatch or you have found a hit.
-        for (unsigned posPattern = 0; posPattern < length(pattern); ++posPattern)
-        {
-            if(pattern[posPattern] != reference[posPattern + pos])
-            {
-                isHit = false;
-                break;
-            }
-        }
-        // [D] Report begin position at which pattern matches the sequence.
-        if(isHit)
-            appendValue(hits, pos);
-    }
-}
 int main()
 {
     // Definition of the used types.
@@ -85,17 +331,47 @@
     typedef String<Dna,Journaled<Alloc<>,SortedArray,Alloc<> > > TJournal;
     typedef StringSet< TJournal, Owner<JournaledSet> > TJournaledSet;
     // Open the stream to the file containing the sequences.
-    String<char> seqDatabasePath = "/home/gabriel/Downloads/sequences.fasta";
+    String<char> seqDatabasePath = "/Users/rmaerker/Development/workspace_seqan_trunk/build/debug/sandbox/rmaerker/apps/seqGen/sequences.fasta";
+//    String<char> seqDatabasePath =  "/path/to/your/fasta/file/sequences.fasta";
     std::ifstream databaseFile(toCString(seqDatabasePath), std::ios_base::in);
     if(!databaseFile.good())
     {
         std::cerr << "Cannot open file <" << seqDatabasePath << ">!" << std::endl;
     }
     // Reading each sequence and journal them.
-    // [D] Construct Journaled Set and call loadAndJoin
     TJournaledSet journalSet;
     JoinConfig<GlobalAlign<JournaledCompact> > joinConfig;
     loadAndJoin(journalSet, databaseFile, joinConfig);
     databaseFile.close();
+    // Define a pattern and start search.
+    StringSet<String<int> > hitSet;
+    TSequence pattern = "GTGGT";
+    ::std::cout << "Search for: " << pattern << ":\n";
+    searchPattern(hitSet, journalSet, pattern);
+    if (empty(hitSet[0]))
+    {
+        ::std::cout << "No hit in reference " << ::std::endl;
+    }
+    else
+    {
+        ::std::cout << "Hit in reference " << " at ";
+        for (unsigned j = 0; j < length(hitSet[0]); ++j)
+            ::std::cout << hitSet[0][j] << ": " << infix(globalReference(journalSet), hitSet[0][j],hitSet[0][j] + length(pattern)) << "\t";
+    }
+    ::std::cout << ::std::endl;
+    for (unsigned i = 1; i < length(hitSet); ++i)
+    {
+        if (empty(hitSet[i]))
+        {
+            ::std::cout << "No hit in sequence " << i - 1 << ::std::endl;
+        }
+        else
+        {
+            ::std::cout << "Hit in sequence " << i - 1 << " at ";
+            for (unsigned j = 0; j < length(hitSet[i]); ++j)
+                ::std::cout << hitSet[i][j] << ": " << infix(value(journalSet,i-1), hitSet[i][j],hitSet[i][j] + length(pattern)) << "\t";
+        }
+        ::std::cout << ::std::endl;
+    }
     return 0;
 }
\ Kein Zeilenumbruch am Dateiende.
diff -u -r -N -x '*.o' -x Thumbs.db -x .DS_Store -x CMakeCache.txt -x misc/seqan_instrumentation/userdata/id.txt -x /home/gabriel/Development/seqan-trunk/misc/seqan_instrumentation/userdata/id.txt -x misc/seqan_instrumentation/userdata/zsrreplh0s7rggp4_stats.txt -x /home/gabriel/Development/seqan-trunk/misc/seqan_instrumentation/userdata/zsrreplh0s7rggp4_stats.txt -x .svn -x bin -x build -x util -x misc -x docs -x docs2 -x extras -x core -x misc/seqan_instrumentation/bin -x /home/gabriel/Development/seqan-trunk/misc/seqan_instrumentation/bin -x misc/seqan_instrumentation/last_revision_copy -x /home/gabriel/Development/seqan-trunk/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/last_revision_copy -x /home/gabriel/Development/seqan-trunk/misc/seqan_instrumentation/last_revision_copy -x misc/seqan_instrumentation/userdata -x /home/gabriel/Development/seqan-trunk/misc/seqan_instrumentation/userdata -x misc/seqan_instrumentation/userdata -x /home/gabriel/Development/seqan-trunk/misc/seqan_instrumentation/userdata ./misc/seqan_instrumentation/last_revision_copy/sandbox/my_sandbox/apps/first_app/first_app.cpp~ ./sandbox/my_sandbox/apps/first_app/first_app.cpp~
--- ./misc/seqan_instrumentation/last_revision_copy/sandbox/my_sandbox/apps/first_app/first_app.cpp~	2012-09-05 14:20:01.000000000 +0200
+++ ./sandbox/my_sandbox/apps/first_app/first_app.cpp~	2012-09-05 14:57:34.584122302 +0200
@@ -1,12 +1,289 @@
-#include <seqan/sequence.h>
-#include <seqan/index.h>
+// #include <seqan/sequence.h>
+// #include <seqan/index.h>
+// #include <iostream>
+// #include <seqan/sequence_journaled.h>
+// #include <seqan/journaled_set.h>
+// 
+// using namespace std;
+// using namespace seqan;
+// 
+// 
+// template <typename TString, typename TStream, typename TSpec>
+// inline int
+// loadAndJoin(StringSet<TString, Owner<JournaledSet> > & journalSet,
+//             TStream & stream,
+//             JoinConfig<TSpec> const & joinConfig)
+// {
+//     typedef typename Host<TString>::Type THost;
+//     // Define the RecordReader.
+//     RecordReader<std::ifstream, SinglePass<> > reader(stream);
+//     // [A] Ensure the Journal Set is not occupied by other sequences.
+//     clear(journalSet);
+//     // Construct the temporary buffers for the read id and sequence.
+//     String<char> tempSeqId;
+//     THost tempSeq;
+//     // No sequences in the fasta file!
+//     if (atEnd(reader))
+//     {
+//         std::cerr << "Empty FASTA file." << std::endl;
+//         return -1;
+//     }
+//     // First read sequence for reference sequence.
+//     if (readRecord(tempSeqId, tempSeq, reader, Fasta()) != 0)
+//     {
+//         std::cerr << "ERROR reading FASTA." << std::endl;
+//         return 1;
+//     }
+//     // [B] Set the reference sequence to the Journal Set
+//     createGlobalReference(journalSet, tempSeq);
+//     // Read remaining sequences.
+//     while (!atEnd(reader))
+//     {
+//         if (readRecord(tempSeqId, tempSeq, reader, Fasta()) != 0)
+//         {
+//             std::cerr << "ERROR reading FASTA." << std::endl;
+//             return 1;
+//         }
+//         // [C] Append and join the current read sequence.
+//     appendValue(journalSet,tempSeq);
+//     join(journalSet,length(journalSet)-1,joinConfig);  
+//       
+//     }
+//     return 0;
+// }
+// 
+// 
+// template <typename TString, typename TPattern>
+// void searchPattern(StringSet<String<int> > & hitSet,
+//                    StringSet<TString, Owner<JournaledSet> > const & journalSet,
+//                    TPattern const & pattern)
+// {
+//     typedef typename Host<TString>::Type THost;
+//     // Check for valid initial state.
+//     if (empty(globalReference(journalSet)))
+//     {
+//         ::std::cout << "No reference set. Aborted search!" << std::endl;
+//         return;
+//     }
+//     // Reset the hitSet to avoid phantom hits coming from a previous search.
+//     clear(hitSet);
+//     resize(hitSet, length(journalSet) + 1);
+//         // Access the reference sequence.
+//     THost & globalRef = globalReference(journalSet);
+//     // Search for pattern in the reference sequence.
+//     findPatternInReference(hitSet[0], globalRef, pattern);
+//         // Search for pattern in the journaled sequences.
+//     for (unsigned i = 0; i < length(journalSet); ++i)
+//         findPatternInJournalString(hitSet[i+1], journalSet[i], pattern, hitSet[0]);
+// }
+// 
+// 
+// 
+// template <typename TString, typename TPattern>
+// void findPatternInReference(String<int> & hits,
+//                             TString const & reference,
+//                             TPattern const & pattern)
+// {
+//     // [A] Check whether pattern fits into the sequence.
+//     if (length(pattern) > length(reference))
+//         return;
+//     // [B] Iterate over all positions at which the pattern might occur.
+//     for (unsigned pos = 0; pos < length(reference) - length(pattern) + 1; ++pos)
+//     {
+//         bool isHit = true;
+//         // [C] Evaluate all positions of the pattern until you find a mismatch or you have found a hit.
+//         for (unsigned posPattern = 0; posPattern < length(pattern); ++posPattern)
+//         {
+//             if(pattern[posPattern] != reference[posPattern + pos])
+//             {
+//                 isHit = false;
+//                 break;
+//             }
+//         }
+//         // [D] Report begin position at which pattern matches the sequence.
+//         if(isHit)
+//             appendValue(hits, pos);
+//     }
+// }
+// 
+// template <typename TJournalEntriesIterator, typename TPattern>
+// void _findInOriginalNode(String<int> & hitTarget,
+//                          TJournalEntriesIterator & entriesIt,
+//                          TPattern const & pattern,
+//                          String<int> const & refHits)
+// {
+//     // [A] Check if hits exist in the reference.
+//     if(!empty(refHits)){
+//     // [B] Find upper bound to current physical position in sorted refHits using ::std::upper_bound.
+//     THitIterator itHit = std::upper_bound(begin(refHits),end(refHits),entriesIt->physicalPosition);
+//     // [C] Make sure we do not miss hits that begin at physical position of current node.
+//     if(itHit != begin(refHits) && *(itHit - 1) >= (int)entriesIt->physicalPosition)
+//             --itHit;
+//     // [D] Store all hits that are found in the region of the reference which is covered by this node.
+//    while((int)*itHit < ((int)entriesIt->physicalPosition + (int)entriesIt->length - (int)length(pattern) + 1) && itHit != end(refHits))
+//         {
+//             // [E] Store the correct virtual position and check next hit.
+//             appendValue(hitTarget, entriesIt->virtualPosition + (*itHit - (int)entriesIt->physicalPosition));
+//             ++itHit;
+//         }
+//     }
+// }
+// 
+// int main()
+// {
+//     // Definition of the used types.
+//     typedef String<Dna,Alloc<> > TSequence;
+//     typedef String<Dna,Journaled<Alloc<>,SortedArray,Alloc<> > > TJournal;
+//     typedef StringSet< TJournal, Owner<JournaledSet> > TJournaledSet;
+//     // Open the stream to the file containing the sequences.
+//     String<char> seqDatabasePath = "/home/gabriel/Downloads/sequences.fasta";
+//     std::ifstream databaseFile(toCString(seqDatabasePath), std::ios_base::in);
+//     if(!databaseFile.good())
+//     {
+//         std::cerr << "Cannot open file <" << seqDatabasePath << ">!" << std::endl;
+//     }
+//     // Reading each sequence and journal them.
+//     // [D] Construct Journaled Set and call loadAndJoin
+//     TJournaledSet journalSet;
+//     JoinConfig<GlobalAlign<JournaledCompact> > joinConfig;
+//     loadAndJoin(journalSet, databaseFile, joinConfig);
+//     databaseFile.close();
+//     return 0;
+// }
+
 #include <iostream>
-#include <seqan/sequence_journaled.h>
+#include <seqan/find.h>
+#include <seqan/seq_io.h>
 #include <seqan/journaled_set.h>
 
-using namespace std;
 using namespace seqan;
 
+template <typename TJournalEntriesIterator, typename TJournal, typename TPattern>
+void _searchAtBorder(String<int> & hitTarget,
+                    TJournalEntriesIterator & entriesIt,
+                    TJournal const & journal,
+                    TPattern const & needle)
+{
+    typedef typename Position<TJournal>::Type TPosition;
+    // Define region before the border to the next node to search for the pattern.
+    TPosition infixBegin = entriesIt->virtualPosition + _max(0,(int)entriesIt->length - (int)length(needle) + 1);
+    TPosition infixEnd = _min(length(journal),entriesIt->virtualPosition + entriesIt->length + length(needle) - 1);
+    TPattern tmpInsBuffer = infix(journal, infixBegin, infixEnd);
+    Finder<TPattern const> finder(tmpInsBuffer);
+    Pattern<TPattern, Horspool> pattern(needle);
+    while (find(finder, pattern))
+    {
+        appendValue(hitTarget, infixBegin + beginPosition(finder));
+    }
+}
+
+template <typename TJournalEntriesIterator, typename TJournal, typename TPattern>
+void _findInPatchNode(String<int> & hitTarget,
+                      TJournalEntriesIterator & entriesIt,
+                      TJournal const & journal,
+                      TPattern const & needle)
+{
+    typedef typename Position<TJournal>::Type TPosition;
+    TPosition infixBegin = entriesIt->virtualPosition;
+    TPosition infixEnd = entriesIt->virtualPosition + entriesIt->length;
+    TPattern tmpInsBuffer = infix(journal, infixBegin, infixEnd);
+    Finder<TPattern const> finder(tmpInsBuffer);
+    Pattern<TPattern, Horspool> pattern(needle);
+    while (find(finder, pattern))
+        appendValue(hitTarget, entriesIt->virtualPosition + beginPosition(finder));
+}
+
+template <typename TJournalEntriesIterator, typename TPattern>
+void _findInOriginalNode(String<int> & hitTarget,
+                         TJournalEntriesIterator & entriesIt,
+                         TPattern const & pattern,
+                         String<int> const & refHits)
+{
+    // Define an Iterator which iterates over the reference hit set.
+    typedef typename Iterator<String<int> const, Standard>::Type THitIterator;
+    // Check if hits exist in the reference.
+    if(!empty(refHits))
+    {
+        // Find upper bound to physical position in sorted refHits.
+        THitIterator itHit = std::upper_bound(begin(refHits),end(refHits),entriesIt->physicalPosition);
+        // Make sure we do not miss hits that begin at physical position of current node.
+        if(itHit != begin(refHits) && *(itHit - 1) >= (int)entriesIt->physicalPosition)
+            --itHit;
+        // Store all hits that are found in the region of the reference which is covered by this node.
+        while((int)*itHit < ((int)entriesIt->physicalPosition + (int)entriesIt->length - (int)length(pattern) + 1) && itHit != end(refHits))
+        {
+            appendValue(hitTarget, entriesIt->virtualPosition + (*itHit - (int)entriesIt->physicalPosition));
+            ++itHit;
+        }
+    }
+}
+
+template <typename TValue, typename THostSpec, typename TJournalSpec, typename TBufferSpec, typename TPattern>
+void findPatternInJournalString(String<int> & hitTarget,
+                           String<TValue, Journaled<THostSpec, TJournalSpec, TBufferSpec> > const & journal,
+                           TPattern const & pattern,
+                           String<int> const & refHits)
+{
+    typedef String<TValue, Journaled<THostSpec, TJournalSpec, TBufferSpec> > TJournal;
+    typedef typename JournalType<TJournal>::Type TJournalEntries;
+    typedef typename Iterator<TJournalEntries>::Type TJournalEntriesIterator;
+    if (length(pattern) > length(journal))
+        return;
+    TJournalEntriesIterator it = begin(journal._journalEntries);
+    TJournalEntriesIterator itEnd = findInJournalEntries(journal._journalEntries, length(journal) - length(pattern) + 1) + 1;
+    while(it != itEnd)
+    {
+        if (it->segmentSource == SOURCE_ORIGINAL)
+        {   // Find a possible hit in the current source vertex.
+            _findInOriginalNode(hitTarget, it, pattern, refHits);
+        }
+        if (it->segmentSource == SOURCE_PATCH)
+        {  // Search for pattern within the patch node.
+            _findInPatchNode(hitTarget, it, journal, pattern);
+        }
+        // Scan the border for a possible match.
+        _searchAtBorder(hitTarget, it, journal, pattern);
+        ++it;
+    }
+}
+
+template <typename TString>
+void findPatternInReference(String<int> & hits,
+                            TString const & reference,
+                            TString const & needle)
+{
+    // Check whether the pattern fits into the sequence.
+    if (length(needle) > length(reference))
+        return;
+    Finder<TString const> finder(reference);
+    Pattern<TString, Horspool> pattern(needle);
+    while (find(finder, pattern))
+        appendValue(hits, beginPosition(finder));
+}
+
+template <typename TString, typename TPattern>
+void searchPattern(StringSet<String<int> > & hitSet,
+                   StringSet<TString, Owner<JournaledSet> > const & journalSet,
+                   TPattern const & pattern)
+{
+    typedef typename Host<TString>::Type THost;
+    // Check for valid initial state.
+    if (empty(globalReference(journalSet)))
+    {
+        ::std::cout << "No reference set. Aborted search!" << std::endl;
+        return;
+    }
+    // Reset the hitSet to avoid phantom hits coming from a previous search.
+    clear(hitSet);
+    resize(hitSet, length(journalSet) + 1);
+    // Access the reference sequence.
+    THost & globalRef = globalReference(journalSet);
+    // Search for pattern in the reference sequence.
+    findPatternInReference(hitSet[0], globalRef, pattern);
+    // Search for pattern in the journaled sequences.
+    for (unsigned i = 0; i < length(journalSet); ++i)
+        findPatternInJournalString(hitSet[i+1], journalSet[i], pattern, hitSet[0]);
+}
 
 template <typename TString, typename TStream, typename TSpec>
 inline int
@@ -15,13 +292,10 @@
             JoinConfig<TSpec> const & joinConfig)
 {
     typedef typename Host<TString>::Type THost;
-    // Define the RecordReader.
     RecordReader<std::ifstream, SinglePass<> > reader(stream);
-    // [A] Ensure the Journal Set is not occupied by other sequences.
     clear(journalSet);
-    // Construct the temporary buffers for the read id and sequence.
-    String<char> tempSeqId;
-    THost tempSeq;
+    String<char> seqId;
+    THost sequence;
     // No sequences in the fasta file!
     if (atEnd(reader))
     {
@@ -29,54 +303,27 @@
         return -1;
     }
     // First read sequence for reference sequence.
-    if (readRecord(tempSeqId, tempSeq, reader, Fasta()) != 0)
+    if (readRecord(seqId, sequence, reader, Fasta()) != 0)
     {
         std::cerr << "ERROR reading FASTA." << std::endl;
         return 1;
     }
-    // [B] Set the reference sequence to the Journal Set
-    createGlobalReference(journalSet, tempSeq);
-    // Read remaining sequences.
+    // We have to create the global reference sequence otherwise we loose the information after this function terminates.
+    createGlobalReference(journalSet, sequence);
+    // If there are more
     while (!atEnd(reader))
     {
-        if (readRecord(tempSeqId, tempSeq, reader, Fasta()) != 0)
+        if (readRecord(seqId, sequence, reader, Fasta()) != 0)
         {
             std::cerr << "ERROR reading FASTA." << std::endl;
             return 1;
         }
-        // [C] Append and join the current read sequence.
-    appendValue(journalSet,tempSeq);
-    join(journalSet,length(journalSet)-1,joinConfig);  
-      
+        appendValue(journalSet, sequence);
+        join(journalSet, length(journalSet) - 1, joinConfig);
     }
     return 0;
 }
 
-template <typename TString, typename TPattern>
-void findPatternInReference(String<int> & hits,
-                            TString const & reference,
-                            TPattern const & pattern)
-{
-    // [A] Check whether pattern fits into the sequence.
-  if(length(pattern)>lenth(reference)) 
-    return;
-    // [B] Iterate over all positions at which the pattern might occur.
-    for(unsigned i=0;i<length(reference)-length(pattern)+1;i++)
-      bool isHit = true;
-    // [C] Evaluate all positions of the pattern until you find a mismatch or you have found a hit.
-    for (unsigned posPattern = 0; posPattern < length(pattern); ++posPattern)
-        {
-            if(pattern[posPattern] != reference[posPattern + i])
-            {
-                isHit = false;
-                break;
-            }
-        }
-        // [D] Report begin position at which pattern matches the sequence.
-        if(isHit)
-            appendValue(hits,i);
-    }
-
 int main()
 {
     // Definition of the used types.
@@ -84,17 +331,47 @@
     typedef String<Dna,Journaled<Alloc<>,SortedArray,Alloc<> > > TJournal;
     typedef StringSet< TJournal, Owner<JournaledSet> > TJournaledSet;
     // Open the stream to the file containing the sequences.
-    String<char> seqDatabasePath = "/home/gabriel/Downloads/sequences.fasta";
+    String<char> seqDatabasePath = "/Users/rmaerker/Development/workspace_seqan_trunk/build/debug/sandbox/rmaerker/apps/seqGen/sequences.fasta";
+//    String<char> seqDatabasePath =  "/path/to/your/fasta/file/sequences.fasta";
     std::ifstream databaseFile(toCString(seqDatabasePath), std::ios_base::in);
     if(!databaseFile.good())
     {
         std::cerr << "Cannot open file <" << seqDatabasePath << ">!" << std::endl;
     }
     // Reading each sequence and journal them.
-    // [D] Construct Journaled Set and call loadAndJoin
     TJournaledSet journalSet;
     JoinConfig<GlobalAlign<JournaledCompact> > joinConfig;
     loadAndJoin(journalSet, databaseFile, joinConfig);
     databaseFile.close();
+    // Define a pattern and start search.
+    StringSet<String<int> > hitSet;
+    TSequence pattern = "GTGGT";
+    ::std::cout << "Search for: " << pattern << ":\n";
+    searchPattern(hitSet, journalSet, pattern);
+    if (empty(hitSet[0]))
+    {
+        ::std::cout << "No hit in reference " << ::std::endl;
+    }
+    else
+    {
+        ::std::cout << "Hit in reference " << " at ";
+        for (unsigned j = 0; j < length(hitSet[0]); ++j)
+            ::std::cout << hitSet[0][j] << ": " << infix(globalReference(journalSet), hitSet[0][j],hitSet[0][j] + length(pattern)) << "\t";
+    }
+    ::std::cout << ::std::endl;
+    for (unsigned i = 1; i < length(hitSet); ++i)
+    {
+        if (empty(hitSet[i]))
+        {
+            ::std::cout << "No hit in sequence " << i - 1 << ::std::endl;
+        }
+        else
+        {
+            ::std::cout << "Hit in sequence " << i - 1 << " at ";
+            for (unsigned j = 0; j < length(hitSet[i]); ++j)
+                ::std::cout << hitSet[i][j] << ": " << infix(value(journalSet,i-1), hitSet[i][j],hitSet[i][j] + length(pattern)) << "\t";
+        }
+        ::std::cout << ::std::endl;
+    }
     return 0;
 }
\ Kein Zeilenumbruch am Dateiende.
